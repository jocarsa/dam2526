---
slug: chatbots-clasicos
title: Chatbots clásicos (comoprogramar.es)
description: Aprende cómo funcionan los chatbots clásicos basados en reglas, patrones e intención. Diseña sistemas conversacionales controlables, explicables y eficientes sin modelos generativos.
keywords:
  - chatbots clasicos
  - chatbots basados en reglas
  - sistemas conversacionales
  - nlp clasico
  - bots de atencion al cliente
  - dialogos guiados
level: Principiante–Intermedio
duration_estimate: "25-40 horas"
prerequisites:
  - "Procesamiento de texto con Python"
  - "NLP desde cero"
audience:
  - "Desarrolladores"
  - "Profesionales de atención al cliente"
  - "Estudiantes de NLP"
  - "Autodidactas"
updated: 2025-12-26
---

# Chatbots clásicos

## Objetivos del curso

## Cómo usar este curso

## Conversar sin generar texto libre

---

# Unidad 1 — Qué es un chatbot clásico

## 1.1 — Definición y contexto histórico

### Lección 1.1.1 — Primeros chatbots
### Lección 1.1.2 — Diferencia con chatbots generativos
### Lección 1.1.3 — Por qué siguen existiendo

## 1.2 — Casos de uso reales

### Lección 1.2.1 — Atención al cliente
### Lección 1.2.2 — FAQs automatizadas
### Lección 1.2.3 — Flujos guiados

---

# Unidad 2 — Arquitectura general de un chatbot clásico

## 2.1 — Componentes principales

### Lección 2.1.1 — Entrada de usuario
### Lección 2.1.2 — Procesamiento del texto
### Lección 2.1.3 — Motor de diálogo

## 2.2 — Flujo conversacional

### Lección 2.2.1 — Turnos de conversación
### Lección 2.2.2 — Estados
### Lección 2.2.3 — Respuestas deterministas

---

# Unidad 3 — Chatbots basados en reglas

## 3.1 — Reglas simples

### Lección 3.1.1 — if / else conversacional
### Lección 3.1.2 — Coincidencia exacta
### Lección 3.1.3 — Ventajas y límites

## 3.2 — Árboles de decisión

### Lección 3.2.1 — Diálogos ramificados
### Lección 3.2.2 — Control del flujo
### Lección 3.2.3 — Escalabilidad del árbol

---

# Unidad 4 — Chatbots basados en patrones

## 4.1 — Pattern matching

### Lección 4.1.1 — Palabras clave
### Lección 4.1.2 — Expresiones regulares
### Lección 4.1.3 — Coincidencias parciales

## 4.2 — AIML y lenguajes similares

### Lección 4.2.1 — Filosofía de AIML
### Lección 4.2.2 — Categorías y plantillas
### Lección 4.2.3 — Ventajas estructurales

---

# Unidad 5 — Gestión de intención sin ML

## 5.1 — Intención manual

### Lección 5.1.1 — Qué es una intención
### Lección 5.1.2 — Mapeo manual
### Lección 5.1.3 — Ambigüedad

## 5.2 — Contexto y memoria básica

### Lección 5.2.1 — Variables de sesión
### Lección 5.2.2 — Estados persistentes
### Lección 5.2.3 — Recuperación de contexto

---

# Unidad 6 — Diseño de diálogos

## 6.1 — UX conversacional

### Lección 6.1.1 — Claridad y brevedad
### Lección 6.1.2 — Preguntas guiadas
### Lección 6.1.3 — Evitar frustración

## 6.2 — Manejo de errores

### Lección 6.2.1 — Entradas no esperadas
### Lección 6.2.2 — Reintentos
### Lección 6.2.3 — Escalado a humano

---

# Unidad 7 — Idioma y variabilidad

## 7.1 — Variantes lingüísticas

### Lección 7.1.1 — Sinónimos
### Lección 7.1.2 — Errores ortográficos
### Lección 7.1.3 — Lenguaje informal

## 7.2 — Español en chatbots clásicos

### Lección 7.2.1 — Flexión verbal
### Lección 7.2.2 — Formas de cortesía
### Lección 7.2.3 — Regionalismos

---

# Unidad 8 — Limitaciones de los chatbots clásicos

## 8.1 — Problemas estructurales

### Lección 8.1.1 — Escalabilidad
### Lección 8.1.2 — Mantenimiento
### Lección 8.1.3 — Cobertura incompleta

## 8.2 — Expectativas del usuario

### Lección 8.2.1 — Ilusión de inteligencia
### Lección 8.2.2 — Frustración
### Lección 8.2.3 — Diseño honesto

---

# Unidad 9 — Chatbots clásicos en producción

## 9.1 — Integración en sistemas reales

### Lección 9.1.1 — Web
### Lección 9.1.2 — WhatsApp / Telegram
### Lección 9.1.3 — APIs internas

## 9.2 — Monitorización y mejora

### Lección 9.2.1 — Logs de conversación
### Lección 9.2.2 — Análisis de fallos
### Lección 9.2.3 — Iteración guiada por datos

---

# Unidad 10 — Cuándo usar un chatbot clásico

## 10.1 — Casos donde es la mejor opción

### Lección 10.1.1 — Procesos cerrados
### Lección 10.1.2 — Información sensible
### Lección 10.1.3 — Cumplimiento normativo

## 10.2 — Comparación con chatbots modernos

### Lección 10.2.1 — Coste
### Lección 10.2.2 — Control
### Lección 10.2.3 — Riesgo

---

# Unidad 11 — Hibridación básica

## 11.1 — Reglas + ML ligero

### Lección 11.1.1 — Clasificación de intención simple
### Lección 11.1.2 — Fallbacks inteligentes
### Lección 11.1.3 — Transición suave

## 11.2 — Preparar el salto a LLMs

### Lección 11.2.1 — Modularidad
### Lección 11.2.2 — Separación de responsabilidades
### Lección 11.2.3 — Diseño escalable

---

# Unidad 12 — Mini-proyecto de chatbot clásico

## 12.1 — Proyecto guiado completo

### Lección 12.1.1 — Definición del dominio
### Lección 12.1.2 — Diseño de reglas y flujos
### Lección 12.1.3 — Implementación del bot
### Lección 12.1.4 — Pruebas con usuarios
### Lección 12.1.5 — Mejora iterativa

---

# Unidad 13 — Siguientes pasos

## 13.1 — Qué aprender después

### Lección 13.1.1 — Clasificación de intención
### Lección 13.1.2 — Chatbots con Machine Learning
### Lección 13.1.3 — Chatbots con LLMs

## 13.2 — Ruta recomendada en comoprogramar.es

### Lección 13.2.1 — Clasificación de texto
### Lección 13.2.2 — Modelos de lenguaje
### Lección 13.2.3 — Chatbots con IA generativa

---

## Recursos recomendados

## Glosario (opcional)

## Créditos

> Última actualización: **2025-12-26**

