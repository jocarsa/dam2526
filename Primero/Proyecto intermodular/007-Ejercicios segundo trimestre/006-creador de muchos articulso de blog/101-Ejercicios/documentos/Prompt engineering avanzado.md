---
slug: prompt-engineering-avanzado
title: Prompt engineering avanzado (comoprogramar.es)
description: Profundiza en prompt engineering avanzado para sistemas con LLMs. Diseña prompts robustos, seguros y evaluables, integrados en arquitecturas reales con control de calidad, costes y riesgos.
keywords:
  - prompt engineering avanzado
  - prompts avanzados llms
  - diseño de prompts en produccion
  - control de generacion
  - seguridad llms
  - prompting profesional
level: Avanzado
duration_estimate: "40-60 horas"
prerequisites:
  - "Prompt engineering desde cero"
  - "Generación de texto con LLMs"
  - "Introducción a la IA generativa"
audience:
  - "Ingenieros de IA"
  - "Desarrolladores backend"
  - "Arquitectos de sistemas con LLMs"
  - "Product managers técnicos"
updated: 2025-12-26
---

# Prompt engineering avanzado

## Objetivos del curso

## Cómo usar este curso

## Un prompt avanzado es parte del sistema, no del texto

---

# Unidad 1 — Prompt engineering como disciplina de ingeniería

## 1.1 — Del prompt artesanal al prompt industrial

### Lección 1.1.1 — Limitaciones del prompting manual
### Lección 1.1.2 — Prompts como componentes
### Lección 1.1.3 — Prompt ≠ interfaz de usuario

## 1.2 — Prompts en sistemas complejos

### Lección 1.2.1 — Prompts estáticos vs dinámicos
### Lección 1.2.2 — Prompts orquestados
### Lección 1.2.3 — Dependencia del contexto externo

---

# Unidad 2 — Arquitectura interna de prompts

## 2.1 — Separación de responsabilidades

### Lección 2.1.1 — Instrucción
### Lección 2.1.2 — Contexto
### Lección 2.1.3 — Datos de entrada

## 2.2 — Jerarquía y prioridad

### Lección 2.2.1 — Conflictos de instrucciones
### Lección 2.2.2 — Orden y peso semántico
### Lección 2.2.3 — Delimitación estricta

---

# Unidad 3 — Prompts dinámicos y parametrizados

## 3.1 — Plantillas de prompts

### Lección 3.1.1 — Variables y placeholders
### Lección 3.1.2 — Inyección controlada de datos
### Lección 3.1.3 — Validación previa

## 3.2 — Generación de prompts por programas

### Lección 3.2.1 — Prompt builders
### Lección 3.2.2 — Prompts compuestos
### Lección 3.2.3 — Automatización del prompting

---

# Unidad 4 — Prompting multi-paso y razonamiento

## 4.1 — Descomposición de tareas

### Lección 4.1.1 — Planificación previa
### Lección 4.1.2 — Cadena de prompts
### Lección 4.1.3 — Coordinación entre pasos

## 4.2 — Control del razonamiento

### Lección 4.2.1 — Razonamiento implícito vs explícito
### Lección 4.2.2 — Riesgos de sobre-explicitar
### Lección 4.2.3 — Verificabilidad del resultado

---

# Unidad 5 — Prompts con salida estructurada

## 5.1 — Diseñar para JSON y esquemas

### Lección 5.1.1 — Especificación de formato
### Lección 5.1.2 — Campos obligatorios
### Lección 5.1.3 — Errores frecuentes

## 5.2 — Validación de salidas

### Lección 5.2.1 — Validación sintáctica
### Lección 5.2.2 — Validación semántica
### Lección 5.2.3 — Reintentos automáticos

---

# Unidad 6 — Prompt engineering y RAG

## 6.1 — Inyección de contexto recuperado

### Lección 6.1.1 — Separar hechos e instrucciones
### Lección 6.1.2 — Contexto confiable
### Lección 6.1.3 — Saturación de contexto

## 6.2 — Control de fuentes

### Lección 6.2.1 — Citar o no citar
### Lección 6.2.2 — Priorización de documentos
### Lección 6.2.3 — Conflictos entre fuentes

---

# Unidad 7 — Robustez frente a fallos del modelo

## 7.1 — Manejo de alucinaciones

### Lección 7.1.1 — Señales tempranas
### Lección 7.1.2 — Prompts defensivos
### Lección 7.1.3 — Fallbacks programáticos

## 7.2 — Control de incertidumbre

### Lección 7.2.1 — Forzar “no sé”
### Lección 7.2.2 — Respuestas condicionadas
### Lección 7.2.3 — Umbrales de confianza

---

# Unidad 8 — Seguridad avanzada en prompting

## 8.1 — Prompt injection avanzada

### Lección 8.1.1 — Inyección indirecta
### Lección 8.1.2 — Ataques por contexto
### Lección 8.1.3 — Casos reales

## 8.2 — Estrategias defensivas

### Lección 8.2.1 — Separación de canales
### Lección 8.2.2 — Sanitización de entradas
### Lección 8.2.3 — Reglas de salida

---

# Unidad 9 — Evaluación de prompts

## 9.1 — Métricas prácticas

### Lección 9.1.1 — Exactitud
### Lección 9.1.2 — Consistencia
### Lección 9.1.3 — Utilidad

## 9.2 — Testing sistemático

### Lección 9.2.1 — Casos de prueba
### Lección 9.2.2 — Comparación A/B
### Lección 9.2.3 — Regressions

---

# Unidad 10 — Coste y eficiencia

## 10.1 — Prompts y consumo de tokens

### Lección 10.1.1 — Longitud del prompt
### Lección 10.1.2 — Coste por llamada
### Lección 10.1.3 — Optimización de contexto

## 10.2 — Estrategias de reducción de coste

### Lección 10.2.1 — Resúmenes intermedios
### Lección 10.2.2 — Cacheo de resultados
### Lección 10.2.3 — Selección de modelo

---

# Unidad 11 — Prompt engineering en producción

## 11.1 — Gestión de prompts

### Lección 11.1.1 — Versionado
### Lección 11.1.2 — Trazabilidad
### Lección 11.1.3 — Auditoría

## 11.2 — Mantenimiento a largo plazo

### Lección 11.2.1 — Drift del modelo
### Lección 11.2.2 — Actualización controlada
### Lección 11.2.3 — Deuda técnica en prompts

---

# Unidad 12 — Mini-proyecto avanzado

## 12.1 — Proyecto integral

### Lección 12.1.1 — Definición del sistema
### Lección 12.1.2 — Diseño de arquitectura de prompts
### Lección 12.1.3 — Implementación y pruebas
### Lección 12.1.4 — Evaluación y mejora
### Lección 12.1.5 — Documentación técnica

---

# Unidad 13 — Siguientes pasos

## 13.1 — Qué aprender después

### Lección 13.1.1 — Fine-tuning de LLMs
### Lección 13.1.2 — Agentes autónomos
### Lección 13.1.3 — Sistemas multimodales complejos

## 13.2 — Ruta recomendada en comoprogramar.es

### Lección 13.2.1 — Sistemas RAG avanzados
### Lección 13.2.2 — Evaluación y seguridad en LLMs
### Lección 13.2.3 — Arquitecturas de agentes con IA

---

## Recursos recomendados

## Glosario (opcional)

## Créditos

> Última actualización: **2025-12-26**

