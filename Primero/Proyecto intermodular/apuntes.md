# Proyecto intermodular

**Author:** Jose Vicente Carratala Sanchis

## Table of contents

- [Búsqueda de información](#busqueda-de-informacion)
  - [Identificar empresas representativas](#identificar-empresas-representativas)
  - [Estructura de las empresas](#estructura-de-las-empresas)
  - [Caracteristicas de los departamentos](#caracteristicas-de-los-departamentos)
  - [Funciones de cada departamento](#funciones-de-cada-departamento)
  - [Evaluacion del volumen de negocio](#evaluacion-del-volumen-de-negocio)
  - [Estrategia para dar respuesta a las demandas](#estrategia-para-dar-respuesta-a-las-demandas)
  - [Valoracion de recursos humanos y materiales](#valoracion-de-recursos-humanos-y-materiales)
  - [Realización de seguimiento](#realizacion-de-seguimiento)
  - [Desarrollo sostenible](#desarrollo-sostenible)
  - [Conexion intermodular](#conexion-intermodular)
- [Selección de un servicio o producto](#seleccion-de-un-servicio-o-producto)
  - [Identificar las necesidades](#identificar-las-necesidades)
  - [Plantear posibles soluciones](#plantear-posibles-soluciones)
  - [Información relativa a las soluciones](#informacion-relativa-a-las-soluciones)
  - [Aspectos innovadores](#aspectos-innovadores)
  - [Estudio de viabilidad técnica](#estudio-de-viabilidad-tecnica)
  - [Partes del proyecto](#partes-del-proyecto)
  - [Recursos materiales y humanos necesarios](#recursos-materiales-y-humanos-necesarios)
  - [Realización de presupuestos económicos](#realizacion-de-presupuestos-economicos)
  - [Documentación para el diseño](#documentacion-para-el-diseno)
  - [Aspectos sobre la calidad del proyecto](#aspectos-sobre-la-calidad-del-proyecto)
  - [Presentación en público de las ideas más relevantes](#presentacion-en-publico-de-las-ideas-mas-relevantes)
- [Propuesta de empresa spin off](#propuesta-de-empresa-spin-off)
  - [Temporalización de las secuencias de las actividades](#temporalizacion-de-las-secuencias-de-las-actividades)
  - [Determinacion de recursos y logistica de cada actividad](#determinacion-de-recursos-y-logistica-de-cada-actividad)
  - [Permisos y autorizaciones necesarios](#permisos-y-autorizaciones-necesarios)
  - [Actividades que implican riesgos](#actividades-que-implican-riesgos)
  - [PRL](#prl)
  - [Recursos materiales y humanos de cada actividad](#recursos-materiales-y-humanos-de-cada-actividad)
  - [Posibles imprevistos](#posibles-imprevistos)
  - [Documentación necesaria](#documentacion-necesaria)
- [Relacion de unidad de empresa](#relacion-de-unidad-de-empresa)
  - [Procedimiento de seguimiento de las actividades](#procedimiento-de-seguimiento-de-las-actividades)
  - [Verificación de la calidad de los resultados de las actividades](#verificacion-de-la-calidad-de-los-resultados-de-las-actividades)
  - [Identificación de posibles desviaciones en planificación](#identificacion-de-posibles-desviaciones-en-planificacion)
  - [Información de posibles desviaciones](#informacion-de-posibles-desviaciones)
  - [Solución y documentación de las desviaciones](#solucion-y-documentacion-de-las-desviaciones)
  - [Definición y elaboración de documentación](#definicion-y-elaboracion-de-documentacion)
- [Transmision de informacion](#transmision-de-informacion)
  - [Actitud ordenada y metódica](#actitud-ordenada-y-metodica)
  - [Transmisión de información horizontal y vertical](#transmision-de-informacion-horizontal-y-vertical)
  - [Uso de medios informáticos para transmitijr información](#uso-de-medios-informaticos-para-transmitijr-informacion)
  - [Términos técnicos en otras lenguajes estándares del sector](#terminos-tecnicos-en-otras-lenguajes-estandares-del-sector)
- [Ejercicios](#ejercicios)
  - [Full Stack en el servidor](#full-stack-en-el-servidor)
  - [Conexion programacion y SQL](#conexion-programacion-y-sql)
  - [Refresco full stack](#refresco-full-stack)
  - [Simulacro parte 1](#simulacro-parte-1)
  - [Simulacro examen 1](#simulacro-examen-1)
  - [Simulacro examen 2](#simulacro-examen-2)
  - [Simulacro examen 3](#simulacro-examen-3)
  - [Resolucion de dudas](#resolucion-de-dudas)
  - [Examen final](#examen-final)
  - [Instalacion de Ollama](#instalacion-de-ollama)
- [Ejercicios segundo trimestre](#ejercicios-segundo-trimestre)
  - [Proyecto Piero](#proyecto-piero)
  - [Primer contacto con PHP](#primer-contacto-con-php)
  - [proyecto ollama menus saludables](#proyecto-ollama-menus-saludables)
  - [Proyecto ollama curriculums](#proyecto-ollama-curriculums)
- [Actividad libre de final de evaluación - La milla extra](#actividad-libre-de-final-de-evaluacion-la-milla-extra)
  - [La Milla Extra - Primera evaluación](#la-milla-extra-primera-evaluacion)
- [Carpeta sin título](#carpeta-sin-titulo)

---

<a id="busqueda-de-informacion"></a>
# Búsqueda de información

<a id="identificar-empresas-representativas"></a>
## Identificar empresas representativas

### Introducción a los ejercicios

En esta carpeta encontrarás un ejercicio que te ayudará a comprender mejor el panorama actual de la inteligencia artificial (IA) tanto a nivel global como local en Valencia. El objetivo principal es identificar y analizar las empresas representativas del sector IA tanto en escala internacional como entre las start-ups valencianas, lo cual te permitirá tener una visión holística del mercado y sus oportunidades. Además de estudiar casos concretos de compañías líderes mundiales como DeepSeek, Copilot o OpenAI, también se enfatiza el análisis de empresas locales que están innovando en diversos sectores. Este ejercicio es fundamental para desarrollar habilidades de investigación y análisis de mercado, además de potenciar tu capacidad para identificar nichos de oportunidad en un sector tan dinámico como la IA.

### Actividades propuestas

### Actividades Propuestas para Estudiantes de Formación Profesional

1. **Análisis de Mercado en IA**
   - **Descripción**: Los estudiantes deben analizar el mercado actual de inteligencia artificial identificando a los principales actores globales y locales, como Deepseek, OpenAI, Grok, etc., para comprender sus características y servicios ofertados.
   - **Objetivo**: Familiarizarse con la industria de IA y reconocer las diferencias entre grandes empresas y startups locales.

2. **Identificación de Oportunidades Locales**
   - **Descripción**: Los estudiantes deberán identificar oportunidades no cubiertas en el mercado local valenciano para proyectos relacionados con la inteligencia artificial.
   - **Objetivo**: Aprender a detectar nichos de mercado y necesidades específicas que pueden ser abordadas por pequeñas o medianas empresas.

3. **Evaluación del Impacto Energético**
   - **Descripción**: Los estudiantes deben evaluar el impacto energético de diferentes modelos de IA, como Deepseek y OpenAI, y compararlos en términos de eficiencia.
   - **Objetivo**: Entender los factores técnicos que influyen en la sostenibilidad de las tecnologías de IA.

4. **Comparativa entre Soluciones Globales y Locales**
   - **Descripción**: Los estudiantes deben realizar una comparativa entre soluciones globales (como Copilot) y locales (como Maisa o Aitister).
   - **Objetivo**: Analizar ventajas y desventajas de implementar tecnologías desarrolladas localmente frente a las internacionales.

5. **Investigación sobre Startups Valencianas**
   - **Descripción**: Los estudiantes deben investigar sobre las startups valencianas relacionadas con IA, sus productos o servicios, y su impacto en el mercado.
   - **Objetivo**: Conocer a fondo empresas locales relevantes y comprender sus estrategias de desarrollo.

6. **Generación de Ideas Innovadoras**
   - **Descripción**: Los estudiantes deben proponer ideas innovadoras para proyectos relacionados con IA que sean viables y adaptables al contexto valenciano.
   - **Objetivo**: Estimular la creatividad y el pensamiento crítico para desarrollar soluciones prácticas.

7. **Análisis de Competencia**
   - **Descripción**: Los estudiantes deben analizar a las empresas competidoras en IA, identificando sus fortalezas y debilidades.
   - **Objetivo**: Comprender el entorno competitivo del mercado y aprender a hacer análisis SWOT.

8. **Estrategias de Marketing para Startups**
   - **Descripción**: Los estudiantes deben diseñar estrategias de marketing adecuadas para una startup valenciana dedicada a la IA.
   - **Objetivo**: Aprender las técnicas y herramientas necesarias para promocionar proyectos tecnológicos.

9. **Diseño de Productos Personalizados**
   - **Descripción**: Los estudiantes deben proponer el diseño de productos personalizados basados en las necesidades del mercado local identificadas.
   - **Objetivo**: Desarrollar habilidades en diseño y desarrollo de soluciones tecnológicas orientadas al usuario final.

10. **Evaluación de Riesgos**
    - **Descripción**: Los estudiantes deben evaluar los riesgos asociados a la implementación de un proyecto basado en IA, tanto técnicos como económicos.
    - **Objetivo**: Adquirir habilidades para identificar y mitigar posibles desafíos en el desarrollo de proyectos tecnológicos.


<a id="estructura-de-las-empresas"></a>
## Estructura de las empresas

### Introducción a los ejercicios

Este conjunto de ejercicios se centra en la búsqueda y análisis de información sobre el tamaño y estructura del mercado de empresas tecnológicas, específicamente en inteligencia artificial (IA), en la ciudad de Valencia. Los estudiantes explorarán datos clave para entender el entorno empresarial actual, identificar oportunidades en diferentes sectores y evaluar las amenazas que enfrentan al competir en este mercado emergente. Se practicarán competencias como análisis de datos, evaluación del potencial comercial, identificación de nichos competitivos y estrategia empresarial para nuevos proyectos tecnológicos.

### Actividades propuestas

### Actividad 1: Análisis del Ecosistema Empresarial en Valencia

**Descripción:** Estudia el archivo proporcionado y realiza un análisis comparativo entre la cantidad de empresas existentes en España y Valencia. Identifica qué tipos de industrias tienen mayor presencia en Valencia y cómo esto podría influir en el mercado de IA. Este ejercicio ayudará a los estudiantes a comprender mejor las tendencias del sector empresarial local.

### Actividad 2: Desarrollo de Estrategias Empresariales

**Descripción:** Basándote en la información sobre startups e industrias clave, desarrolla estrategias para una empresa que desee entrar en el mercado de IA en Valencia. Propón qué tipo de soluciones especializadas podrían ofrecerse y cómo diferenciarse frente a la competencia existente.

### Actividad 3: Evaluación de Sectores Potenciales

**Descripción:** Elige tres sectores industriales que consideras prometedores para el negocio de IA en Valencia. Justifica tu elección basándote en los datos proporcionados y explora las oportunidades y desafíos que podrían surgir.

### Actividad 4: Análisis de Amenazas Competitivas

**Descripción:** Analiza detalladamente las amenazas competitivas identificadas en el archivo. Considera qué medidas una empresa podría tomar para mitigar riesgos como la resistencia al cambio o los costes elevados de adopción.

### Actividad 5: Identificación de Nichos Específicos

**Descripción:** Busca nichos específicos dentro del mercado empresarial en Valencia donde las empresas pequeñas y medianas podrían competir de manera efectiva. Describe cómo estos nichos pueden ser utilizados para desarrollar soluciones personalizadas.

### Actividad 6: Propuesta de Solución Híbrida

**Descripción:** Diseña una propuesta que combine componentes genéricos y personalizados en el desarrollo de aplicaciones de IA para pymes. Explica cómo esta estrategia puede atraer a más clientes mientras mantiene la rentabilidad.

### Actividad 7: Evaluación del Mercado Local

**Descripción:** Crea un informe detallado sobre el mercado local de Valencia, incluyendo estimaciones numéricas de empresas en diferentes sectores. Identifica los segmentos del mercado que tienen mayor potencial para servicios de IA y propón estrategias específicas para estos nichos.

### Actividad 8: Desarrollo de Alianzas Estratégicas

**Descripción:** Elabora una lista de posibles aliados estratégicos en Valencia (universidades, clústers industriales, cámaras de comercio) y describe cómo estas asociaciones podrían beneficiar a la empresa en el desarrollo y adopción de soluciones basadas en IA. 

### Actividad 9: Estrategia de Concienciación

**Descripción:** Propón una estrategia para la formación y educación empresarial sobre IA, incluyendo workshops, seminarios web y cursos especializados que ayuden a las pymes a entender el valor potencial de estas tecnologías.

### Actividad 10: Gestión de Privacidad y Ética

**Descripción:** Analiza cómo la gestión ética y privacidad de datos puede convertirse en un distintivo competitivo para una empresa emergente en IA. Diseña un plan que asegure cumplimiento de las regulaciones locales mientras se construye confianza entre los clientes potenciales.


<a id="caracteristicas-de-los-departamentos"></a>
## Caracteristicas de los departamentos

### Introducción a los ejercicios

Este archivo es una guía práctica sobre cómo abordar diferentes departamentos dentro de las pymes y empresas de inteligencia artificial (IA). La idea principal es entender quién decide, quién usa, quién bloquea y dónde duele en cada departamento para poder orientar la oferta y el discurso de productos relacionados con IA. El ejercicio se enfoca en comprender los roles típicos dentro de departamentos como Dirección, Operaciones, Marketing, Ventas, entre otros, tanto en clientes potenciales (pymes) como en competidores (empresas de IA). También se practica la identificación de puntos débiles y fortalezas en cada departamento para poder elaborar estrategias más efectivas. Se enfatiza la importancia de personalizar las soluciones según el tamaño del cliente y su sector específico, así como cómo abordar los bloqueadores legales o técnicos que puedan surgir durante la implementación de nuevas tecnologías.

### Actividades propuestas

### Actividad 1: Análisis de Características Departamentales

**Descripción:** Estudia el contenido del archivo proporcionado y elabora un resumen de las características principales de los departamentos tanto para clientes potenciales (pymes valencianas) como para empresas de la competencia (proveedores de IA). Identifica quién decide, quien usa, quién bloquea y dónde duele en cada contexto. Aprenderás a analizar estructuras organizativas y roles clave dentro de una empresa.

### Actividad 2: Mapa de Compra en Pymes

**Descripción:** Diseña un mapa de compra simplificado para pymes valencianas basado en el documento proporcionado, identificando los campeones, económicos, aprobadores técnicos y bloqueadores. Aprenderás cómo estructurar una estrategia de venta teniendo en cuenta los roles clave dentro del cliente potencial.

### Actividad 3: Identificación de Fortalezas y Debilidades Competitivas

**Descripción:** Analiza el apartado "Departamentos típicos en COMPETIDORES (empresas de IA)" y elabora un informe que identifica las fortalezas y debilidades de los competidores. Aprenderás a realizar análisis competitivos básicos para mejorar la estrategia empresarial.

### Actividad 4: Estrategias para Atacar Competidores

**Descripción:** Basándote en el apartado "Cómo atacarles", propone tres estrategias distintas para competir con empresas de IA. Aprenderás a desarrollar tácticas estratégicas para superar a la competencia en un entorno empresarial.

### Actividad 5: Análisis Vertical por Tamaño

**Descripción:** Estudia las secciones que describen pymes "micro", "pequeña", "mediana" y "grande". Escribe una breve descripción de cómo varían los roles, decisiones y presupuestos según el tamaño de la empresa. Aprenderás sobre la estructura organizativa en diferentes tamaños empresariales.

### Actividad 6: Desarrollo de Scripts de Acercamiento

**Descripción:** Diseña un script de acercamiento para cada uno de los departamentos principales mencionados (IT, Marketing, Ventas). Aprenderás a crear scripts efectivos para iniciar el contacto con diferentes departamentos y roles dentro de una empresa.

### Actividad 7: Identificación de KPIs Importantes

**Descripción:** Para cada departamento en la sección "Departamentos típicos en CLIENTES (pymes/medianas)", identifica los tres principales KPIs mencionados. Aprenderás a relacionar métricas clave con roles y responsabilidades dentro de una organización.

### Actividad 8: Descripción Rápida de Vertical

**Descripción:** Para cada vertical (industria, retail/hostelería, salud/regulado, logística), escribe una descripción rápida que destaque los aspectos más relevantes a considerar al acercarse al cliente. Aprenderás a entender las particularidades de diferentes industrias y cómo abordarlas desde el punto de vista del vendedor.

Estas actividades ayudarán a los estudiantes a comprender mejor la estructura organizativa interna de las empresas, así como a desarrollar habilidades para acercarse y negociar con clientes potenciales y competidores.


<a id="funciones-de-cada-departamento"></a>
## Funciones de cada departamento

### Introducción a los ejercicios

En esta unidad de ejercicios, se centra en la comprensión y aplicación práctica de funciones dentro del desarrollo de software orientado a diferentes departamentos. El objetivo principal es enseñar cómo dividir tareas complejas en bloques más manejables mediante el uso de funciones, lo que facilita tanto la codificación como la depuración de errores. Los estudiantes aprenderán a diseñar y utilizar funciones específicas para cada departamento o tarea, promoviendo así una estructura modular en los programas.

A través de este ejercicio, se enfatiza la importancia de la organización del código, la reutilización de códigos y el entendimiento de cómo las diferentes partes de un sistema interactúan. Los estudiantes adquirirán habilidades clave como la capacidad para definir funciones claras y eficientes, pasar argumentos a estas funciones y devolver valores pertinentes según sea necesario.

### Actividades propuestas

### Actividad 1: Desarrolla funciones específicas para cada departamento

**Descripción:** Los estudiantes deben crear una estructura modular en un archivo Markdown, donde cada sección represente las funciones y responsabilidades del departamento correspondiente. Se espera que los alumnos identifiquen claramente la funcionalidad de diferentes departamentos dentro de una organización a través de la creación de esta documentación.

### Actividad 2: Organiza información con listas ordenadas

**Descripción:** Los estudiantes deben tomar las funciones y responsabilidades identificadas en el departamento anterior y organizarlas utilizando listas ordenadas en Markdown. Esta actividad ayuda a los alumnos a mejorar sus habilidades en la estructuración y presentación de información.

### Actividad 3: Añade descripciones detalladas

**Descripción:** Los estudiantes deben agregar una breve descripción para cada función dentro del departamento, usando bloques de texto enriquecido en Markdown. Esto mejora las competencias de redacción técnica y la capacidad de explicar conceptos complejos con claridad.

### Actividad 4: Introduce enlaces internos

**Descripción:** Los estudiantes deben incorporar enlaces entre los diferentes departamentos, creando un sistema interconectado de funciones. Esto les enseña a crear referencias y vincular información relevante para mejorar la navegabilidad del documento.

### Actividad 5: Realiza una revisión exhaustiva

**Descripción:** Cada estudiante debe realizar una revisión exhaustiva del trabajo realizado por sus compañeros, buscando errores de formato o estructura. Esta actividad fomenta el pensamiento crítico y la colaboración entre los estudiantes.

### Actividad 6: Documenta las mejoras propuestas

**Descripción:** Los estudiantes deben documentar las mejoras sugeridas a partir de la revisión que realizaron en actividades anteriores, explicando por qué son necesarias. Esto les ayuda a desarrollar habilidades de comunicación y argumentación técnica.

### Actividad 7: Crea un resumen del departamento

**Descripción:** Los estudiantes deben redactar un breve resumen sobre las funciones principales del departamento que han estudiado, usando Markdown para dar énfasis al contenido más importante. Esta actividad fortalece la capacidad de sintetizar información y presentarla claramente.

### Actividad 8: Implementa una tabla comparativa

**Descripción:** Los estudiantes deben crear una tabla en Markdown que compare las funciones esenciales entre diferentes departamentos dentro de la misma organización, destacando similitudes y diferencias. Esto les ayuda a entender mejor el funcionamiento interno de una empresa o institución.

### Actividad 9: Organiza un seminario

**Descripción:** Los estudiantes deben organizar un pequeño seminario en grupo para presentar los resultados obtenidos durante las actividades anteriores, usando Markdown como base para la preparación. Esto mejora sus habilidades de presentación y comunicación oral.

### Actividad 10: Propone nuevas funciones basadas en análisis

**Descripción:** Los estudiantes deben analizar las necesidades actuales del departamento estudiado y proponer nuevas funciones que podrían ser útiles, utilizando Markdown para documentar estas propuestas. Esto les ayuda a pensar de manera estratégica sobre la evolución organizacional.


<a id="evaluacion-del-volumen-de-negocio"></a>
## Evaluacion del volumen de negocio

### Introducción a los ejercicios

Este conjunto de ejercicios se centra en el análisis y modelado del volumen de negocio futuro para una empresa que ofrece servicios de Inteligencia Artificial (IA) a pequeñas y medianas empresas (pymes) en la Comunidad Valenciana. El ejercicio proporciona un modelo detallado, incluyendo datos históricos y proyecciones futuras basadas en tres escenarios: conservador, base y ambicioso. Los estudiantes practicarán habilidades de análisis financiero, interpretación de tendencias del mercado, y modelización empresarial para prever el potencial de crecimiento a largo plazo dentro de un contexto regional específico.

### Actividades propuestas

### Actividad 1: Análisis de Mercado y Segmentación

**Descripción:** 
Los estudiantes deben analizar el tamaño del mercado y la segmentación empresarial en la Comunitat Valenciana basándose en los datos proporcionados. Se espera que identifiquen las empresas potenciales de interés (pymes de 10–199 empleados) y discutan cómo este mercado está evolucionando con respecto a la adopción de IA.

**Objetivo:**
Aprender a realizar análisis de mercado y segmentación empresarial, identificando oportunidades basadas en datos macroeconómicos y tendencias tecnológicas actuales.

### Actividad 2: Crear un Modelo de Ingresos

**Descripción:** 
Los estudiantes deberán crear un modelo simplificado que refleje los ingresos anuales de una empresa de IA en la Comunitat Valenciana, basándose en escenarios conservador, base y ambicioso. Deben tomar en cuenta el histórico, la situación actual y las proyecciones futuras.

**Objetivo:**
Entender cómo se construyen modelos financieros para empresas emergentes y evaluar diferentes hipótesis de crecimiento en función del mercado y la competencia.

### Actividad 3: Evaluar Escenarios Financieros

**Descripción:** 
Los estudiantes deben comparar los escenarios conservador, base y ambicioso presentados y discutir las implicaciones financieras a corto y largo plazo para una empresa de servicios de IA. Se les pedirá que analicen los riesgos y oportunidades asociadas con cada uno.

**Objetivo:**
Desarrollar habilidades en la evaluación financiera y proyección económica, identificando factores clave que influyen en el rendimiento empresarial a largo plazo.

### Actividad 4: Estudio de Viabilidad Empresarial

**Descripción:** 
Los estudiantes deben realizar un análisis más profundo sobre la viabilidad del modelo de negocio descrito. Se les pedirá que evalúen aspectos como la capacidad comercial local, el potencial de expansión y las estrategias para mantenerse competitivos en el mercado.

**Objetivo:**
Aprender a realizar estudios de viabilidad empresarial integrando datos económicos, tecnológicos y estratégicos para determinar la factibilidad de nuevos negocios o productos.

### Actividad 5: Propuesta de Productos y Servicios

**Descripción:** 
Los estudiantes deben proponer un conjunto de productos y servicios que podrían ofrecer una empresa de IA en la Comunitat Valenciana, basándose en las necesidades identificadas por el análisis del mercado y los escenarios financieros.

**Objetivo:**
Desarrollar habilidades en innovación y diseño de producto/servicio para responder a demandas específicas del mercado, integrando tecnologías emergentes como la IA.

### Actividad 6: Canales de Distribución e Ingreso

**Descripción:** 
Los estudiantes deben identificar los canales más efectivos para comercializar servicios de IA en pymes de la Comunitat Valenciana. Se les pedirá que evalúen el potencial de diferentes socios y programas de apoyo público.

**Objetivo:**
Aprender a diseñar estrategias de distribución y ventas basadas en conocimientos del mercado local, promoviendo una presencia efectiva en el mercado objetivo.

### Actividad 7: Análisis de Tendencias y Futuro

**Descripción:** 
Los estudiantes deben analizar las tendencias actuales y futuras que podrían afectar la adopción de servicios de IA en pymes. Se les pedirá que propongan estrategias para mantenerse alineados con estas tendencias.

**Objetivo:**
Desarrollar habilidades en el análisis estratégico del futuro, identificando oportunidades y amenazas basadas en tendencias tecnológicas y económicas emergentes.

### Actividad 8: Informe de Evaluación Financiera

**Descripción:** 
Los estudiantes deben redactar un informe que evalúe la viabilidad financiera a largo plazo del modelo empresarial presentado, incluyendo recomendaciones sobre cómo mejorar el rendimiento financiero y estrategias para superar desafíos potenciales.

**Objetivo:**
Aprender a redactar informes financieros estructurados que analicen la viabilidad económica de un negocio emergente en un mercado específico, proporcionando recomendaciones basadas en análisis detallados.


<a id="estrategia-para-dar-respuesta-a-las-demandas"></a>
## Estrategia para dar respuesta a las demandas

### Introducción a los ejercicios

En esta carpeta, se encuentran dos ejercicios relacionados con la identificación de demandas y soluciones tecnológicas en el ámbito empresarial, específicamente para pequeñas y medianas empresas (Pymes) valencianas. El primer ejercicio analiza las necesidades de diferentes áreas funcionales dentro de una empresa, como dirección estratégica, producción, logística, ventas y marketing, entre otras, con énfasis en cómo la inteligencia artificial puede ayudar a resolver problemas específicos. El segundo ejercicio se centra en el sector educativo para explorar similares demandas pero adaptadas al entorno académico. Estos ejercicios buscan desarrollar competencias en análisis de requerimientos del mercado, diseño de soluciones tecnológicas y estrategia comercial orientada a la innovación.

### Actividades propuestas

### Actividad 1: Análisis de Demanda Empresarial
**Descripción:** Los estudiantes deben analizar el documento "Que necesitan las empresas" y extraer los principales requisitos que las pequeñas y medianas empresas (Pymes) valencianas tienen para la implementación de soluciones basadas en Inteligencia Artificial. Se espera que identifiquen qué áreas funcionales son más demandantes y qué tipo de productos/servicios podrían ofrecerse para satisfacer estas necesidades.

### Actividad 2: Diseño de MVP
**Descripción:** Basándose en las demandas extraídas del documento anterior, los estudiantes deberán diseñar un Producto Mínimo Viable (MVP) que pueda ser implementado en una Pyme. La tarea consiste en seleccionar una área funcional clave y crear un concepto innovador para abordar alguna de las necesidades identificadas.

### Actividad 3: Consultoría Estratégica
**Descripción:** Los estudiantes trabajarán en grupos para desarrollar estrategias que permitan a las Pymes justificar la inversión en soluciones basadas en IA. El objetivo es presentar un plan estratégico que incluya métricas de ROI y rápidas ganancias visibles.

### Actividad 4: Investigación de Mercado
**Descripción:** Cada grupo deberá investigar el mercado local para identificar las tendencias actuales en la implementación de IA dentro de las Pymes valencianas. Se espera que generen un informe breve resumiendo los hallazgos y sugiriendo áreas con potencial para innovación.

### Actividad 5: Desarrollo de Herramienta Predictiva
**Descripción:** En esta actividad, los estudiantes deben diseñar una herramienta predictiva basada en Machine Learning que pueda ser útil en el contexto empresarial. La tarea incluye la definición del problema a resolver y la conceptualización de un modelo predictivo.

### Actividad 6: Integración con Sistemas Existentes
**Descripción:** Los estudiantes deberán investigar cómo una solución basada en IA podría integrarse fácilmente con sistemas existentes como ERP, CRM o web. Se espera que diseñen una propuesta tecnológica sencilla y adaptable a diversas infraestructuras empresariales.

### Actividad 7: Implementación de Visión Artificial
**Descripción:** Con base en las necesidades de mejora en calidad y reducción de costes identificadas, los estudiantes deberán investigar cómo la visión artificial puede ser implementada en entornos industriales. Se espera que presenten un caso de uso concreto para una industria local.

### Actividad 8: Formación Adaptativa
**Descripción:** Los estudiantes deben diseñar un sistema de formación personalizada para empleados basado en Inteligencia Artificial. La tarea incluye la definición del problema, el desarrollo de un modelo adaptativo y la presentación de un caso de uso práctico.

### Actividad 9: Evaluación de Cumplimiento Legal
**Descripción:** Los estudiantes trabajarán en grupos para investigar cómo las soluciones basadas en IA deben cumplir con las regulaciones locales y europeas, especialmente con respecto a GDPR. Se espera que diseñen un plan de auditoría o asesoramiento legal que garantice el cumplimiento.

### Actividad 10: Desarrollo de Chatbots
**Descripción:** Los estudiantes deberán investigar cómo los chatbots personalizados pueden mejorar la interacción entre las empresas y sus clientes. La tarea incluye diseñar un chatbot funcional para una web o aplicación móvil, con énfasis en su integración con sistemas existentes como CRM.

Estas actividades están diseñadas para que los estudiantes apliquen lo aprendido sobre Inteligencia Artificial a situaciones prácticas dentro del contexto empresarial.


<a id="valoracion-de-recursos-humanos-y-materiales"></a>
## Valoracion de recursos humanos y materiales

### Introducción a los ejercicios

En esta carpeta de ejercicios se aborda la planificación y valoración de recursos humanos y materiales necesarios para el desarrollo y lanzamiento de un portafolio de servicios educativos basados en inteligencia artificial. Los ejercicios incluyen la estimación detallada del equipo necesario, desde desarrolladores hasta expertos en educación, así como la infraestructura requerida (hardware, software y nube), todo ello con el fin de calcular costes totales para el primer año. También se analizan estrategias de financiación inicial y modelos comerciales mínimos viables que permiten arrancar con un presupuesto limitado. Estos ejercicios ayudan a desarrollar competencias en gestión de proyectos, análisis de costos, planificación estratégica y modelización comercial para startups tecnológicas en el ámbito educativo.

### Actividades propuestas

### Actividad 1: Planificación de Recursos Iniciales

**Descripción:** Los estudiantes deben crear un documento similar al contenido del archivo "001-Necesidades de recursos.md", pero adaptado a su propio proyecto de software. Deben identificar los productos o servicios clave, los roles necesarios en el equipo y estimar los costos asociados para una pequeña empresa.

**Objetivo:** Aprender a planificar y presupuestar recursos humanos y materiales para un proyecto de desarrollo de software.

### Actividad 2: Búsqueda de Recursos Mínimos

**Descripción:** Basándose en el contenido del archivo "002-arranque minimo.md", los estudiantes deben investigar y seleccionar las tecnologías y recursos necesarios para lanzar un producto mínimo viable (MVP) con bajo presupuesto. 

**Objetivo:** Familiarizarse con la estrategia de desarrollo ágil y minimizar costes iniciales.

### Actividad 3: Análisis Coste-Beneficio

**Descripción:** Los estudiantes deben realizar un análisis detallado del escenario "bootstrap" descrito en el archivo "002-arranque minimo.md", evaluando la viabilidad financiera y estrategias de comercialización para captar clientes.

**Objetivo:** Aprender a evaluar el potencial de ingresos y costes relacionados con un MVP y planificar estrategias comerciales básicas.

### Actividad 4: Estimación de Coste Anual

**Descripción:** Utilizando los datos proporcionados en "001-Necesidades de recursos.md", los estudiantes deben crear una estimación del costo anual para desarrollar un portafolio completo, incluyendo personal y materiales.

**Objetivo:** Entender cómo se calcula la inversión necesaria para proyectos más grandes y detallar las diferentes fases de financiación y crecimiento.

### Actividad 5: Diseño de Infraestructura

**Descripción:** Los estudiantes deben diseñar una infraestructura mínima viable para un proyecto de software, incluyendo hardware, servicios en la nube y licencias necesarias. 

**Objetivo:** Aprender a seleccionar e implementar recursos tecnológicos adecuados para un MVP.

### Actividad 6: Estrategia de Marketing Inicial

**Descripción:** Basándose en el archivo "002-arranque minimo.md", los estudiantes deben crear un plan básico de marketing para captar clientes potenciales y validar su producto mínimo viable (MVP).

**Objetivo:** Desarrollar habilidades básicas de marketing digital y estrategias de atracción inicial.

### Actividad 7: Diseño de MVP

**Descripción:** Los estudiantes deben seleccionar uno o dos productos del portafolio descrito en "001-Necesidades de recursos.md" para diseñar un MVP. 

**Objetivo:** Aprender a definir y priorizar características clave para el lanzamiento inicial de un producto.

### Actividad 8: Roadmap Anual

**Descripción:** Los estudiantes deben crear una guía práctica de dos o tres años que incluya hitos específicos, como desarrollo del MVP, pruebas con clientes y escalabilidad gradual. 

**Objetivo:** Familiarizarse con la planificación estratégica a largo plazo en proyectos de software.

### Actividad 9: Evaluación de Herramientas Tecnológicas

**Descripción:** Los estudiantes deben investigar e identificar las herramientas tecnológicas necesarias para implementar los productos seleccionados (MVP) según el contenido del archivo "002-arranque minimo.md".

**Objetivo:** Desarrollar habilidades en la selección y configuración de herramientas y servicios técnicos.

### Actividad 10: Modelos de Negocio Alternativos

**Descripción:** Los estudiantes deben explorar modelos de negocio alternativos para su producto, como suscripciones mensuales o proyectos por contrato, basándose en el contenido del archivo "002-arranque minimo.md".

**Objetivo:** Entender las diferentes formas de monetizar productos y servicios tecnológicos.


<a id="realizacion-de-seguimiento"></a>
## Realización de seguimiento


<a id="desarrollo-sostenible"></a>
## Desarrollo sostenible


<a id="conexion-intermodular"></a>
## Conexion intermodular

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios en Python utilizando la biblioteca Flask para generar contenido HTML y CSS dinámicamente. Los ejercicios comienzan con la creación básica de una página web usando Flask, pasando a crear un calendario completo y finalmente desarrollar el tablero de ajedrez mediante manipulaciones condicionales del CSS. A través de estos ejercicios, se aprenden conceptos clave como la estructura de rutas en Flask, construcción de cadenas HTML dinámicas con bucles y condicionales, y aplicación de estilos CSS para diseño gráfico. Estos ejercicios son especialmente útiles para aprender a integrar lógica back-end con presentación front-end utilizando un framework web como Flask.

### flask
<small>Creado: 2025-09-29 16:06</small>

#### Explicación

Este fragmento de código es más bien un comentario que te indica cómo configurar tu entorno para trabajar con Flask, una popular biblioteca en Python utilizada para crear aplicaciones web. No hay ningún código ejecutable aquí; simplemente se te instruye sobre el primer paso necesario: instalar la librería Flask usando el comando `pip install flask` en una terminal. Este comando descarga e instala Flask y sus dependencias necesarias en tu sistema, lo que es fundamental para poder empezar a escribir y ejecutar código que use esta biblioteca.

`001-flask.py`

```python
# Abre una terminal e instala flask:
# pip install flask
```

### arrancar flask
<small>Creado: 2025-09-29 16:08</small>

#### Explicación

Este fragmento de código te muestra cómo configurar y ejecutar una aplicación web básica usando Flask, un marco ligero para Python. En primer lugar, el código importa la clase `Flask` del módulo flask. Luego, se crea una instancia de esta clase llamada `aplicacion`, que representa tu nueva aplicación web.

Lo importante aquí es el decorador `@aplicacion.route("/")`. Este decorador se utiliza para asociar funciones específicas con diferentes URLs en la aplicación web. En este caso, cuando alguien accede a la URL base (es decir, `/`), se ejecuta la función `raiz()`, que simplemente devuelve una cadena de texto "Esto es HTML desde Flask". Esta respuesta será lo que vea el usuario en su navegador.

Este código es fundamental porque te permite entender cómo estructurar y controlar las rutas en una aplicación web basada en Python con Flask, permitiéndote expandir esta idea para crear páginas más complejas y dinámicas.

`002-arrancar flask.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

from flask import Flask

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "Esto es HTML desde Flask"
  
```

### ahora arranco el servidor
<small>Creado: 2025-09-29 16:09</small>

#### Explicación

Este código está configurado para iniciar un pequeño servidor web utilizando la librería Flask en Python. Primero, importamos Flask y creamos una nueva aplicación web llamada `aplicacion`. Luego, definimos qué debe hacer cuando alguien visite el sitio principal (ruta "/"), devolviendo simplemente un mensaje que dice "Esto es HTML desde Flask". Finalmente, si se ejecuta este script directamente (no como módulo importado), comienza el servidor web en modo depuración. Esto te permite ver y probar tu aplicación web localmente antes de subirla a Internet.

Este código es fundamental para estudiantes que están empezando con la creación de aplicaciones web, ya que muestra cómo configurar un entorno de desarrollo básico y cómo responder a solicitudes del usuario mediante el uso de rutas en Flask.

`003-ahora arranco el servidor.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  return "Esto es HTML desde Flask"
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### ahora imprimo html real
<small>Creado: 2025-09-29 16:11</small>

#### Explicación

Este código está diseñado para mostrar cómo crear un simple sitio web utilizando la biblioteca Flask en Python. En primer lugar, se importa Flask para poder usar sus funciones. Luego, creamos una instancia de la aplicación llamada `aplicacion`. 

El código define lo que debe hacer cuando alguien visita el sitio web a través del navegador (ruta inicial, representada por un "/"). Cuando esto sucede, devuelve un mensaje en formato HTML que simplemente dice "Esto es HTML desde Flask". Finalmente, si este archivo se ejecuta directamente (y no importado como un módulo), el servidor Flask arranca y está listo para recibir solicitudes web.

Este ejemplo es importante porque muestra cómo Python puede generar contenido dinámico en tiempo real para los sitios web, lo cual es una habilidad clave cuando trabajas con desarrollo web.

`004-ahora imprimo html real.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  return "<h1>Esto es HTML desde Flask</h1>"
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### html completo
<small>Creado: 2025-09-29 16:12</small>

#### Explicación

Este código crea una simple aplicación web utilizando Flask, una librería de Python que facilita la creación de sitios web. En primer lugar, se importa la función necesaria desde Flask y se inicializa un objeto llamado `aplicacion` para representar nuestra aplicación web.

Luego, mediante el decorador `@aplicacion.route("/")`, se define lo que debe mostrar la página cuando un usuario accede a la raíz del sitio web (URL sin ningún parámetro adicional). En este caso, cuando alguien visita la URL base, verán una simple página HTML que muestra "Si estas viendo esto, es que te lo está dando Python" y tiene el título "Hola Python".

Finalmente, en la última parte del código, se verifica si el script está siendo ejecutado directamente (no importado por otro script), y si es así, se inicia el servidor web de Flask con modo depuración activo (`debug=True`). Esto permite que puedas ver los errores y hacer cambios a tu aplicación sin tener que reiniciar manualmente el servidor cada vez.

`005-html completo.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  return '''
    <!doctype html>
    <html>
      <head>
        <title>Hola Python</title>
      </head>
      <body>
        <p>Si estas viendo esto, es que te lo está dando Python</p>
      </body>
    </html>
    
  '''
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### ademas puedo poner css
<small>Creado: 2025-09-29 16:14</small>

#### Explicación

Este código python utiliza la biblioteca Flask para crear un sencillo servidor web que muestra una página HTML con un mensaje en rojo. Primero, importa Flask y crea una nueva aplicación web llamada `aplicacion`. Luego, define lo que debe mostrar cuando alguien visita la ruta principal del sitio (("/") mediante la función `raiz()`, que retorna todo el código HTML necesario para crear una simple página con un párrafo que dice "Si estas viendo esto, es que te lo está dando Python" y este texto aparece en rojo gracias al estilo CSS definido dentro de `<style>p{color:red;}</style>`. Finalmente, si se ejecuta directamente el script (no como módulo importado), el servidor Flask arranca con modo depuración activo para facilitar la prueba del sitio web.

Este código es importante porque demuestra cómo Python puede interactuar directamente con un navegador web para mostrar contenido HTML y CSS, lo que es fundamental en el desarrollo de aplicaciones web.

`006-ademas puedo poner css.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  return '''
    <!doctype html>
    <html>
      <head>
        <title>Hola Python</title>
        <style>
          p{color:red;}
        </style>
      </head>
      <body>
        <p>Si estas viendo esto, es que te lo está dando Python</p>
      </body>
    </html>
    
  '''
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### contenido dinamico
<small>Creado: 2025-09-29 16:15</small>

#### Explicación

Este código Python utiliza Flask, una biblioteca que permite crear pequeños servidores web para generar páginas HTML dinámicamente. El programa comienza importando Flask y creando una aplicación web llamada `aplicacion`. Luego, define lo que sucede cuando alguien visita la página principal (ruta `/`), donde se realiza una simple operación matemática (`4+3`) y el resultado de esta suma se incluye en el HTML devuelto al navegador. La página también muestra un parrafo con texto en rojo gracias a una regla de estilo CSS integrada directamente en la etiqueta `<style>`. Finalmente, si este script es ejecutado directamente (no importado como módulo), se lanza el servidor web para que puedas ver tu página en acción.

Este código es importante porque demuestra cómo combinar Python con HTML y un poco de CSS para generar contenido dinámico en una página web. Es útil cuando necesitas mostrar datos o resultados calculados por el lado del servidor, no solo información estática.

`007-contenido dinamico.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  suma = 4+3
  return '''
    <!doctype html>
    <html>
      <head>
        <title>Hola Python</title>
        <style>
          p{color:red;}
        </style>
      </head>
      <body>
        <p>Si estas viendo esto, es que te lo está dando Python</p>
        <p>Y el resultado de la suma es: '''+str(suma)+'''</p>
      </body>
    </html>
    
  '''
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### calendario con python y html
<small>Creado: 2025-09-29 16:18</small>

#### Explicación

Este código Python utiliza la librería Flask para crear una aplicación web simple. La primera parte del código importa Flask y crea una nueva instancia de la aplicación. Luego, define qué debe hacer cuando alguien visita la página principal (ruta '/') del sitio web: calcula la suma de 4 y 3 y genera un mensaje básico en formato HTML que se mostrará en el navegador.

El bloque `if __name__ == "__main__":` es lo que ejecuta la aplicación Flask. Cuando este condicional se cumple, la aplicación comienza a funcionar en modo de depuración (debug=True), permitiendo ver los errores y hacer cambios mientras la aplicación está corriendo sin necesidad de reiniciarla manualmente.

Este código es importante porque demuestra cómo generar una página web básica usando Python y Flask, combinando programación con el lenguaje HTML para estructurar lo que se mostrará en la interfaz del usuario.

`008-calendario con python y html.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  suma = 4+3
  cadena =  '''
    <!doctype html>
    <html>
      <head>
        <title>Hola Python</title>
      </head>
      <body>
        '''
        
  cadena += '''
      </body>
    </html>
    
  '''
  return cadena
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### ahora hago un for de dias
<small>Creado: 2025-09-29 16:20</small>

#### Explicación

Este código Python crea una sencilla aplicación web utilizando la librería Flask. La aplicación genera una página HTML con un título "Hola Python" y muestra los números del 1 al 30 representados como días de un mes, cada uno dentro de su propio `<div>`.

Lo primero que hace el programa es importar la librería Flask para poder crear aplicaciones web en Python. Luego, crea una instancia de la aplicación Flask llamada `aplicacion`.

La función `raiz()` se encarga de lo que va a mostrar la página principal (ruta `/`) cuando alguien acceda a ella. En esta función, se genera un bloque HTML que incluye un título y un contenedor (`<div class="mes">`) donde cada día del mes es representado por una caja `<div>` con una clase `dia`. La variable `cadena` va almacenando toda la estructura HTML.

El bucle `for` recorre desde el número 1 hasta el 30, añadiendo a `cadena` un bloque de código HTML para cada día. Esto significa que al final del bucle, tendrás una lista de divs con los números del 1 al 30, representando así los días de un mes cualquiera.

Finalmente, si este script es ejecutado directamente (y no importado por otro script), se lanza el servidor Flask local que servirá la página web en tu navegador. Este servidor corre en modo depuración (`debug=True`), lo que ayuda mucho a identificar problemas mientras estás desarrollando.

Este tipo de aplicación es útil para aprender cómo combinar Python con HTML y cómo crear sitios web interactivos usando Flask, una herramienta muy popular entre los desarrolladores debido a su simplicidad y flexibilidad.

`009-ahora hago un for de dias.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  suma = 4+3
  cadena =  '''
    <!doctype html>
    <html>
      <head>
        <title>Hola Python</title>
      </head>
      <body>
      <div class="mes">
        '''
        
  for dia in range(1,31):
    cadena += '<div class="dia">'+str(dia)+'</div>'
    
  cadena += '''
          </div>
      </body>
    </html>
    
  '''
  return cadena
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### el poder del css
<small>Creado: 2025-09-29 16:21</small>

#### Explicación

Este fragmento de código es un ejemplo sencillo de cómo utilizar Flask, una biblioteca de Python que nos permite crear páginas web. En este caso, se está creando una aplicación web simple que muestra el número del día en un mes confeccionado usando divs HTML.

Primero, se importa la librería Flask y se crea una instancia de la aplicación llamada `aplicacion`. Luego, se define una ruta inicial (`/`) mediante el decorador `@aplicacion.route("/")`, que indica a Flask qué función debe ejecutarse cuando alguien visite esa ruta en el servidor web.

En la función `raiz()`, primero se realiza una operación simple de suma (4+3) para ilustrar cómo puedes mezclar lógica Python con contenido HTML. A continuación, se construye un string llamado `cadena` que contiene todo el código HTML necesario para generar una página web sencilla con 30 cuadrados representando los días del mes. Cada uno de estos cuadros tiene la clase CSS "dia", que define su estilo (tamaño y borde).

Finalmente, se usa un bucle `for` para añadir a la cadena HTML una etiqueta `<div>` por cada día en el rango 1 al 30, con el número del día dentro de ella. Al final de la función, esta cadena completa es devuelta como respuesta HTTP.

El servidor web Flask se inicia sólo si este script es ejecutado directamente (no importado), lo que permite probar fácilmente la página en un navegador local durante el desarrollo.

`010-el poder del css.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  suma = 4+3
  cadena =  '''
    <!doctype html>
    <html>
      <head>
        <title>Hola Python</title>
        <style>
          .dia{
            width:100px;
            height:100px;
            border:1px solid grey;
          }
        </style>
      </head>
      <body>
      <div class="mes">
        '''
        
  for dia in range(1,31):
    cadena += '<div class="dia">'+str(dia)+'</div>'
    
  cadena += '''
          </div>
      </body>
    </html>
    
  '''
  return cadena
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### usamos grid
<small>Creado: 2025-09-29 16:22</small>

#### Explicación

Este código Python utiliza la librería Flask para crear un pequeño servidor web que genera una página HTML con un diseño de cuadrícula. Primero, importamos Flask y creamos una aplicación web llamada `aplicacion`. Luego, definimos qué debe hacer cuando alguien accede a la ruta raíz ("/") del servidor: genera un título "Hola Python" y crea una sección que simula un calendario mensual usando CSS Grid.

En el cuerpo de la página HTML generado dinámicamente por el código Python, hay un bucle `for` que recorre desde 1 hasta 30 (representando los días de un mes), añadiendo divs con la clase "dia" para cada día. Cada div representa un cuadro del calendario y está estilizado en CSS para formar una fila de siete columnas, simulando una semana.

Finalmente, el servidor Flask se inicia en modo depuración si este script es ejecutado directamente (no importado como módulo). Esto permite que podamos ver cómo funciona la aplicación web que hemos creado y ajustarla según sea necesario.

`011-usamos grid.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  suma = 4+3
  cadena =  '''
    <!doctype html>
    <html>
      <head>
        <title>Hola Python</title>
        <style>
          .mes{
            width:700px;
            display:grid;
            grid-template-columns:auto auto auto auto auto auto auto;
          }
          .dia{
            width:100px;
            height:100px;
            border:1px solid grey;
          }
        </style>
      </head>
      <body>
      <div class="mes">
        '''
        
  for dia in range(1,31):
    cadena += '<div class="dia">'+str(dia)+'</div>'
    
  cadena += '''
          </div>
      </body>
    </html>
    
  '''
  return cadena
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### ahora quiero todo el año
<small>Creado: 2025-09-29 16:25</small>

#### Explicación

Este código Python utiliza Flask, una librería que permite crear aplicaciones web simples. El objetivo principal del script es generar una página web con un calendario básico para todo el año.

En primer lugar, importamos la librería Flask y creamos una aplicación web llamada `aplicacion`. Luego, definimos lo que debe mostrar nuestra aplicación cuando se accede a su dirección base (ruta "/"). En esta ruta principal, generamos un código HTML que representa un calendario. Para cada mes del año, el script crea una división `<div>` con la clase "mes". Dentro de cada mes, se genera hasta 30 celdas representando los días del mes utilizando divisiones `<div>` con la clase "dia".

El resultado es una página web simple que muestra un calendario visual para todos los meses del año. La estructura HTML incluye estilos CSS simples para organizar estos elementos en filas y columnas.

Este tipo de práctica es importante porque te ayuda a entender cómo integrar lógica Python con contenido estático como HTML y CSS, creando así aplicaciones web interactivas y dinámicas.

`012-ahora quiero todo el año.py`

```python
# Abre una terminal e instala flask:
# pip install flask
# Flask es un microservidorweb que nos permite generar HTML desde Python

# Importo la librería Flask
from flask import Flask             

# Creo una nueva aplicacion
aplicacion = Flask(__name__)

# Defino que ocurre en una ruta inicial (/)
@aplicacion.route("/")
def raiz():
  suma = 4+3
  cadena =  '''
    <!doctype html>
    <html>
      <head>
        <title>Hola Python</title>
        <style>
          .mes{
            width:700px;
            display:grid;
            grid-template-columns:auto auto auto auto auto auto auto;
          }
          .dia{
            width:100px;
            height:100px;
            border:1px solid grey;
          }
        </style>
      </head>
      <body>
      '''
  for mes in range(1,13):
    cadena += '''
      <div class="mes">
        '''
        
    for dia in range(1,31):
      cadena += '<div class="dia">'+str(dia)+'</div>'
    
    cadena += '''
            </div>
            '''
  cadena += '''
      </body>
    </html>
    
  '''
  return cadena
  
# Ahora arranco el servidor
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### creo un tablero de ajedrez
<small>Creado: 2025-09-29 16:31</small>

#### Explicación

Este fragmento de código es una pequeña aplicación web creada con la biblioteca Flask en Python. El objetivo principal es crear un servidor web básico que, cuando se accede a su página principal (la ruta "/"), devuelve un texto vacío representado por una cadena de caracteres.

El código comienza importando la clase `Flask` desde el módulo `flask`. Luego, crea una instancia de esta clase llamada `aplicacion`, que representa nuestra aplicación web. La línea `@aplicacion.route("/")` define que cuando alguien visite la página principal del servidor (es decir, la URL sin ningún camino adicional), se ejecutará la función `raiz()`. Dentro de esta función, una cadena vacía es asignada a la variable `cadena`, y luego esa cadena vacía es devuelta al usuario web. Finalmente, el bloque `if __name__ == "__main__":` asegura que si este script se ejecuta directamente (y no importado como módulo en otro programa), entonces se inicia el servidor Flask con la opción `debug=True`, lo cual ayuda a depurar errores durante el desarrollo.

Este tipo de código es fundamental para entender cómo crear aplicaciones web simples utilizando Flask, permitiendo a los estudiantes aprender sobre rutas y controladores en un entorno básico antes de avanzar hacia características más complejas.

`013-creo un tablero de ajedrez.py`

```python
# Abre una terminal e instala flask:
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  cadena =  '''
    
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### celdas declaracion
<small>Creado: 2025-09-29 16:34</small>

#### Explicación

Este código es una pequeña aplicación web creada con Flask que genera un tablero de ajedrez básico. Aquí está cómo funciona:

1. **Configuración inicial**: El código importa Flask y crea una instancia de la clase `Flask` llamada `aplicacion`. Esta instancia se utilizará para definir las rutas (direcciones web) y responder a solicitudes.

2. **Definición de ruta**: Se define un endpoint (`@aplicacion.route("/")`) que responde al acceso a la página principal del sitio web. La función `raiz()` es llamada cuando alguien visita esa URL.

3. **Generación del tablero**: En la función `raiz()`, se inicializa una variable `cadena` como una cadena vacía, que será usada para almacenar el código HTML del tablero de ajedrez. Se define una constante `anchuratablero = 8`, ya que un tablero estándar de ajedrez tiene 8 filas y 8 columnas.

4. **Ciclo for anidado**: El código contiene dos bucles `for` anidados. El primer bucle recorre por cada fila del tablero (del 0 al 7) y el segundo bucle recorre por cada celda en la fila actual (también del 0 al 7). En cada iteración, se añade a `cadena` un div HTML que representa una celda del tablero.

5. **Devolver resultado**: Al final de la función, se devuelve la cadena `cadena`, que ahora contiene todo el código HTML necesario para mostrar el tablero de ajedrez en una página web.

6. **Ejecución del servidor**: Si este script es ejecutado directamente (no importado como módulo), entonces se inicia un servidor web local usando `aplicacion.run(debug=True)`. Esto permite probar la aplicación sin necesidad de desplegarla en un entorno remoto.

Esta práctica te enseña cómo estructurar una aplicación web básica con Flask y cómo generar contenido dinámico basado en iteraciones en Python. Es importante para aprender a crear interfaces web más complejas que interactúan con datos o bases de datos en el futuro.

`014-celdas declaracion.py`

```python
# Abre una terminal e instala flask:
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  cadena =  '''
    
  '''
  anchuratablero = 8
  for x in range(0,anchuratablero):
    for y in range(0,anchuratablero):
      cadena += '<div class="celda">c</div>'
  cadena +=  '''
    
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### un poco de css aunque poco legal
<small>Creado: 2025-09-29 16:35</small>

#### Explicación

Este código es una pequeña aplicación web creada usando Flask, un framework de Python muy popular para desarrollar sitios web. En este caso, el programa crea un tablero con celdas cuadradas usando HTML y CSS directamente en la respuesta que se envía al usuario cuando accede a la página principal del sitio.

Aquí hay algunos puntos clave sobre cómo funciona:

1. **Importación de Flask**: El código comienza importando la clase `Flask` desde el módulo `flask`.

2. **Inicialización del objeto Flask**: Se crea una instancia de la aplicación llamada `aplicacion`, y se asocia con el archivo actual usando `__name__`. Esto es importante porque Flask necesita saber dónde está configurado para funcionar correctamente.

3. **Definición de la ruta principal (`/`)**: La función `raiz()` define qué debe hacer la aplicación cuando alguien visita la página raíz del sitio (por ejemplo, "http://localhost:5000/") y retorna una cadena HTML que incluye CSS para estilizar las celdas del tablero.

4. **Generación de un tablero**: Dentro de `raiz()`, se crea un estilo CSS simple que define cómo deben verse los elementos div con la clase "celda". Luego, en dos bucles anidados, se genera una cuadrícula de 8x8 (puedes cambiar esto cambiando el valor de `anchuratablero`). Cada iteración del bucle añade un nuevo `<div>` a la cadena HTML que representa una celda del tablero.

5. **Ejecución del servidor**: Si se ejecuta este archivo directamente, en lugar de importarlo como módulo en otro programa, el último bloque `if` asegura que Flask inicie el servidor web en modo depuración (`debug=True`). Esto es útil durante la fase de desarrollo ya que muestra mensajes informativos y permite reiniciar automáticamente el servidor cuando se hacen cambios.

Este tipo de código es importante para entender cómo integrar HTML y CSS directamente desde Python usando un framework como Flask, lo cual puede ser muy práctico en proyectos simples o prototipos.

`015-un poco de css aunque poco legal.py`

```python
# Abre una terminal e instala flask:
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  cadena =  '''
    <style>
      .celda{width:50px;height:50px;border:1px solid grey;}
    </style>
  '''
  anchuratablero = 8
  for x in range(0,anchuratablero):
    for y in range(0,anchuratablero):
      cadena += '<div class="celda">c</div>'
  cadena +=  '''
    
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### grid en el body
<small>Creado: 2025-09-29 16:36</small>

#### Explicación

Este código crea una aplicación web simple usando Flask, un marco popular para Python que permite crear sitios web rápidamente. La función principal de este script es generar un tablero en formato cuadrícula en la página web.

En el código, primero se importa Flask y se inicializa una instancia de la aplicación llamada `aplicacion`. Luego, con la línea `@aplicacion.route("/")`, se define que cuando alguien visite la raíz del sitio web (es decir, la URL principal), se ejecutará la función `raiz()`.

Dentro de esta función, se crea una cadena HTML que incluye un estilo CSS para definir cómo deben verse las celdas y el cuerpo del tablero. La propiedad `grid-template-columns` en CSS establece que habrá 8 columnas iguales en el tablero. Luego, mediante dos bucles anidados (uno para las filas y otro para las columnas), se añaden divs con la clase "celda" a la cadena HTML para formar un tablero de 8x8.

Finalmente, si este script es ejecutado directamente (no importado como módulo en otro script), la aplicación Flask comenzará a funcionar en modo depuración. Esto permite que puedas ver los cambios hechos al código sin necesidad de reiniciar el servidor web cada vez que haces ajustes.

Esta aplicación es útil para entender cómo integrar CSS con un backend Python y cómo se genera contenido dinámico mediante la combinación de bucles y HTML generado en tiempo real.

`016-grid en el body.py`

```python
# Abre una terminal e instala flask:
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  cadena =  '''
    <style>
      .celda{width:50px;height:50px;border:1px solid grey;}
      body{display:grid;grid-template-columns:auto auto auto auto auto auto auto auto;}
    </style>
  '''
  anchuratablero = 8
  for x in range(0,anchuratablero):
    for y in range(0,anchuratablero):
      cadena += '<div class="celda">c</div>'
  cadena +=  '''
    
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### condicional
<small>Creado: 2025-09-29 16:38</small>

#### Explicación

Este fragmento de código es un programa en Python que utiliza la biblioteca Flask para crear una aplicación web sencilla que muestra el diseño básico de un tablero de ajedrez. La aplicación define una única ruta, "/", que cuando se accede a través del navegador, genera y devuelve una página HTML con CSS incorporado.

El código crea un tablero 8x8 utilizando dos bucles anidados (uno para las filas y otro para las columnas). Dentro de estos bucles, el programa utiliza una condición `if` para alternar entre celdas blancas y negras. Si la columna es par (`y % 2 == 0`), agrega una celda blanca; si no lo es, añade una celda negra con la clase "negra". Cada celda es representada por un `<div>` en HTML.

Esta técnica de alternancia es importante porque refleja cómo se estructura el tablero de ajedrez: las casillas blancas y negras deben intercalarse para que el tablero tenga su aspecto característico. El resultado es una página web simple pero efectiva que muestra la estructura visual del tablero, utilizando CSS para definir estilos como tamaños y bordes.

`017-condicional.py`

```python
# Abre una terminal e instala flask:
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  cadena =  '''
    <style>
      .celda{width:50px;height:50px;border:1px solid grey;}
      body{display:grid;grid-template-columns:auto auto auto auto auto auto auto auto;}
      .negra{background:black;}
    </style>
  '''
  anchuratablero = 8
  for x in range(0,anchuratablero):
    for y in range(0,anchuratablero):
      if y%2 == 0:
        cadena += '<div class="celda">c</div>'
      else:
        cadena += '<div class="celda negra">c</div>'
  cadena +=  '''
    
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### regla diferente en cada fila
<small>Creado: 2025-09-29 16:39</small>

#### Explicación

Este fragmento de código crea una aplicación web simple usando Flask, un framework ligero para Python. La aplicación genera el tablero de ajedrez en formato HTML y CSS directamente desde la función `raiz()`. En esta función se construye un estilo básico para las celdas del tablero y cómo deben organizarse usando CSS Grid.

El código utiliza dos bucles anidados (`for x in range(0, anchuratablero)` y `for y in range(0, anchuratablero)`) para recorrer todas las posiciones en el tablero (8x8). Dentro de estos bucles, hay condiciones que determinan si la celda debe ser negra o blanca dependiendo de las coordenadas. Si ambos valores x e y son pares o impares, la celda será una color diferente al alternar entre clases CSS.

Esta técnica permite crear un tablero de ajedrez clásico con cuadrados alternantes oscuros y claros, mostrando cómo se pueden generar estructuras HTML complejas dinámicamente a través del código Python. Es importante para entender cómo combinar programación backend (Python) con elementos frontend (HTML/CSS) en la creación de aplicaciones web interactivas.

`018-regla diferente en cada fila.py`

```python
# Abre una terminal e instala flask:
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  cadena =  '''
    <style>
      .celda{width:50px;height:50px;border:1px solid grey;}
      body{display:grid;grid-template-columns:auto auto auto auto auto auto auto auto;}
      .negra{background:black;}
    </style>
  '''
  anchuratablero = 8
  for x in range(0,anchuratablero):
    for y in range(0,anchuratablero):
      if x%2 == 0:
        if y%2 == 0:
          cadena += '<div class="celda">c</div>'
        else:
          cadena += '<div class="celda negra">c</div>'
      else:
        if y%2 == 0:
          cadena += '<div class="celda negra">c</div>'
        else:
          cadena += '<div class="celda">c</div>'
  cadena +=  '''
    
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### comentarios en el ejercicio
<small>Creado: 2025-09-29 16:42</small>

#### Explicación

Este código es un programa en Python que utiliza el framework Flask para crear una aplicación web simple. El objetivo principal del código es generar un tablero de ajedrez básico con CSS y HTML directamente desde la aplicación Flask.

El código comienza importando la clase `Flask` y creando una instancia de la misma llamada `aplicacion`. Luego, define una ruta raíz ("/") que cuando se accede mediante un navegador web, genera un tablero de ajedrez en formato HTML con estilos CSS incorporados.

El fragmento incluye comentarios que guían al usuario para instalar Flask desde la terminal. Una vez instalada la librería, el código define una variable `cadena` que contiene el estilo CSS necesario para colorear las celdas del tablero. Luego, se establece la anchura del tablero en 8 (correspondiente a las 8 filas y columnas de un tablero estándar de ajedrez).

El código usa dos bucles `for` anidados para recorrer todas las celdas del tablero. Dentro de estos bucles, hay condicionales que determinan si la celda debe ser negra o blanca basándose en sus coordenadas (`x`, `y`). Las celdas pares e impares se alternan entre blancas y negras para crear el patrón típico del tablero de ajedrez.

Finalmente, cuando se ejecuta la aplicación Flask con el comando `python nombre_del_archivo.py` en una terminal, esta servirá el contenido HTML generado por este código en respuesta a solicitudes HTTP. Esto permite visualizar un tablero de ajedrez en un navegador web sin necesidad de otro archivo HTML o CSS separado.

Este tipo de enfoque es útil para aprender cómo integrar lógica y diseño web directamente desde una aplicación Flask, lo que puede ser muy práctico en proyectos más grandes donde la generación dinámica del contenido es necesaria.

`019-comentarios en el ejercicio.py`

```python
# Abre una terminal e instala flask:
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # En primer lugar arrancamos con un estilo css
  cadena =  '''
    <style>
      .celda{width:50px;height:50px;border:1px solid grey;}
      body{display:grid;grid-template-columns:auto auto auto auto auto auto auto auto;}
      .negra{background:black;}
    </style>
  '''                
  # Ahora defino la anchura del tablero                                         
  anchuratablero = 8
  # Primero recorro las celdas en X (horizontal
  for x in range(0,anchuratablero):
  # Luego recorro las celdas en Y (vertical)
    for y in range(0,anchuratablero):
      # Si estamos en una fila PAR
      if x%2 == 0:
        # Si estamos en una columna par:
        if y%2 == 0:
          cadena += '<div class="celda">c</div>'
        # Si estamos en una columna impar
        else:
          cadena += '<div class="celda negra">c</div>'
      # Si estamos en una fila IMPAR
      else:
        # Si estamos en una columna par:
        if y%2 == 0:
          cadena += '<div class="celda negra">c</div>'
        # Si estamos en una columna impar
        else:
          cadena += '<div class="celda">c</div>'
  cadena +=  '''
    
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### Actividades propuestas

### Ejercicios con Flask y HTML/CSS

1. **Introducción a Flask**
   - **Descripción:** Configura un servidor web básico usando Flask y muestra una página simple.
   - **Instrucciones:**
     ```python
     from flask import Flask
     
     app = Flask(__name__)
     
     @app.route('/')
     def index():
         return '¡Bienvenido a tu primer proyecto con Flask!'
     
     if __name__ == '__main__':
         app.run(debug=True)
     ```

2. **Mostrar una página HTML estática**
   - **Descripción:** Crea un archivo `index.html` y muestra este contenido en la ruta raíz del servidor.
   - **Instrucciones:**
     ```python
     from flask import Flask, render_template
     
     app = Flask(__name__)
     
     @app.route('/')
     def index():
         return render_template('index.html')
     
     if __name__ == '__main__':
         app.run(debug=True)
     ```
     **Archivo `templates/index.html`:**
     ```html
     <!DOCTYPE html>
     <html lang="es">
     <head>
         <meta charset="UTF-8">
         <title>Página Inicial</title>
     </head>
     <body>
         <h1>Bienvenido a mi sitio web con Flask!</h1>
     </body>
     </html>
     ```

3. **Incluir CSS y JavaScript**
   - **Descripción:** Añade estilos y scripts a tu página.
   - **Instrucciones:**
     **Archivo `static/style.css`:**
     ```css
     body {
         background-color: #f0f0f0;
         font-family: Arial, sans-serif;
     }
     
     h1 {
         color: #333;
     }
     ```
     **Archivo `templates/index.html` con CSS e JavaScript:**
     ```html
     <!DOCTYPE html>
     <html lang="es">
     <head>
         <meta charset="UTF-8">
         <title>Página Inicial</title>
         <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
     </head>
     <body>
         <h1>Bienvenido a mi sitio web con Flask!</h1>
         
         <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
         <script>
             $(document).ready(function(){
                 alert('¡Página cargada!');
             });
         </script>
     </body>
     </html>
     ```

4. **Generar contenido dinámico**
   - **Descripción:** Genera un calendario en HTML usando Flask.
   - **Instrucciones:**
     ```python
     from flask import Flask
     
     app = Flask(__name__)
     
     @app.route('/')
     def index():
         meses = ['Enero', 'Febrero', 'Marzo']
         dias = [1, 2, 3]
         
         cadena = '<h1>Calendario</h1>'
         for mes in meses:
             cadena += f'<div class="mes">{mes}</div>'
             
             for dia in dias:
                 cadena += f'<div class="dia">{dia}</div>'
                 
         return cadena
     
     if __name__ == '__main__':
         app.run(debug=True)
     ```

5. **Crear un tablero de ajedrez**
   - **Descripción:** Genera un tablero de ajedrez en HTML usando Flask y CSS.
   - **Instrucciones:**
     ```python
     from flask import Flask
     
     app = Flask(__name__)
     
     @app.route('/')
     def index():
         cadena = '''
             <style>
                 .celda { width: 50px; height: 50px; border: 1px solid grey; }
                 body { display: grid; grid-template-columns: repeat(8, auto); }
                 .negra { background-color: black; }
             </style>
             
             <div id="tablero">
         '''
         
         anchuratablero = 8
         for x in range(anchuratablero):
             for y in range(anchuratablero):
                 if (x + y) % 2 == 0:
                     cadena += '<div class="celda"></div>'
                 else:
                     cadena += '<div class="celda negra"></div>'
         
         cadena += '</div>'
         return cadena
     
     if __name__ == '__main__':
         app.run(debug=True)
     ```

6. **Generar un calendario completo del año**
   - **Descripción:** Genera un calendario completo de todo el año usando HTML y CSS.
   - **Instrucciones:**
     ```python
     from flask import Flask
     
     app = Flask(__name__)
     
     @app.route('/')
     def index():
         meses = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
                  'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre']
         
         cadena = '''
             <style>
                 .mes { width: 700px; display: grid; grid-template-columns: repeat(31, auto); }
                 .dia { width: 25px; height: 25px; border: 1px solid grey; background-color: white; }
                 .negro { background-color: black; }
             </style>
             
             <div id="calendario">
         '''
         
         for mes in meses:
             cadena += f'<h3>{mes}</h3>'
             
             for dia in range(1, 32):
                 if (dia + (ord(mes[0]) - ord('A'))) % 2 == 0:
                     cadena += '<div class="dia negro"></div>'
                 else:
                     cadena += '<div class="dia"></div>'
         
         cadena += '</div>'
         return cadena
     
     if __name__ == '__main__':
         app.run(debug=True)
     ```

Estos ejercicios te permitirán familiarizarte con la creación de páginas web dinámicas usando Flask y generar contenido HTML/JS/CSS desde Python.



<a id="seleccion-de-un-servicio-o-producto"></a>
# Selección de un servicio o producto

<a id="identificar-las-necesidades"></a>
## Identificar las necesidades

### Introducción a los ejercicios

En esta carpeta se encuentran ejercicios diseñados para que los estudiantes de primer curso exploren cómo aplicaciones web pueden mejorar procesos en diversos sectores profesionales. Los ejercicios enfatizan la identificación de necesidades y problemáticas reales en campos como el deporte, hostelería u otros conocidos por cada estudiante. Se practican habilidades esenciales como el desarrollo de interfaces para usuarios finales y paneles administrativos, gestión de bases de datos, almacenamiento y manipulación de datos, y la capacidad de iterar y escalar soluciones conforme se van identificando nuevas necesidades.

El objetivo principal es que los alumnos apliquen sus conocimientos en un contexto práctico, desarrollando propuestas tecnológicas para resolver problemas específicos observados en el sector elegido. Esto implica no solo la creación de aplicaciones web funcionales sino también la capacidad de analizar y entender las necesidades del usuario final y los administradores del sistema.

### Actividades propuestas

### Actividad 1: Identificación y Análisis de Necesidades

**Descripción:** Los estudiantes deben identificar un sector profesional específico que conozcan o en el que puedan obtener información. Se les pedirá que realicen una encuesta, entrevista a expertos del área o investiguen por internet para detectar problemas existentes y oportunidades de mejora dentro de ese sector.

**Objetivo:** Los estudiantes aprenderán a identificar necesidades reales en un entorno profesional y comprender cómo la tecnología puede ofrecer soluciones innovadoras a esos desafíos.

---

### Actividad 2: Diseño de Soluciones Básicas

**Descripción:** Tras haber detectado problemas o áreas que requieren optimización en su sector elegido, los estudiantes deben proponer soluciones simples y básicas utilizando tecnologías web fundamentales (HTML, CSS).

**Objetivo:** Aprender a diseñar interfaces de usuario sencillas y funcionales para abordar necesidades identificadas.

---

### Actividad 3: Creación de una Base de Datos Simples

**Descripción:** Se les solicitará que creen un esquema básico de base de datos (usando SQL) para almacenar información relevante a la solución propuesta, como reservas en hostelería o fichas de empleados.

**Objetivo:** Familiarizarse con el uso de bases de datos y comprender cómo se integran con aplicaciones web para manejar datos importantes.

---

### Actividad 4: Implementación Básica de PHP

**Descripción:** Los estudiantes deben implementar una funcionalidad básica en PHP que permita la inserción, lectura o eliminación de información desde la base de datos creada previamente.

**Objetivo:** Aprender a manipular y gestionar datos utilizando lenguajes de servidor como PHP para interacciones con bases de datos.

---

### Actividad 5: Despliegue en Servidor

**Descripción:** Los estudiantes deben alojar sus proyectos web en un servidor compartido o VPS, asegurándose de que las aplicaciones funcionen correctamente cuando están publicadas y accesibles desde internet.

**Objetivo:** Familiarizarse con los conceptos básicos del despliegue y la administración de servidores para hosting web.

---

### Actividad 6: Mejora Continua

**Descripción:** Se les pedirá que revisen sus soluciones propuestas e implementadas, identifiquen áreas de mejora y organicen las iteraciones necesarias para perfeccionarlas en base a comentarios de expertos o pruebas realizadas.

**Objetivo:** Entender la importancia del feedback constante y la mejora continua en el desarrollo de proyectos informáticos.

---

### Actividad 7: Documentación y Presentación

**Descripción:** Los estudiantes deben documentar cada fase de su proyecto, desde la identificación del problema hasta su implementación final, incluyendo las iteraciones realizadas. Además, se les pedirá que preparen una presentación para exponer a sus compañeros o al profesor.

**Objetivo:** Aprender cómo comunicar eficazmente los resultados y el proceso de desarrollo en contextos académicos o profesionales.

---

### Actividad 8: Revisión y Feedback

**Descripción:** Los estudiantes deben revisar los proyectos de otros compañeros, proporcionando feedback constructivo que ayude a mejorar sus soluciones propuestas.

**Objetivo:** Desarrollar habilidades críticas y de análisis para dar comentarios efectivos en contextos de equipo o colaboración.

---

Estas actividades buscan capacitar a los estudiantes no solo técnicamente sino también en términos de pensamiento crítico, resolución de problemas y trabajo en equipo.


<a id="plantear-posibles-soluciones"></a>
## Plantear posibles soluciones


<a id="informacion-relativa-a-las-soluciones"></a>
## Información relativa a las soluciones


<a id="aspectos-innovadores"></a>
## Aspectos innovadores


<a id="estudio-de-viabilidad-tecnica"></a>
## Estudio de viabilidad técnica


<a id="partes-del-proyecto"></a>
## Partes del proyecto


<a id="recursos-materiales-y-humanos-necesarios"></a>
## Recursos materiales y humanos necesarios


<a id="realizacion-de-presupuestos-economicos"></a>
## Realización de presupuestos económicos


<a id="documentacion-para-el-diseno"></a>
## Documentación para el diseño


<a id="aspectos-sobre-la-calidad-del-proyecto"></a>
## Aspectos sobre la calidad del proyecto


<a id="presentacion-en-publico-de-las-ideas-mas-relevantes"></a>
## Presentación en público de las ideas más relevantes



<a id="propuesta-de-empresa-spin-off"></a>
# Propuesta de empresa spin off

<a id="temporalizacion-de-las-secuencias-de-las-actividades"></a>
## Temporalización de las secuencias de las actividades


<a id="determinacion-de-recursos-y-logistica-de-cada-actividad"></a>
## Determinacion de recursos y logistica de cada actividad


<a id="permisos-y-autorizaciones-necesarios"></a>
## Permisos y autorizaciones necesarios


<a id="actividades-que-implican-riesgos"></a>
## Actividades que implican riesgos


<a id="prl"></a>
## PRL


<a id="recursos-materiales-y-humanos-de-cada-actividad"></a>
## Recursos materiales y humanos de cada actividad


<a id="posibles-imprevistos"></a>
## Posibles imprevistos


<a id="documentacion-necesaria"></a>
## Documentación necesaria



<a id="relacion-de-unidad-de-empresa"></a>
# Relacion de unidad de empresa

<a id="procedimiento-de-seguimiento-de-las-actividades"></a>
## Procedimiento de seguimiento de las actividades


<a id="verificacion-de-la-calidad-de-los-resultados-de-las-actividades"></a>
## Verificación de la calidad de los resultados de las actividades


<a id="identificacion-de-posibles-desviaciones-en-planificacion"></a>
## Identificación de posibles desviaciones en planificación


<a id="informacion-de-posibles-desviaciones"></a>
## Información de posibles desviaciones


<a id="solucion-y-documentacion-de-las-desviaciones"></a>
## Solución y documentación de las desviaciones


<a id="definicion-y-elaboracion-de-documentacion"></a>
## Definición y elaboración de documentación



<a id="transmision-de-informacion"></a>
# Transmision de informacion

<a id="actitud-ordenada-y-metodica"></a>
## Actitud ordenada y metódica


<a id="transmision-de-informacion-horizontal-y-vertical"></a>
## Transmisión de información horizontal y vertical


<a id="uso-de-medios-informaticos-para-transmitijr-informacion"></a>
## Uso de medios informáticos para transmitijr información


<a id="terminos-tecnicos-en-otras-lenguajes-estandares-del-sector"></a>
## Términos técnicos en otras lenguajes estándares del sector



<a id="ejercicios"></a>
# Ejercicios

<a id="full-stack-en-el-servidor"></a>
## Full Stack en el servidor

### Introducción a los ejercicios

It seems you've been working through a series of steps involving Flask web applications, focusing on setting up your application to listen on specific ports and IP addresses. Below is a summary of the key points and actions taken:

1. **Setting Up Flask Application**:
    - Installed Flask using `pip install flask`.
    - Created a basic Flask application that listens on localhost or a specified IP address.
    - Added routes and HTML content to display simple blog posts.

2. **Running Flask Application Locally**:
    - Used `python3 your_flask_app.py` to run the Flask app locally, specifying the host (`192.168.1.78`) and port (e.g., 5000 or 8080).
    - Encountered permission issues when trying to bind to port 80 due to Apache using it.

3. **Stopping and Redirecting Traffic**:
    - Stopped the Apache server with `sudo service apache2 stop` to free up port 80.
    - Attempted to run Flask on port 80 but still encountered permission issues, indicating a broader policy for binding to low-numbered ports (privileged ports).

4. **Using NAT (Network Address Translation)**:
    - Experimented with using `iptables` to redirect traffic from port 80 to port 8080.
    - Command used: `sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080`.
    
5. **Deploying and Running on Server**:
    - Successfully ran the Flask application on a specified IP (`192.168.1.78`) and port (e.g., 8080).
    - Used `python3 your_flask_app.py` to start the application.

### Key Takeaways:

- **Port Binding**: Be mindful of which ports you are using, especially when running multiple services or binding to privileged ports.
- **Apache Interference**: Stopping Apache may be necessary if it's using a port you need for your Flask app.
- **NAT Redirection**: Useful technique for redirecting incoming traffic from one port to another (e.g., external requests on 80 being redirected internally to 8080).

### Next Steps:

1. Consider setting up a WSGI server like Gunicorn or uWSGI in production, which is more suitable than the built-in Flask development server.
2. Explore reverse proxies with Nginx or Apache to serve your application and handle SSL/TLS termination.

Would you like to proceed further into these steps or address any specific issues?

### crear una aplicación de prueba en el servidor
<small>Creado: 2025-10-06 16:00</small>

#### Explicación

Este fragmento de código es el inicio de una aplicación web simple utilizando la biblioteca Flask en Python. Lo que hace este código es configurar un servidor básico y definir lo que sucede cuando alguien visita la página principal (la "raíz") del sitio.

1. La línea `from flask import Flask` importa la clase `Flask`, que es fundamental para crear aplicaciones web con Flask.
2. Luego, se crea una instancia de esta aplicación llamada `aplicacion`. Esta línea inicializa un nuevo objeto de tipo Flask, y el parámetro `__name__` indica a Flask cómo configurar la aplicación (en este caso, en modo desarrollo).
3. La línea que empieza con `@aplicacion.route("/")` es un decorador que le dice a Flask qué función ejecutar cuando alguien visita la URL base de tu sitio web (es decir, cuando se accede a "http://localhost:5000/").
4. Dentro del decorador, se define una función llamada `raiz()` que devuelve el texto "<h1>Esto es HTML desde Flask</h1>", lo cual será mostrado en la página web cuando alguien visite la raíz del sitio.
5. Por último, la línea `if __name__ == "__main__":` asegura que la aplicación solo se ejecute si el archivo se ejecuta directamente (y no si es importado por otro script). La llamada a `aplicacion.run(debug=True)` inicia el servidor de desarrollo en modo depuración, lo que te permite ver mensajes útiles cuando algo falla y también reiniciar automáticamente tu aplicación cada vez que haces cambios.

Este código es importante porque establece los cimientos para crear aplicaciones web más complejas con Flask. Aprender a configurar un servidor básico y responder a solicitudes HTTP es crucial en el desarrollo de aplicaciones full-stack.

`002-crear una aplicación de prueba en el servidor.py`

```python
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "<h1>Esto es HTML desde Flask</h1>"
  
if __name__ == "__main__":
  aplicacion.run(debug=True)
```

### intentamos ejecutarlo
<small>Creado: 2025-10-06 16:14</small>

#### Explicación

Has instalado Flask correctamente en tu entorno de usuario, pero el archivo `flask` no está en tu PATH global por defecto. Esto es una precaución para evitar interferir con las versiones del sistema gestionadas por la distribución (Debian/Ubuntu).

### Resumen:
1. **Instalación:** Has instalado Flask y sus dependencias.
2. **Advertencia:** Se ha instalado el script `flask` en `/home/josevicente/.local/bin`, que no está en tu PATH global.

### Opciones para resolver esto:

#### 1. Usar un entorno virtual
La mejor práctica sería usar un entorno virtual (`venv`) para instalar Flask y otras aplicaciones Python específicas del proyecto:

```sh
python3 -m venv my_flask_env
source my_flask_env/bin/activate
pip install flask
```

#### 2. Añadir el directorio a PATH (no recomendado)
Puedes añadir `/home/josevicente/.local/bin` a tu `PATH` en tu archivo `.bashrc` o similar, pero esto no es lo más recomendable debido a las posibles interferencias con la gestión de paquetes del sistema:

```sh
echo 'export PATH=$HOME/.local/bin:$PATH' >> ~/.bashrc
source ~/.bashrc
```

#### 3. Usar `pipx`
Si estás instalando una aplicación de usuario que necesita Flask, puedes usar `pipx` para manejar el entorno virtual automáticamente:

```sh
sudo apt-get install pipx
pipx install flask
```

### Verificar la Instalación

Para verificar que Flask está correctamente instalado en tu entorno local y disponible para uso:

```sh
flask --version
```

Si esto falla, asegúrate de activar cualquier entorno virtual o añadir el directorio `.local/bin` a tu PATH.

---

Esta es la forma recomendada de instalar paquetes Python en sistemas gestionados como Ubuntu, ya que permite mantener separadas las instalaciones del sistema y las del usuario.

`005-intentamos ejecutarlo.py`

```python
josevicente@ubuntuserver:~$ python3 002-crear\ una\ aplicación\ de\ prueba\ en\ el\ servidor.py 

josevicente@ubuntuserver:~$ python3 002-crear\ una\ aplicación\ de\ prueba\ en\ el\ servidor.py 
Traceback (most recent call last):
  File "/home/josevicente/002-crear una aplicación de prueba en el servidor.py", line 3, in <module>
    from flask import Flask             
    ^^^^^^^^^^^^^^^^^^^^^^^
ModuleNotFoundError: No module named 'flask'


Intentamos instalar con pip 

josevicente@ubuntuserver:~$ pip3 install flask
Command 'pip3' not found, but can be installed with:
sudo apt install python3-pip
josevicente@ubuntuserver:~$ 

El servidor por defecto no tiene pip, pero lo podemos instalar

josevicente@ubuntuserver:~$ sudo apt install python3-pip
[sudo] password for josevicente: 
Leyendo lista de paquetes... Hecho
Creando árbol de dependencias... Hecho
Leyendo la información de estado... Hecho
Se instalarán los siguientes paquetes adicionales:
  binutils binutils-common binutils-x86-64-linux-gnu build-essential bzip2 cpp
  cpp-13 cpp-13-x86-64-linux-gnu cpp-x86-64-linux-gnu dpkg-dev fakeroot g++
  g++-13 g++-13-x86-64-linux-gnu g++-x86-64-linux-gnu gcc gcc-13 gcc-13-base
  gcc-13-x86-64-linux-gnu gcc-x86-64-linux-gnu javascript-common
  libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl
  libasan8 libatomic1 libbinutils libcc1-0 libctf-nobfd0 libctf0 libdpkg-perl
  libexpat1-dev libfakeroot libfile-fcntllock-perl libgcc-13-dev libgomp1
  libgprofng0 libhwasan0 libisl23 libitm1 libjs-jquery libjs-sphinxdoc
  libjs-underscore liblsan0 libmpc3 libpython3-dev libpython3.12-dev
  libquadmath0 libsframe1 libstdc++-13-dev libtsan2 libubsan1
  lto-disabled-list make python3-dev python3-wheel python3.12-dev zlib1g-dev
Paquetes sugeridos:
  binutils-doc gprofng-gui bzip2-doc cpp-doc gcc-13-locales cpp-13-doc
  debian-keyring g++-multilib g++-13-multilib gcc-13-doc gcc-multilib autoconf
  automake libtool flex bison gdb gcc-doc gcc-13-multilib gdb-x86-64-linux-gnu
  bzr libstdc++-13-doc make-doc
Se instalarán los siguientes paquetes NUEVOS:
  binutils binutils-common binutils-x86-64-linux-gnu build-essential bzip2 cpp
  cpp-13 cpp-13-x86-64-linux-gnu cpp-x86-64-linux-gnu dpkg-dev fakeroot g++
  g++-13 g++-13-x86-64-linux-gnu g++-x86-64-linux-gnu gcc gcc-13 gcc-13-base
  gcc-13-x86-64-linux-gnu gcc-x86-64-linux-gnu javascript-common
  libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl
  libasan8 libatomic1 libbinutils libcc1-0 libctf-nobfd0 libctf0 libdpkg-perl
  libexpat1-dev libfakeroot libfile-fcntllock-perl libgcc-13-dev libgomp1
  libgprofng0 libhwasan0 libisl23 libitm1 libjs-jquery libjs-sphinxdoc
  libjs-underscore liblsan0 libmpc3 libpython3-dev libpython3.12-dev
  libquadmath0 libsframe1 libstdc++-13-dev libtsan2 libubsan1
  lto-disabled-list make python3-dev python3-pip python3-wheel python3.12-dev
  zlib1g-dev
0 actualizados, 59 nuevos se instalarán, 0 para eliminar y 135 no actualizados.
Se necesita descargar 76,1 MB de archivos.
Se utilizarán 270 MB de espacio de disco adicional después de esta operación.
¿Desea continuar? [S/n] S
Des:1 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 binutils-common amd64 2.42-4ubuntu2.5 [240 kB]
Des:2 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libsframe1 amd64 2.42-4ubuntu2.5 [15,5 kB]
Des:3 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libbinutils amd64 2.42-4ubuntu2.5 [577 kB]
Des:4 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libctf-nobfd0 amd64 2.42-4ubuntu2.5 [97,7 kB]
Des:5 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libctf0 amd64 2.42-4ubuntu2.5 [94,5 kB]
Des:6 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libgprofng0 amd64 2.42-4ubuntu2.5 [849 kB]
Des:7 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 binutils-x86-64-linux-gnu amd64 2.42-4ubuntu2.5 [2.462 kB]
Des:8 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 binutils amd64 2.42-4ubuntu2.5 [18,1 kB]
Des:9 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 gcc-13-base amd64 13.3.0-6ubuntu2~24.04 [51,5 kB]
Des:10 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libisl23 amd64 0.26-3build1.1 [680 kB]
Des:11 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libmpc3 amd64 1.3.1-1build1.1 [54,6 kB]
Des:12 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 cpp-13-x86-64-linux-gnu amd64 13.3.0-6ubuntu2~24.04 [10,7 MB]
Des:13 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 cpp-13 amd64 13.3.0-6ubuntu2~24.04 [1.038 B]
Des:14 http://es.archive.ubuntu.com/ubuntu noble/main amd64 cpp-x86-64-linux-gnu amd64 4:13.2.0-7ubuntu1 [5.326 B]
Des:15 http://es.archive.ubuntu.com/ubuntu noble/main amd64 cpp amd64 4:13.2.0-7ubuntu1 [22,4 kB]
Des:16 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libcc1-0 amd64 14.2.0-4ubuntu2~24.04 [48,0 kB]
Des:17 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libgomp1 amd64 14.2.0-4ubuntu2~24.04 [148 kB]
Des:18 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libitm1 amd64 14.2.0-4ubuntu2~24.04 [29,7 kB]
Des:19 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libatomic1 amd64 14.2.0-4ubuntu2~24.04 [10,5 kB]
Des:20 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libasan8 amd64 14.2.0-4ubuntu2~24.04 [3.031 kB]
Des:21 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 liblsan0 amd64 14.2.0-4ubuntu2~24.04 [1.322 kB]
Des:22 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libtsan2 amd64 14.2.0-4ubuntu2~24.04 [2.772 kB]
Des:23 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libubsan1 amd64 14.2.0-4ubuntu2~24.04 [1.184 kB]
Des:24 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libhwasan0 amd64 14.2.0-4ubuntu2~24.04 [1.641 kB]
Des:25 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libquadmath0 amd64 14.2.0-4ubuntu2~24.04 [153 kB]
Des:26 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libgcc-13-dev amd64 13.3.0-6ubuntu2~24.04 [2.681 kB]
Des:27 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 gcc-13-x86-64-linux-gnu amd64 13.3.0-6ubuntu2~24.04 [21,1 MB]
Des:28 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 gcc-13 amd64 13.3.0-6ubuntu2~24.04 [494 kB]
Des:29 http://es.archive.ubuntu.com/ubuntu noble/main amd64 gcc-x86-64-linux-gnu amd64 4:13.2.0-7ubuntu1 [1.212 B]
Des:30 http://es.archive.ubuntu.com/ubuntu noble/main amd64 gcc amd64 4:13.2.0-7ubuntu1 [5.018 B]
Des:31 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libstdc++-13-dev amd64 13.3.0-6ubuntu2~24.04 [2.420 kB]
Des:32 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 g++-13-x86-64-linux-gnu amd64 13.3.0-6ubuntu2~24.04 [12,2 MB]
Des:33 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 g++-13 amd64 13.3.0-6ubuntu2~24.04 [16,1 kB]
Des:34 http://es.archive.ubuntu.com/ubuntu noble/main amd64 g++-x86-64-linux-gnu amd64 4:13.2.0-7ubuntu1 [964 B]
Des:35 http://es.archive.ubuntu.com/ubuntu noble/main amd64 g++ amd64 4:13.2.0-7ubuntu1 [1.100 B]
Des:36 http://es.archive.ubuntu.com/ubuntu noble/main amd64 make amd64 4.3-4.1build2 [180 kB]
Des:37 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libdpkg-perl all 1.22.6ubuntu6.5 [269 kB]
Des:38 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 bzip2 amd64 1.0.8-5.1build0.1 [34,5 kB]
Des:39 http://es.archive.ubuntu.com/ubuntu noble/main amd64 lto-disabled-list all 47 [12,4 kB]
Des:40 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 dpkg-dev all 1.22.6ubuntu6.5 [1.074 kB]
Des:41 http://es.archive.ubuntu.com/ubuntu noble/main amd64 build-essential amd64 12.10ubuntu1 [4.928 B]
Des:42 http://es.archive.ubuntu.com/ubuntu noble/main amd64 libfakeroot amd64 1.33-1 [32,4 kB]
Des:43 http://es.archive.ubuntu.com/ubuntu noble/main amd64 fakeroot amd64 1.33-1 [67,2 kB]
Des:44 http://es.archive.ubuntu.com/ubuntu noble/main amd64 javascript-common all 11+nmu1 [5.936 B]
Des:45 http://es.archive.ubuntu.com/ubuntu noble/main amd64 libalgorithm-diff-perl all 1.201-1 [41,8 kB]
Des:46 http://es.archive.ubuntu.com/ubuntu noble/main amd64 libalgorithm-diff-xs-perl amd64 0.04-8build3 [11,2 kB]
Des:47 http://es.archive.ubuntu.com/ubuntu noble/main amd64 libalgorithm-merge-perl all 0.08-5 [11,4 kB]
Des:48 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libexpat1-dev amd64 2.6.1-2ubuntu0.3 [140 kB]
Des:49 http://es.archive.ubuntu.com/ubuntu noble/main amd64 libfile-fcntllock-perl amd64 0.22-4ubuntu5 [30,7 kB]
Des:50 http://es.archive.ubuntu.com/ubuntu noble/main amd64 libjs-jquery all 3.6.1+dfsg+~3.5.14-1 [328 kB]
Des:51 http://es.archive.ubuntu.com/ubuntu noble/main amd64 libjs-underscore all 1.13.4~dfsg+~1.11.4-3 [118 kB]
Des:52 http://es.archive.ubuntu.com/ubuntu noble/main amd64 libjs-sphinxdoc all 7.2.6-6 [149 kB]
Des:53 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 zlib1g-dev amd64 1:1.3.dfsg-3.1ubuntu2.1 [894 kB]
Des:54 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libpython3.12-dev amd64 3.12.3-1ubuntu0.8 [5.677 kB]
Des:55 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 libpython3-dev amd64 3.12.3-0ubuntu2 [10,3 kB]
Des:56 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 python3.12-dev amd64 3.12.3-1ubuntu0.8 [498 kB]
Des:57 http://es.archive.ubuntu.com/ubuntu noble-updates/main amd64 python3-dev amd64 3.12.3-0ubuntu2 [26,7 kB]
Des:58 http://es.archive.ubuntu.com/ubuntu noble/universe amd64 python3-wheel all 0.42.0-2 [53,1 kB]
Des:59 http://es.archive.ubuntu.com/ubuntu noble-updates/universe amd64 python3-pip all 24.0+dfsg-1ubuntu1.3 [1.320 kB]
Descargados 76,1 MB en 12s (6.566 kB/s)                                        
Extrayendo plantillas para los paquetes: 100%
Seleccionando el paquete binutils-common:amd64 previamente no seleccionado.
(Leyendo la base de datos ... 85591 ficheros o directorios instalados actualment
e.)
Preparando para desempaquetar .../00-binutils-common_2.42-4ubuntu2.5_amd64.deb .
..
Desempaquetando binutils-common:amd64 (2.42-4ubuntu2.5) ...
Seleccionando el paquete libsframe1:amd64 previamente no seleccionado.
Preparando para desempaquetar .../01-libsframe1_2.42-4ubuntu2.5_amd64.deb ...
Desempaquetando libsframe1:amd64 (2.42-4ubuntu2.5) ...
Seleccionando el paquete libbinutils:amd64 previamente no seleccionado.
Preparando para desempaquetar .../02-libbinutils_2.42-4ubuntu2.5_amd64.deb ...
Desempaquetando libbinutils:amd64 (2.42-4ubuntu2.5) ...
Seleccionando el paquete libctf-nobfd0:amd64 previamente no seleccionado.
Preparando para desempaquetar .../03-libctf-nobfd0_2.42-4ubuntu2.5_amd64.deb ...
Desempaquetando libctf-nobfd0:amd64 (2.42-4ubuntu2.5) ...
Seleccionando el paquete libctf0:amd64 previamente no seleccionado.
Preparando para desempaquetar .../04-libctf0_2.42-4ubuntu2.5_amd64.deb ...
Desempaquetando libctf0:amd64 (2.42-4ubuntu2.5) ...
Seleccionando el paquete libgprofng0:amd64 previamente no seleccionado.
Preparando para desempaquetar .../05-libgprofng0_2.42-4ubuntu2.5_amd64.deb ...
Desempaquetando libgprofng0:amd64 (2.42-4ubuntu2.5) ...
Seleccionando el paquete binutils-x86-64-linux-gnu previamente no seleccionado.
Preparando para desempaquetar .../06-binutils-x86-64-linux-gnu_2.42-4ubuntu2.5_a
md64.deb ...
Desempaquetando binutils-x86-64-linux-gnu (2.42-4ubuntu2.5) ...
Seleccionando el paquete binutils previamente no seleccionado.
Preparando para desempaquetar .../07-binutils_2.42-4ubuntu2.5_amd64.deb ...
Desempaquetando binutils (2.42-4ubuntu2.5) ...
Seleccionando el paquete gcc-13-base:amd64 previamente no seleccionado.
Preparando para desempaquetar .../08-gcc-13-base_13.3.0-6ubuntu2~24.04_amd64.deb
 ...
Desempaquetando gcc-13-base:amd64 (13.3.0-6ubuntu2~24.04) ...
Seleccionando el paquete libisl23:amd64 previamente no seleccionado.
Preparando para desempaquetar .../09-libisl23_0.26-3build1.1_amd64.deb ...
Desempaquetando libisl23:amd64 (0.26-3build1.1) ...
Seleccionando el paquete libmpc3:amd64 previamente no seleccionado.
Preparando para desempaquetar .../10-libmpc3_1.3.1-1build1.1_amd64.deb ...
Desempaquetando libmpc3:amd64 (1.3.1-1build1.1) ...
Seleccionando el paquete cpp-13-x86-64-linux-gnu previamente no seleccionado.
Preparando para desempaquetar .../11-cpp-13-x86-64-linux-gnu_13.3.0-6ubuntu2~24.
04_amd64.deb ...
Desempaquetando cpp-13-x86-64-linux-gnu (13.3.0-6ubuntu2~24.04) ...
Seleccionando el paquete cpp-13 previamente no seleccionado.
Preparando para desempaquetar .../12-cpp-13_13.3.0-6ubuntu2~24.04_amd64.deb ...
Desempaquetando cpp-13 (13.3.0-6ubuntu2~24.04) ...
Seleccionando el paquete cpp-x86-64-linux-gnu previamente no seleccionado.
Preparando para desempaquetar .../13-cpp-x86-64-linux-gnu_4%3a13.2.0-7ubuntu1_am
d64.deb ...
Desempaquetando cpp-x86-64-linux-gnu (4:13.2.0-7ubuntu1) ...
Seleccionando el paquete cpp previamente no seleccionado.
Preparando para desempaquetar .../14-cpp_4%3a13.2.0-7ubuntu1_amd64.deb ...
Desempaquetando cpp (4:13.2.0-7ubuntu1) ...
Seleccionando el paquete libcc1-0:amd64 previamente no seleccionado.
Preparando para desempaquetar .../15-libcc1-0_14.2.0-4ubuntu2~24.04_amd64.deb ..
.
Desempaquetando libcc1-0:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete libgomp1:amd64 previamente no seleccionado.
Preparando para desempaquetar .../16-libgomp1_14.2.0-4ubuntu2~24.04_amd64.deb ..
.
Desempaquetando libgomp1:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete libitm1:amd64 previamente no seleccionado.
Preparando para desempaquetar .../17-libitm1_14.2.0-4ubuntu2~24.04_amd64.deb ...
Desempaquetando libitm1:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete libatomic1:amd64 previamente no seleccionado.
Preparando para desempaquetar .../18-libatomic1_14.2.0-4ubuntu2~24.04_amd64.deb 
...
Desempaquetando libatomic1:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete libasan8:amd64 previamente no seleccionado.
Preparando para desempaquetar .../19-libasan8_14.2.0-4ubuntu2~24.04_amd64.deb ..
.
Desempaquetando libasan8:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete liblsan0:amd64 previamente no seleccionado.
Preparando para desempaquetar .../20-liblsan0_14.2.0-4ubuntu2~24.04_amd64.deb ..
.
Desempaquetando liblsan0:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete libtsan2:amd64 previamente no seleccionado.
Preparando para desempaquetar .../21-libtsan2_14.2.0-4ubuntu2~24.04_amd64.deb ..
.
Desempaquetando libtsan2:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete libubsan1:amd64 previamente no seleccionado.
Preparando para desempaquetar .../22-libubsan1_14.2.0-4ubuntu2~24.04_amd64.deb .
..
Desempaquetando libubsan1:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete libhwasan0:amd64 previamente no seleccionado.
Preparando para desempaquetar .../23-libhwasan0_14.2.0-4ubuntu2~24.04_amd64.deb 
...
Desempaquetando libhwasan0:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete libquadmath0:amd64 previamente no seleccionado.
Preparando para desempaquetar .../24-libquadmath0_14.2.0-4ubuntu2~24.04_amd64.de
b ...
Desempaquetando libquadmath0:amd64 (14.2.0-4ubuntu2~24.04) ...
Seleccionando el paquete libgcc-13-dev:amd64 previamente no seleccionado.
Preparando para desempaquetar .../25-libgcc-13-dev_13.3.0-6ubuntu2~24.04_amd64.d
eb ...
Desempaquetando libgcc-13-dev:amd64 (13.3.0-6ubuntu2~24.04) ...
Seleccionando el paquete gcc-13-x86-64-linux-gnu previamente no seleccionado.
Preparando para desempaquetar .../26-gcc-13-x86-64-linux-gnu_13.3.0-6ubuntu2~24.
04_amd64.deb ...
Desempaquetando gcc-13-x86-64-linux-gnu (13.3.0-6ubuntu2~24.04) ...
Seleccionando el paquete gcc-13 previamente no seleccionado.
Preparando para desempaquetar .../27-gcc-13_13.3.0-6ubuntu2~24.04_amd64.deb ...
Desempaquetando gcc-13 (13.3.0-6ubuntu2~24.04) ...
Seleccionando el paquete gcc-x86-64-linux-gnu previamente no seleccionado.
Preparando para desempaquetar .../28-gcc-x86-64-linux-gnu_4%3a13.2.0-7ubuntu1_am
d64.deb ...
Desempaquetando gcc-x86-64-linux-gnu (4:13.2.0-7ubuntu1) ...
Seleccionando el paquete gcc previamente no seleccionado.
Preparando para desempaquetar .../29-gcc_4%3a13.2.0-7ubuntu1_amd64.deb ...
Desempaquetando gcc (4:13.2.0-7ubuntu1) ...
Seleccionando el paquete libstdc++-13-dev:amd64 previamente no seleccionado.
Preparando para desempaquetar .../30-libstdc++-13-dev_13.3.0-6ubuntu2~24.04_amd6
4.deb ...
Desempaquetando libstdc++-13-dev:amd64 (13.3.0-6ubuntu2~24.04) ...
Seleccionando el paquete g++-13-x86-64-linux-gnu previamente no seleccionado.
Preparando para desempaquetar .../31-g++-13-x86-64-linux-gnu_13.3.0-6ubuntu2~24.
04_amd64.deb ...
Desempaquetando g++-13-x86-64-linux-gnu (13.3.0-6ubuntu2~24.04) ...
Seleccionando el paquete g++-13 previamente no seleccionado.
Preparando para desempaquetar .../32-g++-13_13.3.0-6ubuntu2~24.04_amd64.deb ...
Desempaquetando g++-13 (13.3.0-6ubuntu2~24.04) ...
Seleccionando el paquete g++-x86-64-linux-gnu previamente no seleccionado.
Preparando para desempaquetar .../33-g++-x86-64-linux-gnu_4%3a13.2.0-7ubuntu1_am
d64.deb ...
Desempaquetando g++-x86-64-linux-gnu (4:13.2.0-7ubuntu1) ...
Seleccionando el paquete g++ previamente no seleccionado.
Preparando para desempaquetar .../34-g++_4%3a13.2.0-7ubuntu1_amd64.deb ...
Desempaquetando g++ (4:13.2.0-7ubuntu1) ...
Seleccionando el paquete make previamente no seleccionado.
Preparando para desempaquetar .../35-make_4.3-4.1build2_amd64.deb ...
Desempaquetando make (4.3-4.1build2) ...
Seleccionando el paquete libdpkg-perl previamente no seleccionado.
Preparando para desempaquetar .../36-libdpkg-perl_1.22.6ubuntu6.5_all.deb ...
Desempaquetando libdpkg-perl (1.22.6ubuntu6.5) ...
Seleccionando el paquete bzip2 previamente no seleccionado.
Preparando para desempaquetar .../37-bzip2_1.0.8-5.1build0.1_amd64.deb ...
Desempaquetando bzip2 (1.0.8-5.1build0.1) ...
Seleccionando el paquete lto-disabled-list previamente no seleccionado.
Preparando para desempaquetar .../38-lto-disabled-list_47_all.deb ...
Desempaquetando lto-disabled-list (47) ...
Seleccionando el paquete dpkg-dev previamente no seleccionado.
Preparando para desempaquetar .../39-dpkg-dev_1.22.6ubuntu6.5_all.deb ...
Desempaquetando dpkg-dev (1.22.6ubuntu6.5) ...
Seleccionando el paquete build-essential previamente no seleccionado.
Preparando para desempaquetar .../40-build-essential_12.10ubuntu1_amd64.deb ...
Desempaquetando build-essential (12.10ubuntu1) ...
Seleccionando el paquete libfakeroot:amd64 previamente no seleccionado.
Preparando para desempaquetar .../41-libfakeroot_1.33-1_amd64.deb ...
Desempaquetando libfakeroot:amd64 (1.33-1) ...
Seleccionando el paquete fakeroot previamente no seleccionado.
Preparando para desempaquetar .../42-fakeroot_1.33-1_amd64.deb ...
Desempaquetando fakeroot (1.33-1) ...
Seleccionando el paquete javascript-common previamente no seleccionado.
Preparando para desempaquetar .../43-javascript-common_11+nmu1_all.deb ...
Desempaquetando javascript-common (11+nmu1) ...
Seleccionando el paquete libalgorithm-diff-perl previamente no seleccionado.
Preparando para desempaquetar .../44-libalgorithm-diff-perl_1.201-1_all.deb ...
Desempaquetando libalgorithm-diff-perl (1.201-1) ...
Seleccionando el paquete libalgorithm-diff-xs-perl:amd64 previamente no seleccio
nado.
Preparando para desempaquetar .../45-libalgorithm-diff-xs-perl_0.04-8build3_amd6
4.deb ...
Desempaquetando libalgorithm-diff-xs-perl:amd64 (0.04-8build3) ...
Seleccionando el paquete libalgorithm-merge-perl previamente no seleccionado.
Preparando para desempaquetar .../46-libalgorithm-merge-perl_0.08-5_all.deb ...
Desempaquetando libalgorithm-merge-perl (0.08-5) ...
Seleccionando el paquete libexpat1-dev:amd64 previamente no seleccionado.
Preparando para desempaquetar .../47-libexpat1-dev_2.6.1-2ubuntu0.3_amd64.deb ..
.
Desempaquetando libexpat1-dev:amd64 (2.6.1-2ubuntu0.3) ...
Seleccionando el paquete libfile-fcntllock-perl previamente no seleccionado.
Preparando para desempaquetar .../48-libfile-fcntllock-perl_0.22-4ubuntu5_amd64.
deb ...
Desempaquetando libfile-fcntllock-perl (0.22-4ubuntu5) ...
Seleccionando el paquete libjs-jquery previamente no seleccionado.
Preparando para desempaquetar .../49-libjs-jquery_3.6.1+dfsg+~3.5.14-1_all.deb .
..
Desempaquetando libjs-jquery (3.6.1+dfsg+~3.5.14-1) ...
Seleccionando el paquete libjs-underscore previamente no seleccionado.
Preparando para desempaquetar .../50-libjs-underscore_1.13.4~dfsg+~1.11.4-3_all.
deb ...
Desempaquetando libjs-underscore (1.13.4~dfsg+~1.11.4-3) ...
Seleccionando el paquete libjs-sphinxdoc previamente no seleccionado.
Preparando para desempaquetar .../51-libjs-sphinxdoc_7.2.6-6_all.deb ...
Desempaquetando libjs-sphinxdoc (7.2.6-6) ...
Seleccionando el paquete zlib1g-dev:amd64 previamente no seleccionado.
Preparando para desempaquetar .../52-zlib1g-dev_1%3a1.3.dfsg-3.1ubuntu2.1_amd64.
deb ...
Desempaquetando zlib1g-dev:amd64 (1:1.3.dfsg-3.1ubuntu2.1) ...
Seleccionando el paquete libpython3.12-dev:amd64 previamente no seleccionado.
Preparando para desempaquetar .../53-libpython3.12-dev_3.12.3-1ubuntu0.8_amd64.d
eb ...
Desempaquetando libpython3.12-dev:amd64 (3.12.3-1ubuntu0.8) ...
Seleccionando el paquete libpython3-dev:amd64 previamente no seleccionado.
Preparando para desempaquetar .../54-libpython3-dev_3.12.3-0ubuntu2_amd64.deb ..
.
Desempaquetando libpython3-dev:amd64 (3.12.3-0ubuntu2) ...
Seleccionando el paquete python3.12-dev previamente no seleccionado.
Preparando para desempaquetar .../55-python3.12-dev_3.12.3-1ubuntu0.8_amd64.deb 
...
Desempaquetando python3.12-dev (3.12.3-1ubuntu0.8) ...
Seleccionando el paquete python3-dev previamente no seleccionado.
Preparando para desempaquetar .../56-python3-dev_3.12.3-0ubuntu2_amd64.deb ...
Desempaquetando python3-dev (3.12.3-0ubuntu2) ...
Seleccionando el paquete python3-wheel previamente no seleccionado.
Preparando para desempaquetar .../57-python3-wheel_0.42.0-2_all.deb ...
Desempaquetando python3-wheel (0.42.0-2) ...
Seleccionando el paquete python3-pip previamente no seleccionado.
Preparando para desempaquetar .../58-python3-pip_24.0+dfsg-1ubuntu1.3_all.deb ..
.
Desempaquetando python3-pip (24.0+dfsg-1ubuntu1.3) ...
Configurando javascript-common (11+nmu1) ...
apache2_invoke: Enable configuration javascript-common
Configurando lto-disabled-list (47) ...
Configurando libfile-fcntllock-perl (0.22-4ubuntu5) ...
Configurando libalgorithm-diff-perl (1.201-1) ...
Configurando binutils-common:amd64 (2.42-4ubuntu2.5) ...
Configurando libctf-nobfd0:amd64 (2.42-4ubuntu2.5) ...
Configurando libgomp1:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando bzip2 (1.0.8-5.1build0.1) ...
Configurando python3-wheel (0.42.0-2) ...
Configurando libsframe1:amd64 (2.42-4ubuntu2.5) ...
Configurando libfakeroot:amd64 (1.33-1) ...
Configurando fakeroot (1.33-1) ...
update-alternatives: utilizando /usr/bin/fakeroot-sysv para proveer /usr/bin/fak
eroot (fakeroot) en modo automático
Configurando gcc-13-base:amd64 (13.3.0-6ubuntu2~24.04) ...
Configurando libexpat1-dev:amd64 (2.6.1-2ubuntu0.3) ...
Configurando make (4.3-4.1build2) ...
Configurando libquadmath0:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando libmpc3:amd64 (1.3.1-1build1.1) ...
Configurando libatomic1:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando python3-pip (24.0+dfsg-1ubuntu1.3) ...
Configurando libdpkg-perl (1.22.6ubuntu6.5) ...
Configurando libubsan1:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando zlib1g-dev:amd64 (1:1.3.dfsg-3.1ubuntu2.1) ...
Configurando libhwasan0:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando libasan8:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando libtsan2:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando libjs-jquery (3.6.1+dfsg+~3.5.14-1) ...
Configurando libbinutils:amd64 (2.42-4ubuntu2.5) ...
Configurando libisl23:amd64 (0.26-3build1.1) ...
Configurando libalgorithm-diff-xs-perl:amd64 (0.04-8build3) ...
Configurando libcc1-0:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando liblsan0:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando libitm1:amd64 (14.2.0-4ubuntu2~24.04) ...
Configurando libjs-underscore (1.13.4~dfsg+~1.11.4-3) ...
Configurando libalgorithm-merge-perl (0.08-5) ...
Configurando libctf0:amd64 (2.42-4ubuntu2.5) ...
Configurando cpp-13-x86-64-linux-gnu (13.3.0-6ubuntu2~24.04) ...
Configurando libpython3.12-dev:amd64 (3.12.3-1ubuntu0.8) ...
Configurando libgprofng0:amd64 (2.42-4ubuntu2.5) ...
Configurando python3.12-dev (3.12.3-1ubuntu0.8) ...
Configurando libjs-sphinxdoc (7.2.6-6) ...
Configurando libgcc-13-dev:amd64 (13.3.0-6ubuntu2~24.04) ...
Configurando libstdc++-13-dev:amd64 (13.3.0-6ubuntu2~24.04) ...
Configurando binutils-x86-64-linux-gnu (2.42-4ubuntu2.5) ...
Configurando cpp-x86-64-linux-gnu (4:13.2.0-7ubuntu1) ...
Configurando libpython3-dev:amd64 (3.12.3-0ubuntu2) ...
Configurando cpp-13 (13.3.0-6ubuntu2~24.04) ...
Configurando gcc-13-x86-64-linux-gnu (13.3.0-6ubuntu2~24.04) ...
Configurando binutils (2.42-4ubuntu2.5) ...
Configurando dpkg-dev (1.22.6ubuntu6.5) ...
Configurando python3-dev (3.12.3-0ubuntu2) ...
Configurando gcc-13 (13.3.0-6ubuntu2~24.04) ...
Configurando cpp (4:13.2.0-7ubuntu1) ...
Configurando g++-13-x86-64-linux-gnu (13.3.0-6ubuntu2~24.04) ...
Configurando gcc-x86-64-linux-gnu (4:13.2.0-7ubuntu1) ...
Configurando gcc (4:13.2.0-7ubuntu1) ...
Configurando g++-x86-64-linux-gnu (4:13.2.0-7ubuntu1) ...
Configurando g++-13 (13.3.0-6ubuntu2~24.04) ...
Configurando g++ (4:13.2.0-7ubuntu1) ...
update-alternatives: utilizando /usr/bin/g++ para proveer /usr/bin/c++ (c++) en 
modo automático
Configurando build-essential (12.10ubuntu1) ...
Procesando disparadores para man-db (2.12.0-4build2) ...
Procesando disparadores para libc-bin (2.39-0ubuntu8.6) ...
Scanning processes...                                                           
Scanning linux images...                                                        

Running kernel seems to be up-to-date.

No services need to be restarted.

No containers need to be restarted.

No user sessions are running outdated binaries.

No VM guests are running outdated hypervisor (qemu) binaries on this host.
josevicente@ubuntuserver:~$ 

Instalar flask

josevicente@ubuntuserver:~$ pip3 install flask
error: externally-managed-environment

× This environment is externally managed
╰─> To install Python packages system-wide, try apt install
    python3-xyz, where xyz is the package you are trying to
    install.
    
    If you wish to install a non-Debian-packaged Python package,
    create a virtual environment using python3 -m venv path/to/venv.
    Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make
    sure you have python3-full installed.
    
    If you wish to install a non-Debian packaged Python application,
    it may be easiest to use pipx install xyz, which will manage a
    virtual environment for you. Make sure you have pipx installed.
    
    See /usr/share/doc/python3.12/README.venv for more information.

note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.
hint: See PEP 668 for the detailed specification.
josevicente@ubuntuserver:~$ 


Vamos a break system packages

josevicente@ubuntuserver:~$ pip3 install flask --break-system-packages
Defaulting to user installation because normal site-packages is not writeable
Collecting flask
  Downloading flask-3.1.2-py3-none-any.whl.metadata (3.2 kB)
Collecting blinker>=1.9.0 (from flask)
  Downloading blinker-1.9.0-py3-none-any.whl.metadata (1.6 kB)
Requirement already satisfied: click>=8.1.3 in /usr/lib/python3/dist-packages (from flask) (8.1.6)
Collecting itsdangerous>=2.2.0 (from flask)
  Downloading itsdangerous-2.2.0-py3-none-any.whl.metadata (1.9 kB)
Requirement already satisfied: jinja2>=3.1.2 in /usr/lib/python3/dist-packages (from flask) (3.1.2)
Requirement already satisfied: markupsafe>=2.1.1 in /usr/lib/python3/dist-packages (from flask) (2.1.5)
Collecting werkzeug>=3.1.0 (from flask)
  Downloading werkzeug-3.1.3-py3-none-any.whl.metadata (3.7 kB)
Downloading flask-3.1.2-py3-none-any.whl (103 kB)
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 103.3/103.3 kB 3.9 MB/s eta 0:00:00
Downloading blinker-1.9.0-py3-none-any.whl (8.5 kB)
Downloading itsdangerous-2.2.0-py3-none-any.whl (16 kB)
Downloading werkzeug-3.1.3-py3-none-any.whl (224 kB)
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 224.5/224.5 kB 7.4 MB/s eta 0:00:00
Installing collected packages: werkzeug, itsdangerous, blinker, flask
  WARNING: The script flask is installed in '/home/josevicente/.local/bin' which is not on PATH.
  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
Successfully installed blinker-1.9.0 flask-3.1.2 itsdangerous-2.2.0 werkzeug-3.1.3
josevicente@ubuntuserver:~$ 
```

### ahora si que ejecutamos de verdad
<small>Creado: 2025-10-06 16:16</small>

#### Explicación

Este fragmento de código muestra el proceso y los resultados cuando se ejecuta un script en Python llamado `002-crear una aplicación de prueba en el servidor.py`. Primero, se ve cómo el usuario `josevicente` está en su directorio home del servidor Ubuntu y lista el contenido con el comando `ls`, donde se muestra que hay un archivo Python específico.

Luego, ejecuta el script usando la sintaxis `python3 nombre_del_archivo.py`. Cuando este script se ejecuta, utiliza una biblioteca de Python llamada Flask para crear una aplicación web básica. En la salida del terminal, puedes ver mensajes indicativos de que Flask está en modo depuración (debug mode) y servirá la aplicación en el servidor local en la dirección IP `127.0.0.1` en el puerto 5000.

El mensaje "WARNING: This is a development server. Do not use it in a production deployment." es una advertencia importante que Flask muestra para informar que este servidor no debe ser utilizado en un entorno de producción real y se recomienda usar un WSGI (Web Server Gateway Interface) servidor dedicado como Gunicorn o uWSGI.

Finalmente, el texto "Pero la IP no es la correcta (192.168.1.78)" indica que hay una confusión acerca de cuál debería ser realmente la dirección IP del servidor cuando se está corriendo en un entorno de desarrollo local con Flask. En este contexto, `127.0.0.1` es el loopback o localhost para conectarse a sí mismo (al propio servidor), mientras que `192.168.1.78` sería la dirección IP real del equipo en una red local si se quisiera acceder al servidor desde otro dispositivo.

Este tipo de práctica y comprensión son fundamentales cuando empiezas a trabajar con servidores web y aplicaciones full-stack, ya que te ayuda a entender cómo configurar correctamente tus entornos de desarrollo y producción.

`006-ahora si que ejecutamos de verdad.py`

```python
josevicente@ubuntuserver:~$ ls
'002-crear una aplicación de prueba en el servidor.py'   clear
josevicente@ubuntuserver:~$ python3 002-crear\ una\ aplicación\ de\ prueba\ en\ el\ servidor.py 
 * Serving Flask app '002-crear una aplicación de prueba en el servidor'
 * Debug mode: on
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 104-278-497


Pero la IP no es la correcta (192.168.1.78)
```

### cambiamos la IP de escucha
<small>Creado: 2025-10-06 16:17</small>

#### Explicación

Este código es una sencilla aplicación web creada usando el framework Flask en Python. Primero, se importa la clase `Flask` desde el módulo flask. Luego, se crea un objeto de tipo Flask llamado `aplicacion`, que será nuestra aplicación web.

El decorador `@aplicacion.route("/")` indica a Flask que cuando alguien acceda al sitio web en su dirección base (es decir, sin ninguna ruta adicional), debe ejecutar la función `raiz()`. Dentro de esta función, simplemente se retorna un bloque de HTML básico que muestra el texto "Esto es HTML desde Flask" en letras grandes.

Finalmente, el bloque `if __name__ == "__main__":` asegura que nuestra aplicación solo se ejecute si este script está siendo ejecutado directamente (no importado como módulo). Dentro de este bloque, la función `run()` del objeto `aplicacion` es llamada con los parámetros `host="192.168.1.78"` y `port=5000`, lo que significa que la aplicación se ejecutará en el servidor web local (en la IP 192.168.1.78) y escuchará conexiones entrantes en el puerto 5000. La opción `debug=True` habilita un modo de depuración, que es muy útil durante el desarrollo ya que proporciona mensajes adicionales sobre errores y permite a Flask reiniciar automáticamente cuando el código se modifica.

Este fragmento es fundamental para entender cómo configurar una aplicación web básica con Flask y cómo establecer la dirección IP y el puerto en los cuales será accesible.

`007-cambiamos la IP de escucha.py`

```python
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "<h1>Esto es HTML desde Flask</h1>"
  
if __name__ == "__main__":
  aplicacion.run(host="192.168.1.78", port=5000,debug=True)
```

### ejecutamos de nuevo
<small>Creado: 2025-10-06 16:18</small>

#### Explicación

El fragmento de código que has proporcionado no es realmente un código Python válido; parece ser una descripción en texto natural o comentarios. Sin embargo, las frases "En el servidor paro la versión 2" e "y lanzo la versión 7" sugieren que se está cambiando entre diferentes versiones de un software en un servidor.

Lo que esto podría implicar es que alguien está trabajando con dos versiones de una aplicación (posiblemente referidas a Python 2 y Python 3 o versiones específicas del mismo proyecto), deteniendo la versión antigua y ejecutando la nueva. Esta acción es común cuando se hacen cambios significativos en un programa y se necesita probar la nueva versión.

Es importante realizar este tipo de actualizaciones con cuidado, asegurándose de que el cambio no interrumpa servicios importantes o cause errores. En entornos profesionales, esto generalmente se hace durante periodos de menor tráfico para minimizar cualquier impacto negativo en los usuarios finales.

`008-ejecutamos de nuevo.py`

```python
En el servidor paro la versión 2, y lanzo la versión 7
```

### escuchamos en el puerto 80
<small>Creado: 2025-10-06 16:23</small>

#### Explicación

Este código es un ejemplo básico de cómo crear una aplicación web utilizando la biblioteca Flask en Python. La primera línea, aunque comentada (`# pip install flask`), indica que antes de ejecutar este script, debes instalar Flask con el comando `pip install flask`.

El código comienza importando la clase `Flask` desde el módulo `flask`. Luego, se crea una instancia de esta clase llamada `aplicacion`, lo cual es fundamental para iniciar cualquier aplicación Flask.

La decoración `@aplicacion.route("/")` define que la función `raiz()` será ejecutada cuando un usuario acceda a la ruta principal del servidor web (el URL base). Dentro de esta función, se devuelve una cadena HTML simple que muestra el texto "Esto es HTML desde Flask" en un encabezado grande (`<h1>`).

Finalmente, el bloque `if __name__ == "__main__":` asegura que la aplicación solo se ejecute si el script es ejecutado directamente (no cuando se importa como parte de otro programa). Dentro de este bloque, la función `aplicacion.run()` inicia el servidor web en el host especificado (`192.168.1.78`) y en el puerto 80, también habilitando el modo depuración para facilitar la resolución de problemas durante el desarrollo.

Este código es importante porque demuestra cómo Flask puede ser utilizado para crear rápidamente aplicaciones web simples y cómo se pueden manipular los parámetros del servidor (como el host y el puerto) a través de Python.

`010-escuchamos en el puerto 80.py`

```python
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "<h1>Esto es HTML desde Flask</h1>"
  
if __name__ == "__main__":
  aplicacion.run(host="192.168.1.78", port=80,debug=True)
```

### escuchamos en el puerto 8080
<small>Creado: 2025-10-06 16:28</small>

#### Explicación

Este fragmento de código en Python utiliza el marco Flask para crear un servidor web sencillo que responde a las solicitudes del usuario y muestra una página HTML básica cuando alguien accede al sitio web desde su navegador. En este caso, la aplicación es configurada utilizando la clase `Flask` para establecer una instancia llamada `aplicacion`. La función `raiz()` define el contenido de la página principal del servidor, que en este caso devuelve un simple mensaje HTML dentro de un encabezado h1.

El código también incluye una parte importante: en la sección `if __name__ == "__main__":`, cuando el archivo se ejecuta directamente y no como un módulo importado, Flask inicia el servidor web con la función `aplicacion.run()`. Aquí es donde establecemos las opciones para el servidor, especificando que debe escuchar en todas las direcciones IP disponibles de la máquina ("192.168.1.78") y en el puerto 8080. Además, se habilita la depuración (`debug=True`), lo cual es muy útil durante el desarrollo ya que proporcionará mensajes detallados sobre errores y permitirá a Flask reiniciar automáticamente cuando modifiques el código.

ÚLTIMO PÁRRAFO: La principal diferencia entre este archivo y el anterior es que ahora el servidor está configurado para escuchar en el puerto 8080 en lugar del puerto 80. Esto ayuda a evitar conflictos con otros servicios que podrían estar utilizando el puerto 80 en el sistema, permitiendo un entorno de desarrollo más seguro y sin problemas de colisión de puertos.

`010-escuchamos en el puerto 8080.py`

```python
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "<h1>Esto es HTML desde Flask</h1>"
  
if __name__ == "__main__":
  aplicacion.run(host="192.168.1.78", port=8080,debug=True)
```

### escuchamos en el puerto 8080
<small>Creado: 2025-10-06 16:28</small>

#### Explicación

Este código crea una aplicación web simple usando el framework Flask en Python. La aplicación tiene un solo endpoint o punto de acceso que es la raíz del sitio (`/`). Cuando se accede a esta página, muestra un mensaje en HTML: "Esto es HTML desde Flask".

El archivo comienza importando `Flask` desde la biblioteca flask y creando una instancia de la clase `Flask`, llamada `aplicacion`. Luego, se define una función llamada `raiz()` que será ejecutada cuando un usuario visite el endpoint raíz.

La línea `if __name__ == "__main__":` asegura que el servidor Flask solo se inicie si este script es ejecutado directamente (no importado como módulo en otro archivo). Finalmente, la función `run()` arranca el servidor web de Flask y lo hace escuchar en el host 192.168.1.78 en el puerto 8080 con la depuración habilitada.

Este código es importante porque demuestra cómo crear una aplicación web básica usando Python y cómo ejecutarla en un servidor local para pruebas o desarrollo.

`013-escuchamos en el puerto 8080.py`

```python
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "<h1>Esto es HTML desde Flask</h1>"
  
if __name__ == "__main__":
  aplicacion.run(host="192.168.1.78", port=8080,debug=True)
```

### creo un microblog
<small>Creado: 2025-10-06 16:36</small>

#### Explicación

Este código Python crea una pequeña aplicación web usando el framework Flask. Lo que hace es generar un sitio web básico con un título y varios artículos listados en la página principal.

En primer lugar, se importa Flask para crear una instancia de la aplicación web llamada `aplicacion`. Luego, se define una ruta para la raíz del servidor (la URL base) usando el decorador `@aplicacion.route("/")`, y se crea una función `raiz()` que genera la estructura HTML básica de la página. Dentro de esta función, se añade estilo CSS directamente en el código HTML para dar color al fondo y centrar un título.

La lista `articulos` contiene los nombres de algunos artículos imaginarios, que luego son iterados sobre con un bucle for para generar una estructura HTML dinámica que incluye cada artículo como un bloque separado en la página web. Cada artículo tiene su propio título `<h2>` y un párrafo vacío donde debería ir el contenido del artículo.

Finalmente, si este archivo es ejecutado directamente (no importado), se llama a `aplicacion.run()` para iniciar el servidor de desarrollo en la dirección IP "192.168.1.235" y en el puerto 8080 con depuración activada (`debug=True`). Esto permite que puedas ver tu microblog en un navegador web ingresando esa dirección IP y el número del puerto al URL.

Este código es útil para estudiantes de Full Stack porque muestra cómo combinar Flask, HTML y CSS en una aplicación web simple. También demuestra cómo estructurar la lógica de la aplicación con rutas y controladores en Flask.

`014-creo un microblog.py`

```python
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  cadena = '''
  <style>
    body{background:grey;}
    h1{color:white;text-align:center;}
    article{background:white;padding:20px;margin:auto;width:500px;}
  </style>
  <h1>El blog Python de Jose Vicente</h1>
  '''
  articulos = [
    "Primer artículo",
    "Segundo artículo",
    "Tercer artículo",
    "Cuarto artículo",
    "..."
  ]
  for articulo in articulos:
    cadena += '''<article>
      <h2>'''+articulo+'''</h2>
      <p>Este será el contenido del artículo</p>
    </article>'''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="192.168.1.235", port=8080,debug=True)
```

### apunto al servidor
<small>Creado: 2025-10-06 16:36</small>

#### Explicación

Este código es una aplicación sencilla creada con Flask, un framework de Python utilizado para desarrollar páginas web rápidamente. En primer lugar, el programa instala la librería Flask y crea una instancia de la clase `Flask`, a la que se le asigna el nombre `aplicacion`. 

Luego, define una ruta en la aplicación que corresponde a la raíz del sitio web (`/`). Cuando un usuario accede a esta dirección, se ejecuta la función `raiz()`, que genera un HTML dinámico. En este código, se crea un estilo básico para el cuerpo de la página y luego se añaden varios artículos en formato HTML dentro de una etiqueta `<article>`. Cada artículo incluye un título (`<h2>`) y un breve párrafo como contenido.

Finalmente, si el script es ejecutado directamente (no importado como módulo), la aplicación Flask se inicia y comienza a escuchar en la dirección IP `192.168.1.78` en el puerto 8080 con depuración habilitada para facilitar la detección de errores durante el desarrollo.

Esta pieza de código es importante porque demuestra cómo crear una página web básica utilizando Flask y cómo estructurar contenido HTML dinámico desde Python, lo cual es un primer paso hacia la creación de aplicaciones más complejas en un entorno full-stack.

`015-apunto al servidor.py`

```python
# pip install flask

from flask import Flask             

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  cadena = '''
  <style>
    body{background:grey;}
    h1{color:white;text-align:center;}
    article{background:white;padding:20px;margin:auto;width:500px;}
  </style>
  <h1>El blog Python de Jose Vicente</h1>
  '''
  articulos = [
    "Primer artículo",
    "Segundo artículo",
    "Tercer artículo",
    "Cuarto artículo",
    "..."
  ]
  for articulo in articulos:
    cadena += '''<article>
      <h2>'''+articulo+'''</h2>
      <p>Este será el contenido del artículo</p>
    </article>'''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="192.168.1.78", port=8080,debug=True)
```

### Archivo sin título
<small>Creado: 2025-10-13 16:36</small>

#### Explicación

Lo siento, pero no has proporcionado ningún código para analizar en tu último mensaje. ¿Podrías compartir un bloque de código específico que necesitas que explique? Estoy aquí para ayudarte a entenderlo.

`Archivo sin título`

```

```

### Actividades propuestas

It appears you are working through setting up a Flask web application on an Ubuntu server and running into issues related to port permissions and Apache. Here's a summary of the steps you've taken and some insights that could help resolve your issue:

1. **Setting Up Flask Application:**
   - You installed Flask and created several Python files with Flask applications, including setting up routes for basic HTML content.

2. **Running on Different Ports:**
   - Initially, you tried running your application on port 80 but ran into permission issues because the server is typically restricted from binding to lower ports (1-1023) without root privileges.
   
3. **Apache Interference:**
   - You discovered that Apache was running and occupying port 80 by default, which caused conflicts when trying to run Flask on this port.

4. **Port Redirection Using NAT (Network Address Translation):**
   - An option you mentioned is using `iptables` for port redirection from external port 80 to internal port 8080 where your Flask application runs (`sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080`). However, this is a temporary solution and may need configuration changes for persistence.

5. **Running on Port 8080:**
   - You decided to run your Flask application on port 8080 instead of 80 or lower ports, as it does not require root permissions, and avoids conflicts with Apache and other services that typically use those ports.
   
### Recommendations:

1. **Use a WSGI Server for Production (Gunicorn/Nginx):**
   - For production environments, Flask applications should be run using a proper WSGI server like Gunicorn or uWSGI in conjunction with an HTTP server like Nginx to handle static files and reverse proxy requests.

2. **Configure Apache/Nginx as Reverse Proxy:**
   - Alternatively, you could configure Apache or Nginx to act as a reverse proxy that forwards incoming traffic on port 80 to your Flask application running on another port (e.g., 8080).

3. **Disable Apache Temporarily for Testing Purposes:**
   - If you're only testing and don't need Apache, you can temporarily stop the service (`sudo systemctl stop apache2`) or disable it (`sudo systemctl disable apache2`), but be mindful of potential services that might rely on Apache.

### Example Nginx Configuration (Reverse Proxy):

Here's a basic example of how to set up an Nginx configuration file for your Flask application running on port 8080:

1. **Install Nginx:**
   ```sh
   sudo apt-get install nginx
   ```

2. **Create or Edit Nginx Configuration File:**
   - Open the default site configuration:
     ```sh
     sudo nano /etc/nginx/sites-available/default
     ```
   
3. **Configure for Reverse Proxy:**
   Add or modify the server block in `/etc/nginx/sites-available/default` to something like this:

   ```nginx
   server {
       listen 80;
       server_name yourserver.com;

       location / {
           proxy_pass http://127.0.0.1:8080;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
           proxy_set_header X-Forwarded-Proto $scheme;
       }
   }
   ```

4. **Restart Nginx:**
   ```sh
   sudo systemctl restart nginx
   ```

By setting up your Flask application to run on port 8080 and configuring a reverse proxy in Nginx, you can effectively serve your application over HTTP (port 80) while maintaining the simplicity of running your Flask app without needing root permissions for lower ports.

This setup should give you a robust way to develop and deploy your Flask application in a production-like environment.


<a id="conexion-programacion-y-sql"></a>
## Conexion programacion y SQL

### Introducción a los ejercicios

Este código te lleva a través de varios pasos para crear un blog simple utilizando Flask (un microframework web en Python) y SQLite3 (una base de datos relacional). Vamos a revisar los aspectos clave del proceso:

1. **Configuración inicial**:
   - Se crea una base de datos SQLite con una tabla llamada `articulos` que contiene campos como `id`, `titulo`, `fecha`, `texto`, y `imagen`.

2. **Creación de artículos**:
   - Varios scripts SQL (`013-nuevas entradas.sql`, etc.) se utilizan para insertar nuevos registros en la base de datos SQLite.

3. **Desarrollo del código Flask**:
   - El archivo Python principal utiliza Flask para crear un servidor web básico.
   - Se conecta a la base de datos y recupera los artículos.
   - Crea una página HTML dinámica que muestra cada artículo con título, fecha, texto y imagen.

4. **Estilización y mejora del diseño**:
   - Se añade CSS para mejorar el aspecto visual (ejemplo: `015-un poco de grid.py`).
   - Mejorar la accesibilidad (por ejemplo, añadiendo texto alternativo para imágenes en `016-texto alternativo.py`).

5. **Configuración del servidor**:
   - En `017-adapto ip.py`, se ajusta el servidor Flask para que escuche en una dirección IP específica y puerto.

### Puntos Importantes

- **Base de Datos**: La estructura inicial de la base de datos (`CREATE TABLE`) establece los campos necesarios para cada artículo.
  
- **Recuperación de Datos**: El código Python ejecuta consultas SQL para obtener todos los artículos de la base de datos y luego genera una respuesta HTML dinámica.

- **Generación de HTML**: La cadena `cadena` en el archivo Python se utiliza para construir una página HTML completa, incluyendo encabezados, contenido principal y footer.

- **Diseño Web**: Se añaden estilos CSS para mejorar la presentación del blog (por ejemplo, mediante uso de grillas).

### Pasos Finales

Para finalizar el proyecto:

1. **Incluir Migraciones Automáticas**: Considerar usar herramientas como `Alembic` o `SQLAlchemy` para manejar migraciones de base de datos.

2. **Seguridad y Mejoras**: Asegurar que la aplicación esté segura (evitar inyección SQL, validar entradas del usuario, etc.), mejorar las funcionalidades (añadir un formulario para añadir nuevos artículos).

3. **Publicación en Servidor Web**: Una vez terminado el desarrollo, puedes desplegar este blog en un servidor web real o utilizar servicios como Heroku.

### Ejemplo Final de Código Flask

Aquí tienes una versión simplificada y final del código Flask:

```python
from flask import Flask
import sqlite3

app = Flask(__name__)

@app.route('/')
def index():
    conn = sqlite3.connect('blog.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM articulos")
    articles = cursor.fetchall()

    html_content = '''
    <!doctype html>
    <html>
      <head><title>Blog de Jose Vicente</title></head>
      <body style="background:lightgray;font-family:sans-serif;">
        <header style="width:600px;background:white;margin:auto;padding:20px;">
          <h1>El blog de Jose Vicente</h1>
        </header>
        <main style="display:grid;grid-template-columns: auto auto auto;gap:20px;">
    '''

    for article in articles:
        html_content += f'''
          <article>
            <h3>{article[1]}</h3>
            <time>{article[2]}</time>
            <p>{article[3]}</p>
            <img src="static/{article[4]}" alt="Imagen de blog">
          </article>
        '''

    html_content += '''
        </main>
        <footer style="width:600px;background:white;margin:auto;padding:20px;">
          (c) 2025 Jose Vicente Carratala
        </footer>
      </body>
    </html>
    '''

    return html_content

if __name__ == "__main__":
    app.run(host="192.168.1.78", port=8080, debug=True)
```

Este código crea un servidor web básico con Flask que muestra artículos desde una base de datos SQLite y presenta los resultados en HTML generado dinámicamente.

### esquema
<small>Creado: 2025-10-13 17:54</small>

#### Explicación

Este código es un archivo SVG (Scalable Vector Graphics), que es una forma de representar gráficos vectoriales en formato XML. En este caso, el archivo parece describir un diagrama conceptual con diferentes elementos y conexiones entre ellos.

El código comienza definiendo la vista general del dibujo, incluyendo su tamaño y otros metadatos como quién lo creó (Inkscape). Luego se detallan varios rectángulos y texto que representan conceptos como "lenguajes de marcas", "entornos de desarrollo", "sistemas informáticos", "programación" y "bases de datos". Estos elementos están colocados en la página con coordenadas específicas (x, y) y tienen estilos definidos para su apariencia, como color de relleno y trazo.

Además, el código incluye líneas que conectan algunos de estos conceptos entre sí. Las líneas cuentan con flechas al final indicando una dirección o relación específica entre los elementos conectados (por ejemplo, de "programación" hacia "bases de datos").

Este tipo de diagrama es útil para mostrar relaciones y dependencias en sistemas complejos como el que se describe aquí, facilitando así la comprensión visual del funcionamiento interconectado de diferentes partes.

`000-esquema.svg`

```
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   width="210mm"
   height="297mm"
   viewBox="0 0 210 297"
   version="1.1"
   id="svg1"
   inkscape:version="1.4.2 (1:1.4.2+202505120737+ebf0e940d0)"
   sodipodi:docname="000-esquema.svg"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#ffffff"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     inkscape:document-units="mm"
     inkscape:zoom="1.3540965"
     inkscape:cx="471.53212"
     inkscape:cy="404.69789"
     inkscape:window-width="1920"
     inkscape:window-height="971"
     inkscape:window-x="0"
     inkscape:window-y="32"
     inkscape:window-maximized="1"
     inkscape:current-layer="layer1" />
  <defs
     id="defs1">
    <marker
       style="overflow:visible"
       id="ArrowWide"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2" />
    </marker>
    <marker
       style="overflow:visible"
       id="ArrowWide-1"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2-2" />
    </marker>
  </defs>
  <g
     inkscape:label="Capa 1"
     inkscape:groupmode="layer"
     id="layer1">
    <rect
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       id="rect1-3-7-2-5"
       width="101.60527"
       height="127.78815"
       x="61.353951"
       y="42.781853"
       ry="4.8848686" />
    <rect
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       id="rect1-3-7-2"
       width="82.847366"
       height="102.77763"
       x="70.055573"
       y="60.523064"
       ry="4.8848686" />
    <rect
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       id="rect1-3-7"
       width="66.238815"
       height="30.09079"
       x="77.962509"
       y="79.125275"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:5.30117px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:none;stroke:#000000;stroke-width:2.30413;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       x="81.781769"
       y="86.901352"
       id="text1-5-0"><tspan
         sodipodi:role="line"
         id="tspan1-6-9"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.30413"
         x="81.781769"
         y="86.901352">lenguajes de marcas</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:5.30117px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:none;stroke:#000000;stroke-width:2.30413;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       x="73.989769"
       y="69.764908"
       id="text1-5-0-9"><tspan
         sodipodi:role="line"
         id="tspan1-6-9-2"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.30413"
         x="73.989769"
         y="69.764908">entornos de desarrollo</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:5.30117px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:none;stroke:#000000;stroke-width:2.30413;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       x="66.621796"
       y="50.543858"
       id="text1-5-0-9-9"><tspan
         sodipodi:role="line"
         id="tspan1-6-9-2-7"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.30413"
         x="66.621796"
         y="50.543858">sistemas informáticos</tspan></text>
    <rect
       style="fill:#ffffff;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;fill-opacity:1"
       id="rect1-3"
       width="66.238815"
       height="30.09079"
       x="77.962502"
       y="100.72155"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.87774px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:none;stroke:#000000;stroke-width:2.98938;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       x="81.666672"
       y="109.72105"
       id="text1-5"><tspan
         sodipodi:role="line"
         id="tspan1-6"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.98938"
         x="81.666672"
         y="109.72105">programación</tspan></text>
    <rect
       style="fill:#ffffff;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke:#000000;stroke-opacity:1;fill-opacity:1"
       id="rect1"
       width="66.238815"
       height="30.09079"
       x="77.962494"
       y="125.24802"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.87774px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:none;stroke:#000000;stroke-width:2.98938;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       x="81.666664"
       y="134.24751"
       id="text1"><tspan
         sodipodi:role="line"
         id="tspan1"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.98938"
         x="81.666664"
         y="134.24751">bases de datos</tspan></text>
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide)"
       d="M 138.14408,147.71842 V 86.950657"
       id="path1" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide-1)"
       d="M 73.844264,86.270545 V 147.03831"
       id="path1-1" />
  </g>
</svg>
```

### crear tabla de articulos de blog
<small>Creado: 2025-10-13 16:03</small>

#### Explicación

Este fragmento de código SQL crea una tabla llamada "articulos" en una base de datos. La tabla tiene cinco columnas: "id", "titulo", "fecha", "texto" y "imagen". Cada columna está diseñada para almacenar diferentes tipos de información sobre un artículo, como el título, la fecha de publicación, el texto del artículo y la ruta a la imagen asociada.

La columna "id" es especial porque se ha definido como clave primaria con AUTOINCREMENT. Esto significa que cada vez que se inserta una nueva fila en esta tabla, el valor de "id" será automáticamente incrementado para garantizar que cada artículo tenga un identificador único y consecutivo. Esto es crucial para poder hacer referencias únicas a cada artículo dentro del sistema.

Esta estructura de tabla es importante porque permite organizar los datos de manera lógica y facilita la gestión y consulta de información sobre artículos en una base de datos SQL, como SQLite o MySQL.

`001-crear tabla de articulos de blog.sql`

```sql
CREATE TABLE "articulos" (
	"id"	INTEGER,
	"titulo"	TEXT,
	"fecha"	TEXT,
	"texto"	TEXT,
	"imagen"	TEXT,
	PRIMARY KEY("id" AUTOINCREMENT)
);
```

### insertar articulo
<small>Creado: 2025-10-13 16:05</small>

#### Explicación

El código SQL que has compartido se utiliza para insertar un nuevo registro en una tabla llamada `articulos`. Cada vez que deseas agregar información a esta tabla, debes proporcionar los valores específicos que quieres guardar. En este caso, el código agrega un artículo con varios detalles:

1. El primer valor es `NULL`, lo cual indica que la columna correspondiente es probablemente una clave primaria (primary key) autoincrementada por la base de datos.
2. `"Articulo numero 1"` es el título del artículo que se está insertando en la tabla.
3. La fecha `"2025-10-13"` se asocia con el momento en que fue escrito o publicado este artículo.
4. `"Este es el texto del articulo"` representa el contenido principal del artículo, donde se detalla lo que quiere comunicar o explicar.
5. Por último, `"josevicente.jpg"` es probablemente el nombre de un archivo que contiene una imagen asociada con el artículo.

Esta operación `INSERT INTO` es fundamental en la gestión de bases de datos para añadir nuevos registros a tablas existentes. Es importante asegurarse de que los valores proporcionados correspondan correctamente a las columnas esperadas en tu tabla `articulos`.

`002-insertar articulo.sql`

```sql
INSERT INTO articulos VALUES(
	NULL,
	"Articulo numero 1",
	"2025-10-13",
	"Este es el texto del articulo",
	"josevicente.jpg"
);
```

### insertar mas articulos
<small>Creado: 2025-10-13 16:06</small>

#### Explicación

Este fragmento de código SQL se utiliza para insertar nuevos registros en una tabla llamada `articulos`. Cada línea `INSERT INTO` agrega un nuevo artículo a la base de datos. Los valores que se insertan corresponden a diferentes campos de la tabla, como el ID (que es automáticamente generada ya que está definida como `NULL`, lo que indica que se debe autoincrementar), el título del artículo, la fecha de publicación, el texto del artículo y una imagen asociada.

La estructura básica de cada línea es:
- **ID:** Se deja en `NULL` para permitir que la base de datos asigne un ID automáticamente.
- **Título:** Define el nombre o el tema del artículo (por ejemplo, "Articulo numero 2").
- **Fecha:** Indica cuándo fue publicado el artículo (en formato YYYY-MM-DD).
- **Texto del Artículo:** Contiene el cuerpo del texto asociado a ese artículo en particular.
- **Imagen:** Especifica el nombre del archivo de imagen que acompañará al artículo.

Esta operación es importante porque permite almacenar múltiples artículos en una base de datos, lo cual facilita la gestión y consulta de información desde un sistema web o cualquier aplicación que acceda a esta base de datos.

`003-insertar mas articulos.sql`

```sql
INSERT INTO articulos VALUES(
	NULL,
	"Articulo numero 2",
	"2025-10-14",
	"Este es el texto del articulo 2",
	"josevicente.jpg"
);
INSERT INTO articulos VALUES(
	NULL,
	"Articulo numero 3",
	"2025-10-15",
	"Este es el texto del articulo 3",
	"josevicente.jpg"
);
INSERT INTO articulos VALUES(
	NULL,
	"Articulo numero 4",
	"2025-10-16",
	"Este es el texto del articulo 4",
	"josevicente.jpg"
);
```

### quiero hacer un select
<small>Creado: 2025-10-13 16:11</small>

#### Explicación

Este fragmento de código SQL es muy simple pero fundamental. La instrucción `SELECT * FROM articulos;` se utiliza para seleccionar todos los datos de la tabla llamada "articulos". Aquí, el asterisco (*) funciona como un comodín que significa "todas las columnas" en la tabla especificada.

En este contexto, cuando ejecutas esta sentencia en una base de datos SQLite (o cualquier otro tipo de base de datos SQL), obtendrás todas las filas y todas las columnas de la tabla "articulos". Esto es útil para revisar rápidamente el contenido completo de la tabla sin tener que especificar cada columna individualmente.

Es importante notar que esta consulta puede devolver una gran cantidad de información si la tabla tiene muchas filas o columnas, por lo que suele ser más práctica en fases iniciales de desarrollo y depuración.

`004-quiero hacer un select.sql`

```sql
SELECT * FROM articulos;
```

### conexion con sqlite
<small>Creado: 2025-10-13 16:12</small>

#### Explicación

Este fragmento de código está realizando una conexión a una base de datos SQLite llamada `blog.db` y luego ejecuta una consulta SQL para seleccionar todos los registros de la tabla `articulos`. Aquí te explico paso a paso cómo funciona:

1. La línea `import sqlite3` importa el módulo sqlite3, que proporciona soporte en Python para trabajar con bases de datos SQLite.

2. La línea `conexion = sqlite3.connect("blog.db")` crea una nueva conexión a la base de datos SQLite llamada `blog.db`. Si esta base de datos no existe, se creará automáticamente.

3. El siguiente paso es obtener un cursor desde la conexión con el comando `cursor = conexion.cursor()`. Un cursor en SQL te permite ejecutar comandos y recuperar registros que resulten de esa ejecución.

4. La línea `cursor.execute('SELECT * FROM articulos;')` ejecuta una consulta SQL que selecciona todos los campos (`*`) desde la tabla `articulos`.

5. Luego, `filas = cursor.fetchall()` recupera todas las filas resultantes del comando SELECT y las almacena en la variable `filas`. Este método obtiene todo el conjunto de resultados que aún no han sido devueltos por el cursor.

6. Finalmente, `print(filas)` imprime todas las filas recuperadas en la consola.

Este código es importante porque te permite interactuar con una base de datos SQLite desde Python, lo cual es útil para aplicaciones web, sistemas de gestión de contenido (CMS) y otras aplicaciones que necesiten almacenar y recuperar datos estructurados.

`005-conexion con sqlite.py`

```python
import sqlite3

conexion = sqlite3.connect("blog.db")

cursor = conexion.cursor()

cursor.execute('SELECT * FROM articulos;')

filas = cursor.fetchall()

print(filas)
```

### algo mas fino
<small>Creado: 2025-10-13 16:14</small>

#### Explicación

Este fragmento de código es una parte fundamental del proceso de interacción entre un programa de Python y una base de datos SQLite. La función principal es conectarse a una base de datos llamada `blog.db` e interactuar con ella para recuperar toda la información almacenada en una tabla llamada `articulos`. Aquí está cómo funciona:

1. **Conexión a la Base de Datos**: El código comienza importando el módulo `sqlite3`, que es necesario para conectarse y trabajar con bases de datos SQLite. Luego, se crea un objeto de conexión (`conexion`) utilizando la función `connect()`. Esto establece una conexión al archivo de base de datos especificado.

2. **Creación del Cursor**: Una vez establecida la conexión, se crea un cursor (`cursor`). Un cursor es un objeto que permite ejecutar comandos SQL en la base de datos y recuperar los resultados.

3. **Ejecución de Consulta SQL**: Se utiliza el método `execute()` del cursor para enviar una consulta SQL a la base de datos. En este caso, se solicita todos los registros (`SELECT *`) de la tabla `articulos`.

4. **Recuperación de Datos y Bucle**: Después de ejecutar la consulta, se utilizan dos líneas clave: `fetchall()` y un bucle `for`. La función `cursor.fetchall()` recupera todas las filas que devolvió la consulta SQL como una lista de tuplas. Luego, el bucle `for` itera sobre cada fila en esta lista, imprimiendo cada registro.

Este código es importante porque demuestra cómo un programa Python puede conectarse a una base de datos SQLite para realizar operaciones CRUD (Crear, Leer, Actualizar y Eliminar), lo cual es fundamental para aplicaciones que manejan datos persistentes.

`006-algo mas fino.py`

```python
import sqlite3

conexion = sqlite3.connect("blog.db")

cursor = conexion.cursor()

cursor.execute('SELECT * FROM articulos;')

filas = cursor.fetchall()

for fila in filas:
  print(fila)
```

### ahora quiero diccionario
<small>Creado: 2025-10-13 16:16</small>

#### Explicación

Este fragmento de código en Python se utiliza para interactuar con una base de datos SQLite llamada `blog.db`. La primera línea importa el módulo `sqlite3` que proporciona funciones para conectarse y trabajar con bases de datos SQLite. Luego, establece una conexión a la base de datos utilizando `sqlite3.connect("blog.db")`, donde "blog.db" es el nombre del archivo de la base de datos.

El código configura también cómo se deben devolver los resultados desde la base de datos, en este caso usando `Row` que permite acceder a las filas de resultados como diccionarios. Esto facilita el acceso a los datos por nombre en lugar de por índice.

Posteriormente, se crea un objeto cursor con `cursor = conexion.cursor()`, lo cual es necesario para ejecutar comandos SQL. El comando `SELECT * FROM articulos;` es ejecutado para recuperar todos los registros desde la tabla llamada "articulos". Finalmente, el bucle `for fila in filas:` itera sobre cada registro (o fila) devuelto por la consulta y utiliza `print(dict(fila))` para imprimir cada registro en formato de diccionario. Esto hace que los datos sean más fáciles de leer e interpretar, ya que cada clave del diccionario corresponde a un nombre de columna de la tabla "articulos".

`007-ahora quiero diccionario.py`

```python
import sqlite3

conexion = sqlite3.connect("blog.db")
conexion.row_factory = sqlite3.Row

cursor = conexion.cursor()

cursor.execute('SELECT * FROM articulos;')

filas = cursor.fetchall()

for fila in filas:
  print(dict(fila))
```

### controlo el diccionario
<small>Creado: 2025-10-13 16:17</small>

#### Explicación

Este fragmento de código es una parte del proceso de conexión a una base de datos SQLite y extracción de información. En concreto, se conecta a una base de datos llamada `blog.db`, que contiene una tabla denominada `articulos`. 

El código comienza importando el módulo `sqlite3` para poder trabajar con la base de datos. Luego, establece una conexión a dicha base de datos y configura la forma en que se obtendrán los resultados (en este caso, como objetos fila). A continuación, se crea un cursor, que es el objeto mediante el cual podemos ejecutar comandos SQL.

El comando `SELECT * FROM articulos;` recupera todas las filas de la tabla `articulos`. Cada fila contiene varios campos, entre ellos un campo llamado `titulo`.

Finalmente, por cada fila obtenida en la consulta, se imprime el valor del campo `titulo` convirtiendo primero toda la fila en un diccionario Python para poder acceder a sus valores de manera más sencilla.

Este código es importante porque demuestra cómo interactuar con una base de datos desde Python y extraer información específica, como los títulos de los artículos, lo cual es fundamental cuando se desarrollan aplicaciones web o cualquier otro tipo de software que requiere almacenamiento y recuperación de datos.

`008-controlo el diccionario.py`

```python
import sqlite3

conexion = sqlite3.connect("blog.db")
conexion.row_factory = sqlite3.Row

cursor = conexion.cursor()

cursor.execute('SELECT * FROM articulos;')

filas = cursor.fetchall()

for fila in filas:
  print(dict(fila)['titulo'])
```

### extraigo la informacion limpia
<small>Creado: 2025-10-13 16:18</small>

#### Explicación

Este código Python se encarga de conectarse a una base de datos SQLite llamada `blog.db` y extraer información de una tabla llamada `articulos`. Primero, el programa importa la librería sqlite3 para manejar las operaciones con la base de datos. Luego, establece una conexión a la base de datos y configura un método que permitirá obtener los resultados en forma de diccionario, lo cual facilita acceder a los campos de cada fila por su nombre.

Una vez configurada la conexión y el cursor (que es como un puntero para ejecutar comandos SQL), se ejecuta una consulta SQL que selecciona todos los datos de la tabla `articulos`. A continuación, el programa obtiene todas las filas resultantes de esta consulta con la función `fetchall()`, almacenándolas en la variable `filas`.

Finalmente, mediante un bucle for, el código recorre cada fila del resultado y convierte cada fila en un diccionario. Luego imprime los valores asociados a las claves 'titulo', 'fecha', 'texto' e 'imagen'. Esto es útil para visualizar o procesar la información extraída de manera más estructurada y fácilmente accesible.

`009-extraigo la informacion limpia.py`

```python
import sqlite3

conexion = sqlite3.connect("blog.db")
conexion.row_factory = sqlite3.Row

cursor = conexion.cursor()

cursor.execute('SELECT * FROM articulos;')

filas = cursor.fetchall()

for fila in filas:
  diccionario = dict(fila)
  print(diccionario['titulo'])
  print(diccionario['fecha'])
  print(diccionario['texto'])
  print(diccionario['imagen'])
```

### ahora traigo flask
<small>Creado: 2025-10-13 16:26</small>

#### Explicación

Este fragmento de código está configurado para crear una aplicación web simple usando Flask y SQLite. La aplicación se encarga de mostrar todos los artículos almacenados en una base de datos llamada `blog.db`. Aquí te explico cómo funciona:

1. **Inicialización de la Aplicación**: Se importa el módulo Flask y se crea una instancia de la clase `Flask`, a la cual se le pasa un argumento especial `__name__` que permite configurar correctamente las rutas del proyecto.

2. **Conexión con SQLite**: En la función `raiz()`, que será llamada cuando alguien visite el sitio web en la URL raíz (`/`), se establece una conexión a la base de datos SQLite (`blog.db`). Luego, se ajusta cómo deben devolverse los resultados del SELECT para obtenerlos como objetos diccionario, lo cual facilita su manipulación.

3. **Recuperación y Formateo de Datos**: Se ejecuta una consulta SQL que selecciona todos los registros de la tabla `articulos`. Los datos obtenidos se recorren en un bucle donde cada fila se convierte en un diccionario, y luego se añaden a una cadena HTML básica. Esta operación es importante porque permite presentar fácilmente los datos recuperados desde la base de datos en forma de texto web.

4. **Devolver Respuesta al Usuario**: Finalmente, la aplicación devuelve el contenido de `cadena` que contiene todos los títulos, fechas, textos y URLs de imágenes de los artículos en formato HTML simple, lo cual se mostrará directamente en un navegador web cuando alguien accede a la página.

Este código es una base para sitios web sencillos que requieren integrar datos almacenados en bases de datos SQL con páginas web interactivas utilizando Flask.

`010-ahora traigo flask.py`

```python
import sqlite3
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # Me conecto a la base de datos
  conexion = sqlite3.connect("blog.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM articulos;')
  filas = cursor.fetchall()
  cadena = ""
  for fila in filas:
    diccionario = dict(fila)
    cadena += diccionario['titulo']+"<br>"
    cadena += diccionario['fecha']+"<br>"
    cadena += diccionario['texto']+"<br>"
    cadena += diccionario['imagen']+"<br>"
  # Y devuelvo el resultado
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="127.0.0.1", port=5000,debug=True)
```

### html y css minimo
<small>Creado: 2025-10-13 16:31</small>

#### Explicación

Este código es una aplicación simple creada con Flask, un marco web de Python que ayuda a crear sitios web y APIs. La función principal de este fragmento de código es conectarse a una base de datos SQLite llamada `blog.db`, obtener todos los registros de la tabla `articulos` y generar dinámicamente una página HTML con estos datos.

El programa comienza creando un objeto Flask que actúa como el servidor web. Luego, utiliza un decorador para definir una ruta en el navegador (la raíz del sitio) que, cuando se accede a ella, ejecuta la función `raiz()`. Dentro de esta función, primero se establece una conexión con la base de datos y se realiza una consulta SQL (`SELECT * FROM articulos`) que recupera todas las filas de la tabla.

Cada fila recuperada se convierte en un diccionario para facilitar el acceso a los campos individuales. Luego, se construye una cadena HTML que incluye encabezados, datos del artículo (como título, fecha y texto) y un pie de página estático con información sobre el autor.

Finalmente, la función devuelve esta cadena de caracteres como respuesta HTTP al navegador web, lo cual muestra los artículos recuperados desde la base de datos en formato HTML. Esto permite que una aplicación web funcione directamente con la base de datos para presentar contenido dinámico y actualizado automáticamente.

`011-html y css minimo.py`

```python
import sqlite3
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # Me conecto a la base de datos
  conexion = sqlite3.connect("blog.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM articulos;')
  filas = cursor.fetchall()
  cadena = '''
  <!doctype html>
  <html>
    <head>
      <title>Blog de Jose Vicente</title>
    </head>
    <body>
      <header>
        <h1>El blog de Jose Vicente</h1>
      </header>
      <main>
  '''
  for fila in filas:
    diccionario = dict(fila)
    cadena += '<article>'
    cadena += '<h3>'+diccionario['titulo']+"</h3>"
    cadena += '<time>'+diccionario['fecha']+"</time>"
    cadena += '<p>'+diccionario['texto']+"</p>"
    cadena += '<img src="'+diccionario['imagen']+'">'
    cadena += '</article>'
  # Y devuelvo el resultado
  cadena += '''
    </main>
    <footer>
      (c) 2025 Jose Vicente Carratala
    </footer>
   </body>
   </html>
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="127.0.0.1", port=5000,debug=True)
```

### ahora css minimo
<small>Creado: 2025-10-13 16:35</small>

#### Explicación

Este fragmento de código es una aplicación web básica escrita en Python usando el framework Flask. La aplicación conecta a una base de datos SQLite para extraer información y genera un sitio web sencillo que muestra los artículos almacenados en la base de datos.

1. **Conexión con la Base de Datos:** El programa se conecta a la base de datos SQLite llamada "blog.db" y ejecuta una consulta SQL que selecciona todos los registros de la tabla "articulos". Cada artículo es representado como un diccionario en Python gracias al uso del método `row_factory`.

2. **Generación del HTML:** A continuación, el código genera dinámicamente una página web simple con encabezados (header), contenido principal (main) y pie de página (footer). Para cada registro obtenido de la base de datos, se crea un bloque `<article>` que incluye título, fecha, texto e imagen del artículo.

3. **Devuelve el HTML:** Finalmente, toda esta estructura HTML generada es devuelta como respuesta cuando alguien accede a la página principal (URL raíz) de la aplicación web. La función `raiz()` se encarga de conectar a la base de datos, generar el contenido HTML y enviarlo al navegador.

Esta práctica combina conocimientos de programación con SQL para manipular bases de datos y Flask para crear una interfaz web funcional que interactúa con dichas bases de datos, lo cual es fundamental en el desarrollo web.

`012-ahora css minimo.py`

```python
import sqlite3
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # Me conecto a la base de datos
  conexion = sqlite3.connect("blog.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM articulos;')
  filas = cursor.fetchall()
  cadena = '''
  <!doctype html>
  <html>
    <head>
      <title>Blog de Jose Vicente</title>
      <style>
        body{background:lightgray;font-family:sans-serif;}
        header,main,footer{width:400px;background:white;margin:auto;padding:20px;}
      </style>
      
    </head>
    <body>
      <header>
        <h1>El blog de Jose Vicente</h1>
      </header>
      <main>
  '''
  for fila in filas:
    diccionario = dict(fila)
    cadena += '<article>'
    cadena += '<h3>'+diccionario['titulo']+"</h3>"
    cadena += '<time>'+diccionario['fecha']+"</time>"
    cadena += '<p>'+diccionario['texto']+"</p>"
    cadena += '<img src="'+diccionario['imagen']+'">'
    cadena += '</article>'
  # Y devuelvo el resultado
  cadena += '''
    </main>
    <footer>
      (c) 2025 Jose Vicente Carratala
    </footer>
   </body>
   </html>
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="127.0.0.1", port=5000,debug=True)
```

### imagenes en static
<small>Creado: 2025-10-13 16:38</small>

#### Explicación

Este fragmento de código es un ejemplo básico de cómo crear una aplicación web simple usando Python y la biblioteca Flask. La aplicación se conecta a una base de datos SQLite llamada `blog.db` para recuperar información sobre artículos del blog y luego genera HTML dinámico que muestra esos artículos en el navegador.

En primer lugar, el código importa las librerías necesarias: `sqlite3` para manejar la base de datos y `Flask` para crear la aplicación web. Luego, se crea una instancia de Flask llamada `aplicacion`.

El corazón del código es la función `raiz()`, que define cómo se comportará el servidor cuando alguien acceda a la raíz del sitio web (la URL principal). Dentro de esta función:

1. Se conecta a la base de datos SQLite y ejecuta una consulta SQL para recuperar todos los artículos almacenados en la tabla `articulos`.
2. Recorre cada fila devuelta por la consulta y añade al HTML básico elementos como el título, la fecha, el texto del artículo y una imagen asociada.
3. Finalmente, junta todo esto en un único string de HTML completo que Flask enviará al navegador cuando alguien visite la página.

Este código es importante porque demuestra cómo las aplicaciones web pueden interactuar con bases de datos para mostrar información dinámica en lugar de solo servir archivos estáticos como HTML o CSS. Además, muestra cómo manejar los archivos y las imágenes que se necesitan para hacer funcionar una aplicación web básica utilizando Flask y SQLite.

`013-imagenes en static.py`

```python
import sqlite3
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # Me conecto a la base de datos
  conexion = sqlite3.connect("blog.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM articulos;')
  filas = cursor.fetchall()
  cadena = '''
  <!doctype html>
  <html>
    <head>
      <title>Blog de Jose Vicente</title>
      <style>
        body{background:lightgray;font-family:sans-serif;}
        header,main,footer{width:400px;background:white;margin:auto;padding:20px;}
      </style>
      
    </head>
    <body>
      <header>
        <h1>El blog de Jose Vicente</h1>
      </header>
      <main>
  '''
  for fila in filas:
    diccionario = dict(fila)
    cadena += '<article>'
    cadena += '<h3>'+diccionario['titulo']+"</h3>"
    cadena += '<time>'+diccionario['fecha']+"</time>"
    cadena += '<p>'+diccionario['texto']+"</p>"
    cadena += '<img src="static/'+diccionario['imagen']+'">'
    cadena += '</article>'
  # Y devuelvo el resultado
  cadena += '''
    </main>
    <footer>
      (c) 2025 Jose Vicente Carratala
    </footer>
   </body>
   </html>
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="127.0.0.1", port=5000,debug=True)
```

### nuevas entradas
<small>Creado: 2025-10-13 16:36</small>

#### Explicación

El código que has proporcionado está escrito en SQL y se utiliza para insertar nuevos registros en una tabla llamada `articulos`. Cada instrucción `INSERT INTO` agrega un nuevo artículo a la base de datos. La estructura de cada entrada es la misma: primero, el ID del artículo se establece en `NULL`, lo que indica al motor de bases de datos SQLite que debe generar automáticamente un valor único para este campo. Luego, siguen los campos adicionales como el título, fecha, texto y nombre de la imagen asociada a cada artículo.

Este código es importante porque permite ampliar el conjunto de datos almacenados en tu base de datos, haciendo que tu sitio web tenga más contenido y esté actualizado con nuevos artículos. Es una práctica común para mantener un blog o cualquier otro sistema que dependa de una fuente constante de información nueva e interesante.

**ÚLTIMO PÁRRAFO:**
Este archivo `013-nuevas entradas.sql` representa la continuación directa del ejercicio anterior, pero en lugar de generar HTML dinámico basado en los datos existentes en la base de datos, este código inserta nuevos registros en la tabla `articulos`, lo que aumenta el conjunto de datos utilizado por el sitio web.

`013-nuevas entradas.sql`

```sql
INSERT INTO articulos VALUES(
	NULL,
	"Articulo numero 5",
	"2025-10-14",
	"Este es el texto del articulo 5",
	"josevicente.jpg"
);
INSERT INTO articulos VALUES(
	NULL,
	"Articulo numero 6",
	"2025-10-15",
	"Este es el texto del articulo 6",
	"josevicente.jpg"
);
INSERT INTO articulos VALUES(
	NULL,
	"Articulo numero 7",
	"2025-10-16",
	"Este es el texto del articulo 7",
	"josevicente.jpg"
);
```

### imagenes en static
<small>Creado: 2025-10-13 16:38</small>

#### Explicación

Este código es una aplicación web sencilla en Python utilizando el framework Flask y una base de datos SQLite. Su función principal es conectarse a la base de datos para recuperar información sobre artículos publicados (título, fecha, texto e imagen) y luego mostrar estos detalles en un formato HTML básico.

El programa inicia creando una instancia del servidor web Flask. Luego, define una ruta raíz ("/") que se activa cuando alguien visita la página principal del sitio web. Dentro de esta función (`raiz()`), el código se conecta a una base de datos SQLite llamada `blog.db`, ejecuta una consulta SQL para obtener todos los artículos registrados y luego construye una respuesta HTML estática con esos datos.

Para cada artículo recuperado, el programa añade información específica como título, fecha, texto del artículo y enlace a la imagen. Las imágenes se almacenan en un directorio llamado `static`, y su ubicación relativa es incluida en las etiquetas `<img>` de HTML.

Finalmente, cuando todas las filas (artículos) han sido procesadas, el código completa el formato HTML con un pie de página y luego devuelve toda la cadena de texto como respuesta al navegador web. Si ejecutas este script, podrás ver esta información estructurada en una página web local a través del servidor Flask.

Este fragmento es importante porque muestra cómo integrar bases de datos y lenguajes de programación para crear sitios web dinámicos que pueden actualizar automáticamente según la información almacenada.

`014-imagenes en static.py`

```python
import sqlite3
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # Me conecto a la base de datos
  conexion = sqlite3.connect("blog.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM articulos;')
  filas = cursor.fetchall()
  cadena = '''
  <!doctype html>
  <html>
    <head>
      <title>Blog de Jose Vicente</title>
      <style>
        body{background:lightgray;font-family:sans-serif;}
        header,main,footer{width:400px;background:white;margin:auto;padding:20px;}
      </style>
      
    </head>
    <body>
      <header>
        <h1>El blog de Jose Vicente</h1>
      </header>
      <main>
  '''
  for fila in filas:
    diccionario = dict(fila)
    cadena += '<article>'
    cadena += '<h3>'+diccionario['titulo']+"</h3>"
    cadena += '<time>'+diccionario['fecha']+"</time>"
    cadena += '<p>'+diccionario['texto']+"</p>"
    cadena += '<img src="static/'+diccionario['imagen']+'">'
    cadena += '</article>'
  # Y devuelvo el resultado
  cadena += '''
    </main>
    <footer>
      (c) 2025 Jose Vicente Carratala
    </footer>
   </body>
   </html>
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="127.0.0.1", port=5000,debug=True)
```

### un poco de grid
<small>Creado: 2025-10-13 16:41</small>

#### Explicación

Este código es una pequeña aplicación web en Python que utiliza Flask para mostrar los artículos de un blog almacenados en una base de datos SQLite llamada `blog.db`. La aplicación se encarga de conectarse a la base de datos y recuperar todos los registros de la tabla `articulos`, luego crea dinámicamente una página HTML con esta información.

El código comienza importando las bibliotecas necesarias, Flask para crear la aplicación web y sqlite3 para manejar la base de datos. Luego se define una ruta raíz ("/") que, cuando se accede desde un navegador web, ejecuta la función `raiz()`. Dentro de esta función, se realiza la conexión a la base de datos, se obtienen todos los registros de la tabla `articulos`, y por cada registro obtenido, se añade una estructura HTML que representa ese artículo en la página.

La parte crucial es cómo construye la cadena HTML (`cadena`) con un bucle que itera sobre los artículos recuperados de la base de datos. Cada artículo contiene información como el título, fecha, texto y nombre de imagen, que se incorporan directamente dentro del código HTML generado. Además, hay estilos CSS básicos definidos en línea para dar formato a la página web, incluyendo un diseño de cuadrícula que muestra los artículos en varias columnas.

Finalmente, si el script se ejecuta directamente (no importado como módulo), la aplicación Flask se inicia en modo depuración y escucha en localhost en el puerto 5000. Esto permite a un desarrollador probar fácilmente su página web sin necesidad de desplegarla en un servidor remoto.

Este tipo de código es importante porque demuestra cómo integrar bases de datos con aplicaciones web, permitiendo que la información esté actualizada automáticamente cada vez que se carga la página.

`015-un poco de grid.py`

```python
import sqlite3
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # Me conecto a la base de datos
  conexion = sqlite3.connect("blog.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM articulos;')
  filas = cursor.fetchall()
  cadena = '''
  <!doctype html>
  <html>
    <head>
      <title>Blog de Jose Vicente</title>
      <style>
        body{background:lightgray;font-family:sans-serif;}
        header,main,footer{width:600px;background:white;margin:auto;padding:20px;}
        main{display:grid;grid-template-columns: auto auto auto;gap:20px;}
        article img{width:100%;}
      </style>
      
    </head>
    <body>
      <header>
        <h1>El blog de Jose Vicente</h1>
      </header>
      <main>
  '''
  for fila in filas:
    diccionario = dict(fila)
    cadena += '<article>'
    cadena += '<h3>'+diccionario['titulo']+"</h3>"
    cadena += '<time>'+diccionario['fecha']+"</time>"
    cadena += '<p>'+diccionario['texto']+"</p>"
    cadena += '<img src="static/'+diccionario['imagen']+'">'
    cadena += '</article>'
  # Y devuelvo el resultado
  cadena += '''
    </main>
    <footer>
      (c) 2025 Jose Vicente Carratala
    </footer>
   </body>
   </html>
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="127.0.0.1", port=5000,debug=True)
```

### texto alternativo
<small>Creado: 2025-10-13 16:42</small>

#### Explicación

Este fragmento de código es un ejemplo sencillo de cómo crear una aplicación web básica utilizando Flask en Python para mostrar los artículos de un blog almacenados en una base de datos SQLite. El archivo `texto alternativo.py` se encarga de realizar varias tareas clave:

1. **Conexión a la Base de Datos**: La aplicación primero se conecta a una base de datos SQLite llamada `blog.db`. Aquí, selecciona todos los artículos de una tabla llamada `articulos`.

2. **Generación de HTML dinámico**: Después de obtener los datos desde la base de datos, el código construye un documento HTML en formato de cadena (`cadena`). Este HTML incluye un encabezado que muestra el título del blog y una sección principal donde cada artículo es presentado en su propio bloque con detalles como el título, fecha, texto y una imagen asociada.

3. **Devolver la Respuesta al Cliente**: Finalmente, la cadena de caracteres que contiene todo el HTML construido se retorna al cliente web que ha solicitado la página del blog. 

Este código es importante porque combina las bases de la programación web (como Flask para manejar solicitudes HTTP) con operaciones de base de datos y construcción de páginas HTML dinámicas, permitiendo a los desarrolladores crear sitios web interactivos que pueden mostrar contenido actualizado desde una base de datos.

`016-texto alternativo.py`

```python
import sqlite3
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # Me conecto a la base de datos
  conexion = sqlite3.connect("blog.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM articulos;')
  filas = cursor.fetchall()
  cadena = '''
  <!doctype html>
  <html>
    <head>
      <title>Blog de Jose Vicente</title>
      <style>
        body{background:lightgray;font-family:sans-serif;}
        header,main,footer{width:600px;background:white;margin:auto;padding:20px;}
        main{display:grid;grid-template-columns: auto auto auto;gap:20px;}
        article img{width:100%;}
      </style>
      
    </head>
    <body>
      <header>
        <h1>El blog de Jose Vicente</h1>
      </header>
      <main>
  '''
  for fila in filas:
    diccionario = dict(fila)
    cadena += '<article>'
    cadena += '<h3>'+diccionario['titulo']+"</h3>"
    cadena += '<time>'+diccionario['fecha']+"</time>"
    cadena += '<p>'+diccionario['texto']+"</p>"
    cadena += '<img src="static/'+diccionario['imagen']+'" alt="Imagen de blog">'
    cadena += '</article>'
  # Y devuelvo el resultado
  cadena += '''
    </main>
    <footer>
      (c) 2025 Jose Vicente Carratala
    </footer>
   </body>
   </html>
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="127.0.0.1", port=5000,debug=True)
```

### adapto ip
<small>Creado: 2025-10-13 16:54</small>

#### Explicación

Este código Python utiliza la biblioteca Flask para crear una aplicación web simple que muestra los artículos de un blog almacenados en una base de datos SQLite. Aquí te explico cómo funciona:

- **Conexión a la Base de Datos**: El programa se conecta a una base de datos llamada `blog.db` y ejecuta una consulta SQL para recuperar todos los registros de la tabla `articulos`.

- **Generación del HTML**: Después, el código genera un fragmento de HTML que incluye un encabezado, un cuerpo principal donde muestra cada artículo en formato de tarjeta (cada tarjeta tiene un título, fecha, texto y una imagen), y un pie de página con la información de copyright.

- **Rendimiento del HTML**: La cadena `cadena` es construida iterando sobre los resultados obtenidos desde la base de datos. Para cada fila, se extrae el diccionario correspondiente y se añaden al código HTML las etiquetas necesarias para mostrar un artículo en formato web. 

- **Ejecución del Servidor Web**: Al finalizar, la aplicación Flask ejecuta un servidor web local que escucha en la dirección IP `192.168.1.78` y en el puerto 8080. Esto permite a cualquier dispositivo conectado al mismo red acceder a esta página web.

Este código es importante porque muestra cómo combinar bases de datos, Python y programación web para crear páginas dinámicas que pueden mostrar información almacenada en una base de datos SQLite a través de una interfaz web.

`017-adapto ip.py`

```python
import sqlite3
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # Me conecto a la base de datos
  conexion = sqlite3.connect("blog.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM articulos;')
  filas = cursor.fetchall()
  cadena = '''
  <!doctype html>
  <html>
    <head>
      <title>Blog de Jose Vicente</title>
      <style>
        body{background:lightgray;font-family:sans-serif;}
        header,main,footer{width:600px;background:white;margin:auto;padding:20px;}
        main{display:grid;grid-template-columns: auto auto auto;gap:20px;}
        article img{width:100%;}
      </style>
      
    </head>
    <body>
      <header>
        <h1>El blog de Jose Vicente</h1>
      </header>
      <main>
  '''
  for fila in filas:
    diccionario = dict(fila)
    cadena += '<article>'
    cadena += '<h3>'+diccionario['titulo']+"</h3>"
    cadena += '<time>'+diccionario['fecha']+"</time>"
    cadena += '<p>'+diccionario['texto']+"</p>"
    cadena += '<img src="static/'+diccionario['imagen']+'" alt="Imagen de blog">'
    cadena += '</article>'
  # Y devuelvo el resultado
  cadena += '''
    </main>
    <footer>
      (c) 2025 Jose Vicente Carratala
    </footer>
   </body>
   </html>
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run(host="192.168.1.78", port=8080,debug=True)
```

### Actividades propuestas

Este es un proyecto de creación de un blog básico utilizando Flask y SQLite en Python. Aquí está una descripción detallada del contenido:

### Archivos SQL

- **00-database.sql**: Creación inicial de la base de datos con una tabla llamada `articulos`.
- **01-insert-values.sql**: Inserción de valores iniciales en la tabla `articulos`.
- **013-nuevas entradas.sql**: Inserción adicional de nuevos artículos en la tabla `articulos`.

### Archivos Python

- **017-adapto ip.py**: Versión final del código principal que crea el blog, adaptado para correr en una IP específica.
  
El archivo `.py` contiene:
  - Importación de Flask y SQLite.
  - Configuración inicial de la aplicación Flask.
  - Conexión a la base de datos `blog.db`.
  - Consulta a la tabla `articulos` y generación dinámica del HTML para mostrar los artículos en una estructura grid.
  - Adaptación para correr en IP específica (192.168.1.78) en el puerto 8080.

### Archivos de Estilo

- **Estilos incorporados**: El estilo CSS está incrustado directamente dentro del archivo Python como una cadena HTML. Esto incluye:
    - Diseño de la estructura general (header, main, footer).
    - Estilización para una disposición grid en `main`.
    - Alineación y formato específico para las imágenes (`img{width:100%}`).

### Contenido del Blog

- El contenido del blog se genera dinámicamente basado en los datos de la base de datos. Cada artículo contiene:
  - Título (h3)
  - Fecha (time element)
  - Texto (p)
  - Imagen con texto alternativo.

### Rutas HTTP

El código solo maneja la ruta raíz (`/`) para mostrar el contenido del blog. 

### Consideraciones Adicionales
- La aplicación se está ejecutando en modo de depuración.
- El directorio `static` es mencionado para alojar imágenes y otros recursos estáticos.

Este proyecto es un buen ejemplo básico de cómo integrar Flask con una base de datos SQLite para crear una página web dinámica y estructurarla utilizando HTML y CSS.


<a id="refresco-full-stack"></a>
## Refresco full stack

### Introducción a los ejercicios

To summarize and provide a solution based on the provided files, it appears that you are building a Flask web application with multiple routes and templates. The goal seems to be creating pages dynamically using data from an SQLite database.

Below is an enhanced version of your Flask application that incorporates routing, template rendering, styling, and dynamic content from a database:

1. **Set up the project structure:**

   ```
   my_flask_app/
   ├── app.py
   ├── templates/
   │   ├── index.html
   │   ├── sobremi.html
   │   └── contacto.html
   └── blog.db
   ```

2. **Update `app.py`:**

    ```python
    from flask import Flask, render_template, redirect, url_for
    import sqlite3

    app = Flask(__name__)

    # Define routes for different pages
    @app.route("/")
    def raiz():
        return render_template("index.html")

    @app.route("/sobremi")
    def sobremi():
        return render_template("sobremi.html")

    @app.route("/contacto")
    def contacto():
        return render_template("contacto.html")

    # Route for dynamic content
    @app.route("/productos")
    def productos():
        conn = sqlite3.connect('blog.db')
        cursor = conn.cursor()
        
        # Execute a query to get product data from the database
        cursor.execute("SELECT * FROM productos LIMIT 20;")
        products = cursor.fetchall()

        conn.close()

        return render_template("productos.html", products=products)

    if __name__ == "__main__":
        app.run(debug=True)
    ```

3. **Create templates in `templates/`:**

   - **index.html:**
     ```html
     <!doctype html>
     <html lang="es">
       <head>
         <title>Home</title>
         <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
       </head>
       <body>
         <header>
           <h1>Bienvenido a mi web</h1>
           <nav>
             <a href="/">Inicio</a>
             <a href="/sobremi">Sobre mí</a>
             <a href="/contacto">Contacto</a>
             <a href="/productos">Productos</a>
           </nav>
         </header>

         <main>
           <h2>¡Bienvenido!</h2>
           <p>Puedes navegar por la web en los diferentes enlaces del menú.</p>
         </main>
       </body>
     </html>
     ```

   - **sobremi.html:**
     ```html
     <!doctype html>
     <html lang="es">
       <head>
         <title>Sobre mí</title>
         <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
       </head>
       <body>
         <header>
           <h1>Bienvenido a mi web</h1>
           <nav>
             <a href="/">Inicio</a>
             <a href="/sobremi">Sobre mí</a>
             <a href="/contacto">Contacto</a>
             <a href="/productos">Productos</a>
           </nav>
         </header>

         <main>
           <h2>Sobre mí</h2>
           <p>Esta es la página donde puedes conocerme un poco más.</p>
         </main>
       </body>
     </html>
     ```

   - **contacto.html:**
     ```html
     <!doctype html>
     <html lang="es">
       <head>
         <title>Contacto</title>
         <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
       </head>
       <body>
         <header>
           <h1>Bienvenido a mi web</h1>
           <nav>
             <a href="/">Inicio</a>
             <a href="/sobremi">Sobre mí</a>
             <a href="/contacto">Contacto</a>
             <a href="/productos">Productos</a>
           </nav>
         </header>

         <main>
           <h2>Contacto</h2>
           <p>Información de contacto.</p>
         </main>
       </body>
     </html>
     ```

   - **productos.html:**
     ```html
     <!doctype html>
     <html lang="es">
       <head>
         <title>Productos</title>
         <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
       </head>
       <body>
         <header>
           <h1>Bienvenido a mi web</h1>
           <nav>
             <a href="/">Inicio</a>
             <a href="/sobremi">Sobre mí</a>
             <a href="/contacto">Contacto</a>
             <a href="/productos">Productos</a>
           </nav>
         </header>

         <main>
           <h2>Lista de Productos</h2>
           <ul>
             {% for product in products %}
               <li>{{ product[1] }} - {{ product[3] }}</li>
             {% endfor %}
           </ul>
         </main>
       </body>
     </html>
     ```

4. **Create `styles.css` in a `static/` folder:**

   ```
   my_flask_app/
   ├── app.py
   ├── templates/
   │   ├── index.html
   │   ├── sobremi.html
   │   └── contacto.html
   ├── static/
   │   └── styles.css
   └── blog.db
   ```

   - **styles.css:**
     ```css
     body, html {
       background-color: grey;
       font-family: sans-serif;
     }

     header, main, footer {
       background-color: white;
       padding: 20px;
       margin: auto;
       width: 600px;
     }

     nav a {
       text-decoration: none;
       color: inherit;
     }
     ```

5. **Ensure the `blog.db` SQLite database has been created and populated with data, as per your SQL statements (e.g., `014-ahora con css.py`, `009-20 productos mas.sql`).**

By following these steps, you will have a Flask application that serves multiple pages with dynamic content from an SQLite database. This example demonstrates how to structure and serve HTML files dynamically using Flask's routing mechanism and template rendering capabilities.

Let me know if you need further assistance or specific configurations!

### Esquema full stack
<small>Creado: 2025-10-20 19:18</small>

#### Explicación

The SVG you've provided appears to be a visual representation of skills or knowledge domains, likely used as a skill graph or proficiency chart for someone's resume or personal website. Here’s an analysis and interpretation based on the content:

### Structure Overview:
- The diagram uses `rect` elements (with rounded corners) to represent different categories or areas of expertise.
- Text within these rectangles provides labels such as "HTML", "Python/PHP", "Bases de datos" (Databases), etc.
- Arrows (`path` elements with specific markers) indicate relationships or connections between different skill domains.

### Skill Domains:
1. **Programming Languages:**
   - HTML
   - Python/PHP
   - SQL (implied through "MySQL/SQLite")

2. **Technologies and Frameworks:**
   - SQLite3 (database technology)
   - Flask (implied by mentioning `sqlite3`)

### Relationships Between Skills:
- Arrows between categories suggest dependencies or relationships.
  - For example, there are arrows connecting HTML to SQL databases, implying that knowledge of HTML can be used in the context of web applications and databases.

### Visual Indicators:
- **Red Circles:** Represent specific achievements or projects within a domain (e.g., a circle near "HTML" might represent an accomplished project using this technology).
- **Green Circles:** May indicate areas where significant growth or development has occurred over time.

### Suggestions for Improvement and Use:

1. **Enhance Readability:**
   - Ensure text labels are clear and concise.
   - Consider adding tooltips or descriptions on hover to provide more context about each skill domain.

2. **Interactive Elements:**
   - Add clickable links that navigate to detailed descriptions of projects related to specific skills.
   - Implement interactive features like expanding a section for more information when clicked.

3. **Dynamic Update Capability:**
   - Create an interface where users can update their proficiency levels dynamically (e.g., adjusting the size or color of rectangles based on self-assessment).

4. **Exporting and Sharing Options:**
   - Allow exporting the skill graph as images or in other formats for use in resumes, LinkedIn profiles, etc.

5. **Accessibility Enhancements:**
   - Ensure that screen readers can interpret the content accurately.
   - Provide alternative text descriptions for non-visual users.

### Example of Potential Updates:
If you wanted to enhance this SVG:

```xml
<!-- Adding a hover effect example -->
<defs>
  <style type="text/css"><![CDATA[
    .skill:hover {
      fill: #00bfff; /* Change color on hover */
    }
  ]]></style>
</defs>

<g id="skills">
  <!-- Example rectangle with hover effect -->
  <rect class="skill" x="50" y="100" width="71.123688" height="19.930264" rx="4.8848686" style="fill:#00ffff;stroke:#000000;stroke-width:1.38"/>
</g>
```

This would allow users to see more information or highlight specific skills when interacting with the graphic.

### Conclusion:
The SVG is a well-structured visual representation of skill domains. By enhancing its interactivity, readability, and functionality, it can become an effective tool for showcasing professional competencies online.

`001-Esquema full stack.svg`

```
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   width="297mm"
   height="210mm"
   viewBox="0 0 297 210"
   version="1.1"
   id="svg1"
   inkscape:version="1.4.2 (1:1.4.2+202505120737+ebf0e940d0)"
   sodipodi:docname="001-Esquema full stack.svg"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#ffffff"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     inkscape:document-units="mm"
     inkscape:zoom="0.95749083"
     inkscape:cx="630.29324"
     inkscape:cy="377.02711"
     inkscape:window-width="1920"
     inkscape:window-height="971"
     inkscape:window-x="0"
     inkscape:window-y="32"
     inkscape:window-maximized="1"
     inkscape:current-layer="layer1" />
  <defs
     id="defs1">
    <marker
       style="overflow:visible"
       id="ArrowWide"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2" />
    </marker>
    <marker
       style="overflow:visible"
       id="ArrowWide-7"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2-3" />
    </marker>
    <marker
       style="overflow:visible"
       id="ArrowWide-6"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2-1" />
    </marker>
    <marker
       style="overflow:visible"
       id="ArrowWide-7-0"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2-3-6" />
    </marker>
    <marker
       style="overflow:visible"
       id="ArrowWide-5"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2-4" />
    </marker>
    <marker
       style="overflow:visible"
       id="ArrowWide-7-7"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2-3-4" />
    </marker>
    <marker
       style="overflow:visible"
       id="ArrowWide-6-4"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2-1-3" />
    </marker>
    <marker
       style="overflow:visible"
       id="ArrowWide-7-0-0"
       refX="0"
       refY="0"
       orient="auto-start-reverse"
       inkscape:stockid="Wide arrow"
       markerWidth="1"
       markerHeight="1"
       viewBox="0 0 1 1"
       inkscape:isstock="true"
       inkscape:collect="always"
       preserveAspectRatio="xMidYMid">
      <path
         style="fill:none;stroke:context-stroke;stroke-width:1;stroke-linecap:butt"
         d="M 3,-3 0,0 3,3"
         transform="rotate(180,0.125,0)"
         sodipodi:nodetypes="ccc"
         id="path2-3-6-7" />
    </marker>
  </defs>
  <g
     inkscape:label="Capa 1"
     inkscape:groupmode="layer"
     id="layer1">
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1-3-9-1"
       width="143.24579"
       height="159.75319"
       x="8.9871988"
       y="20.939737"
       ry="4.8848686" />
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1-3-9"
       width="124.73168"
       height="138.75211"
       x="17.444403"
       y="33.471813"
       ry="4.8848686" />
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1-3"
       width="71.123688"
       height="19.930264"
       x="52.815788"
       y="53.954731"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="82.924461"
       y="66.080948"
       id="text1-5"><tspan
         sodipodi:role="line"
         id="tspan1-6"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="82.924461"
         y="66.080948">CSS</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="23.347557"
       y="52.040302"
       id="text1-5-2"><tspan
         sodipodi:role="line"
         id="tspan1-6-6"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="23.347557"
         y="52.040302">Lenguajes de marcas</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="23.393692"
       y="102.72272"
       id="text1-5-2-2"><tspan
         sodipodi:role="line"
         id="tspan1-6-6-2"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="23.393692"
         y="102.72272">Programación</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="102.38627"
       y="99.062225"
       id="text1-5-2-2-7"><tspan
         sodipodi:role="line"
         id="tspan1-6-6-2-6"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="102.38627"
         y="99.062225">flask</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="104.1509"
       y="134.67635"
       id="text1-5-2-2-7-7"><tspan
         sodipodi:role="line"
         id="tspan1-6-6-2-6-4"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="104.1509"
         y="134.67635">sqlite3</tspan></text>
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1"
       width="71.123688"
       height="19.930264"
       x="52.888294"
       y="69.846947"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.74619px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322;stroke-linecap:round;stroke-linejoin:round"
       x="79.232765"
       y="82.057823"
       id="text1"><tspan
         sodipodi:role="line"
         id="tspan1"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322"
         x="79.232765"
         y="82.057823">HTML</tspan></text>
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1-7-2"
       width="71.123688"
       height="19.930264"
       x="52.640656"
       y="104.63715"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.74619px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322;stroke-linecap:round;stroke-linejoin:round"
       x="70.004395"
       y="116.84802"
       id="text1-0-0"><tspan
         sodipodi:role="line"
         id="tspan1-9-2"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322"
         x="70.004395"
         y="116.84802">Python/PHP</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="22.789604"
       y="137.84715"
       id="text1-5-2-2-4"><tspan
         sodipodi:role="line"
         id="tspan1-6-6-2-7"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="22.789604"
         y="137.84715">Bases de datos</tspan></text>
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1-7-2-8"
       width="71.123688"
       height="19.930264"
       x="52.036568"
       y="139.76158"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.74619px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322;stroke-linecap:round;stroke-linejoin:round"
       x="64.840858"
       y="151.97246"
       id="text1-0-0-4"><tspan
         sodipodi:role="line"
         id="tspan1-9-2-5"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322"
         x="64.840858"
         y="151.97246">MySQL/SQLite</tspan></text>
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide)"
       d="M 76.433359,104.63714 V 89.777214"
       id="path1" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide-7)"
       d="M 98.292404,89.146404 V 104.00633"
       id="path1-2" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide-6)"
       d="M 78.145912,141.43815 V 126.57822"
       id="path1-0" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide-7-0)"
       d="m 100.00495,125.94741 v 14.85993"
       id="path1-2-6" />
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1-3-8"
       width="71.123688"
       height="19.930264"
       x="189.09117"
       y="50.783554"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="219.19986"
       y="62.909775"
       id="text1-5-8"><tspan
         sodipodi:role="line"
         id="tspan1-6-4"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="219.19986"
         y="62.909775">CSS</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="159.62296"
       y="48.869125"
       id="text1-5-2-3"><tspan
         sodipodi:role="line"
         id="tspan1-6-6-1"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="159.62296"
         y="48.869125">Lenguajes de marcas</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="159.66908"
       y="99.551544"
       id="text1-5-2-2-49"><tspan
         sodipodi:role="line"
         id="tspan1-6-6-2-2"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="159.66908"
         y="99.551544">Programación</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="238.66167"
       y="95.891052"
       id="text1-5-2-2-7-0"><tspan
         sodipodi:role="line"
         id="tspan1-6-6-2-6-6"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="238.66167"
         y="95.891052">flask</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="240.4263"
       y="131.50517"
       id="text1-5-2-2-7-7-8"><tspan
         sodipodi:role="line"
         id="tspan1-6-6-2-6-4-9"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="240.4263"
         y="131.50517">sqlite3</tspan></text>
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1-2"
       width="71.123688"
       height="19.930264"
       x="189.1637"
       y="66.675774"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.74619px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322;stroke-linecap:round;stroke-linejoin:round"
       x="215.50816"
       y="78.88665"
       id="text1-6"><tspan
         sodipodi:role="line"
         id="tspan1-64"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322"
         x="215.50816"
         y="78.88665">HTML</tspan></text>
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1-7-2-9"
       width="71.123688"
       height="19.930264"
       x="188.91605"
       y="101.46598"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.74619px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322;stroke-linecap:round;stroke-linejoin:round"
       x="206.2798"
       y="113.67685"
       id="text1-0-0-5"><tspan
         sodipodi:role="line"
         id="tspan1-9-2-0"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322"
         x="206.2798"
         y="113.67685">Python/PHP</tspan></text>
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.51291px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308;stroke-linecap:round;stroke-linejoin:round"
       x="159.065"
       y="134.67598"
       id="text1-5-2-2-4-4"><tspan
         sodipodi:role="line"
         id="tspan1-6-6-2-7-8"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.8308"
         x="159.065"
         y="134.67598">Bases de datos</tspan></text>
    <rect
       style="fill:#00ffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round"
       id="rect1-7-2-8-7"
       width="71.123688"
       height="19.930264"
       x="188.31197"
       y="136.59041"
       ry="4.8848686" />
    <text
       xml:space="preserve"
       style="font-weight:bold;font-size:6.74619px;font-family:Ubuntu;-inkscape-font-specification:'Ubuntu Bold';text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322;stroke-linecap:round;stroke-linejoin:round"
       x="201.11624"
       y="148.80128"
       id="text1-0-0-4-1"><tspan
         sodipodi:role="line"
         id="tspan1-9-2-5-7"
         style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:2.9322"
         x="201.11624"
         y="148.80128">MySQL/SQLite</tspan></text>
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide-5)"
       d="M 212.70876,101.46596 V 86.606037"
       id="path1-27" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide-7-7)"
       d="M 234.5678,85.975227 V 100.83515"
       id="path1-2-2" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide-6-4)"
       d="M 214.42131,138.26697 V 123.40704"
       id="path1-0-2" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1;marker-end:url(#ArrowWide-7-0-0)"
       d="m 236.28035,122.77623 v 14.85993"
       id="path1-2-6-6" />
    <circle
       style="fill:#ff2a2a;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       id="path3"
       cx="110.87737"
       cy="81.586395"
       r="2.5560513" />
    <circle
       style="fill:#99ff55;fill-opacity:1;stroke:#000000;stroke-width:1.38;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:1"
       id="path3-5"
       cx="248.69147"
       cy="78.758316"
       r="2.5560513" />
  </g>
</svg>
```

### flask hola mundo
<small>Creado: 2025-10-20 15:39</small>

#### Explicación

Este código es un ejemplo básico de cómo crear una aplicación web simple usando Flask, que es un microframework para desarrollar aplicaciones web en Python. En primer lugar, se importa la clase `Flask` del módulo flask.

Luego, se crea una instancia de la aplicación llamada `aplicacion`. Esta línea indica al framework que estamos creando una nueva aplicación y le da a Flask el nombre de nuestro archivo como referencia para configuraciones internas.

El decorador `@aplicacion.route("/")` define qué función debe ejecutarse cuando alguien visite la página principal del sitio web (la URL base, sin ninguna ruta adicional). En este caso, se asocia con la función `raiz()`. Esta función simplemente retorna el texto "Hola mundo" cuando se accede a la página principal.

Finalmente, el bloque `if __name__ == "__main__":` asegura que la aplicación solo se ejecute si se ejecuta directamente desde este archivo (no si es importado por otro programa). Dentro de ese bloque, se llama a `aplicacion.run()`, lo que inicia el servidor web integrado y hace que nuestra aplicación sea accesible en un navegador.

Este código básico te ayuda a entender cómo estructurar una aplicación Flask y cómo responder con contenido HTML simple o texto puro.

`002-flask hola mundo.py`

```python
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():

  return "Hola mundo"
  
if __name__ == "__main__":
  aplicacion.run()
```

### html más válido
<small>Creado: 2025-10-20 15:40</small>

#### Explicación

Este fragmento de código es un ejemplo básico de cómo crear una aplicación web simple usando Flask, que es un marco ligero y fácil de usar para Python. La función principal del código es iniciar un servidor web local y mostrar una página HTML muy básica cuando alguien accede a la URL raíz ("/") del sitio.

El código comienza importando `Flask`, el módulo central que Flask proporciona, y luego crea una instancia de esta clase llamada `aplicacion`. La línea `@aplicacion.route("/")` define que la función que sigue (`raiz()`) será ejecutada cuando se solicite la URL principal del sitio web. Dentro de la función `raiz`, el código devuelve un bloque de HTML estático como respuesta, lo cual significa que cualquier persona que visite la página verá una simple página con el título "Tienda online" y un encabezado h1 también diciendo "Tienda online".

Finalmente, la línea `if __name__ == "__main__":` asegura que el servidor Flask solo se inicie si este archivo es ejecutado directamente (no importado como módulo en otro script). Cuando esto ocurre, `aplicacion.run()` comienza un servidor web local en modo desarrollo.

Este ejemplo es importante porque demuestra cómo conectar HTML básico con una aplicación web en Python utilizando Flask, lo cual es el primer paso hacia aplicaciones más complejas que pueden interactuar con bases de datos y permitir funcionalidades dinámicas.

`003-html más válido.py`

```python
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():

  return '''
    <!doctype html>
    <html lang="es">
      <head>
        <title>Tienda online</title>
        <meta charset="utf-8">
      </head>
      <body>
        <h1>Tienda online</h1>
      </body>
    </html>
  '''
  
if __name__ == "__main__":
  aplicacion.run()
```

### simulo una tienda online
<small>Creado: 2025-10-20 15:42</small>

#### Explicación

Este fragmento de código está configurado para crear una aplicación web muy básica utilizando Flask, un framework popular en Python. La función principal es mostrar una página HTML que simula la interfaz de una tienda online cuando alguien accede a la dirección base del servidor (por ejemplo, `http://localhost:5000/`).

El código comienza importando el módulo Flask y creando una instancia de la aplicación llamada `aplicacion`. Luego, con el decorador `@aplicacion.route("/")`, define qué debe hacer la función `raiz()` cuando alguien visita la ruta principal del sitio web (la URL base).

Dentro de la función `raiz()`, se devuelve un bloque grande de código HTML como una cadena única (`'''...'''`). Este código HTML crea una página web con un encabezado que dice "Tienda online", y luego muestra 12 artículos, todos ellos identificados por títulos genéricos como "Articulo" y el precio de $5.54€. Es importante notar que la etiqueta `<img>` no tiene ninguna URL en su atributo `src`, lo que significa que aún no se han añadido imágenes para estos artículos.

Finalmente, al final del archivo, hay una condición que asegura que la aplicación solo se ejecute si el script está siendo ejecutado directamente (no importado por otro script). Esta parte de código llama a `aplicacion.run()` para iniciar el servidor web en tu máquina local. Este es un paso fundamental para probar y ver cómo luciría la página web desde un navegador.

Este ejemplo es una introducción básica al uso de Flask y HTML, mostrando cómo servir contenido estático simple a través de un sitio web.

`004-simulo una tienda online.py`

```python
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():

  return '''
    <!doctype html>
    <html lang="es">
      <head>
        <title>Tienda online</title>
        <meta charset="utf-8">
      </head>
      <body>
        <header>
          <h1>Tienda online</h1>
        </header>
        <main>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
        </main>
        <footer>
        </footer>
      </body>
    </html>
  '''
  
if __name__ == "__main__":
  aplicacion.run()
```

### un poco de css
<small>Creado: 2025-10-20 15:45</small>

#### Explicación

Este fragmento de código en Python utiliza el framework Flask para crear una aplicación web sencilla que muestra un diseño básico de una tienda online. La aplicación tiene solo una ruta, la raíz ("/"), a la cual se le asigna una función llamada `raiz()`. Cuando un usuario accede a esa página, la función retorna directamente el código HTML necesario para dibujar en el navegador una página web con estilos incorporados.

El código HTML incluye elementos como `<header>`, `<main>` y `<footer>` que definen las diferentes secciones de la página. En el bloque `<main>`, hay varios artículos (`<article>`) dispuestos en un diseño de grilla de tres columnas, cada uno representando un artículo diferente con un precio fijo.

La parte más destacada es cómo incorpora CSS directamente dentro del HTML para definir estilos como colores de fondo y tamaños de letras. Esto permite centrar el contenido de la página en una ventana de 600 píxeles de ancho, utilizando una grilla CSS3 para organizar los artículos en tres columnas con un espacio entre ellas.

Este código es importante porque muestra cómo integrar diseño web y programación backend usando Flask, permitiendo crear páginas dinámicas que pueden cambiar según las necesidades del usuario o el estado actual de la aplicación.

`005-un poco de css.py`

```python
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():

  return '''
    <!doctype html>
    <html lang="es">
      <head>
        <title>Tienda online</title>
        <meta charset="utf-8">
        <style>
          body,html{background:grey;font-family:sans-serif;text-align:center;}
          header,footer,main{background:white;width:600px;margin:auto;padding:20px;}
          main{display:grid;grid-template-columns:auto auto auto;gap:20px;}
          main article img{
            width:100%;height:100px;background:grey;
          }
        </style>
      </head>
      <body>
        <header>
          <h1>Tienda online</h1>
        </header>
        <main>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
        </main>
        <footer>
        </footer>
      </body>
    </html>
  '''
  
if __name__ == "__main__":
  aplicacion.run()
```

### traigo sqlite
<small>Creado: 2025-10-20 15:56</small>

#### Explicación

Este fragmento de código es una aplicación web simple que utiliza Flask para servir un sitio web y SQLite para gestionar los datos. La función principal aquí es la definición del endpoint raíz ("/"), donde se realizan dos tareas principales: conectarse a una base de datos SQLite llamada `tiendaonline.db` y ejecutar una consulta SQL para obtener todos los registros de la tabla `productos`. Posteriormente, imprime estos registros en la consola.

Después de manejar los datos desde la base de datos, el código Flask devuelve un bloque HTML estático que representa la estructura de un sitio web básico para una tienda online. Este HTML incluye estilos CSS integrados y define una página con un encabezado, un contenido principal que muestra varios artículos (representados por bloques `<article>`), y un pie de página vacío.

Este código es importante porque demuestra cómo combinar Flask, una biblioteca popular para crear aplicaciones web en Python, con SQLite, una base de datos simple pero efectiva, para generar páginas web dinámicas que pueden mostrar información actualizada desde la base de datos. Sin embargo, hay un detalle a tener en cuenta: el HTML devuelto muestra artículos estáticos sin utilizar los registros reales obtenidos desde la base de datos, lo cual es algo que necesitarías mejorar para una aplicación real donde se muestran datos de forma dinámica.

`007-traigo sqlite.py`

```python
from flask import Flask  
import sqlite3

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  # BLOQUE SQLITE
  conexion = sqlite3.connect("tiendaonline.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM productos;')
  filas = cursor.fetchall()
  for fila in filas:
    print(fila)
  # BLOQUE FLASK
  return '''
    <!doctype html>
    <html lang="es">
      <head>
        <title>Tienda online</title>
        <meta charset="utf-8">
        <style>
          body,html{background:grey;font-family:sans-serif;text-align:center;}
          header,footer,main{background:white;width:600px;margin:auto;padding:20px;}
          main{display:grid;grid-template-columns:auto auto auto;gap:20px;}
          main article img{
            width:100%;height:100px;background:grey;
          }
        </style>
      </head>
      <body>
        <header>
          <h1>Tienda online</h1>
        </header>
        <main>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
          <article>
            <img src="">
            <h3>Articulo</h3>
            <p>5.54€</p>
          </article>
        </main>
        <footer>
        </footer>
      </body>
    </html>
  '''
  
if __name__ == "__main__":
  aplicacion.run()
```

### separo en tres bloques
<small>Creado: 2025-10-20 16:01</small>

#### Explicación

Este código es una aplicación web sencilla desarrollada usando Flask, un framework ligero para Python. La aplicación muestra los productos de una tienda online almacenados en una base de datos SQLite y los presenta en la página web.

El programa crea una instancia de la clase `Flask` llamada `aplicacion`, que es el núcleo del servidor web. Luego, define una ruta principal (`/`) que se ejecuta cuando un usuario accede a la raíz del sitio web. En esta función `raiz()`, se construye el HTML de la página.

La estructura del código está dividida en tres bloques principales:
1. **Cabeza Estática**: Aquí, el código genera el encabezado y los estilos CSS que determinan cómo se ve la página.
2. **Cuerpo Dinámico**: Este bloque es donde la magia ocurre. Conecta a una base de datos SQLite (`tiendaonline.db`), extrae información sobre los productos almacenados en ella, y genera HTML dinámicamente para cada producto encontrado. Esto incluye el nombre del producto y su precio.
3. **Pie de Página Estático**: Finalmente, completa la estructura HTML con un pie de página vacío.

La cadena `cadena` se utiliza para concatenar todo el contenido HTML generado, desde la cabecera hasta el cuerpo dinámico y el final del documento. Esto permite que la aplicación genere una página web única cada vez que alguien visita la URL raíz.

El código es importante porque demuestra cómo Flask puede integrarse fácilmente con bases de datos para crear páginas web dinámicas, lo cual es un concepto fundamental en desarrollo full-stack.

`008-separo en tres bloques.py`

```python
from flask import Flask  
import sqlite3

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  ####################### INICIO DE LA CADENA
  cadena = ''
  ####################### CABEZA ESTATICA
  cadena += '''
  <!doctype html>
    <html lang="es">
      <head>
        <title>Tienda online</title>
        <meta charset="utf-8">
        <style>
          body,html{background:grey;font-family:sans-serif;text-align:center;}
          header,footer,main{background:white;width:600px;margin:auto;padding:20px;}
          main{display:grid;grid-template-columns:auto auto auto;gap:20px;}
          main article img{
            width:100%;height:100px;background:grey;
          }
        </style>
      </head>
      <body>
        <header>
          <h1>Tienda online</h1>
        </header>
        <main>
  '''
  #################### CUERPO DINAMICO
  conexion = sqlite3.connect("tiendaonline.db")
  conexion.row_factory = sqlite3.Row
  cursor = conexion.cursor()
  cursor.execute('SELECT * FROM productos;')
  filas = cursor.fetchall()
  for fila in filas:
    cadena += '''
          <article>
            <img src="">
            <h3>'''+fila['nombre']+'''</h3>
            <p>'''+fila['precio']+'''</p>
          </article>
         '''
  ################### PIE DE PAGINA ESTATICO
  cadena += '''
        </main>
        <footer>
        </footer>
      </body>
    </html>
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run()
```

### 20 productos mas
<small>Creado: 2025-10-20 16:29</small>

#### Explicación

Este fragmento de código SQL está realizando inserciones en una tabla llamada `productos`. Cada línea dentro del bloque `VALUES` agrega un nuevo registro al conjunto de datos, especificando los detalles para cada producto. Estos detalles incluyen el nombre del producto, su descripción, precio y la ruta de la imagen asociada.

La estructura completa es muy útil en sistemas de gestión de inventario o tiendas online, ya que permite almacenar información detallada sobre productos para luego mostrarla a los clientes potenciales. Cada registro contiene datos específicos que ayudan tanto al usuario final como al administrador del sistema a entender y gestionar eficazmente el catálogo de productos.

Este tipo de inserción múltiple es especialmente conveniente cuando se necesita cargar una gran cantidad de datos iniciales en la base de datos, lo cual acelera significativamente el proceso de configuración inicial de un sistema o aplicación.

`009-20 productos mas.sql`

```sql
INSERT INTO productos (nombre, descripcion, precio, imagen) VALUES
('Sudadera deportiva', 'Sudadera con capucha, tejido cálido y transpirable para entrenamientos al aire libre.', '39.99 €', 'sudadera_deportiva.jpg'),
('Cinta para el pelo', 'Cinta elástica absorbente que mantiene el sudor alejado de los ojos.', '5.99 €', 'cinta_pelo.jpg'),
('Rodillera ajustable', 'Rodillera ortopédica con cierre de velcro para protección y estabilidad.', '18.90 €', 'rodillera.jpg'),
('Tobillera elástica', 'Soporte elástico para tobillo, ideal para prevenir lesiones.', '11.50 €', 'tobillera.jpg'),
('Balón medicinal', 'Balón de entrenamiento de 5 kg para ejercicios funcionales y de fuerza.', '44.00 €', 'balon_medicinal.jpg'),
('Chaleco con peso', 'Chaleco ajustable con 10 kg de peso distribuido uniformemente.', '69.95 €', 'chaleco_peso.jpg'),
('Esterilla de fitness', 'Superficie antideslizante y acolchada para ejercicios de suelo.', '19.50 €', 'esterilla_fitness.jpg'),
('Raqueta de pádel', 'Raqueta de fibra de carbono con gran control y potencia.', '129.00 €', 'raqueta_padel.jpg'),
('Pelotas de pádel', 'Pack de 3 pelotas presurizadas de alto rendimiento.', '6.90 €', 'pelotas_padel.jpg'),
('Gafas deportivas', 'Gafas con protección solar UV400, ligeras y resistentes a impactos.', '24.99 €', 'gafas_deportivas.jpg'),
('Banda de sudor', 'Muñequera absorbente para entrenamiento y competiciones.', '4.50 €', 'banda_sudor.jpg'),
('Cinta para correr', 'Cinta de correr plegable con velocidad regulable hasta 14 km/h.', '599.00 €', 'cinta_correr.jpg'),
('Pulsómetro', 'Reloj deportivo con sensor de frecuencia cardíaca y contador de pasos.', '79.00 €', 'pulsometro.jpg'),
('Saco de boxeo', 'Saco de entrenamiento de 40 kg con soporte y cadenas reforzadas.', '129.99 €', 'saco_boxeo.jpg'),
('Guantes de boxeo', 'Guantes acolchados de piel sintética con cierre de velcro.', '49.00 €', 'guantes_boxeo.jpg'),
('Tabla de surf', 'Tabla ligera de espuma rígida, ideal para surfistas principiantes.', '219.00 €', 'tabla_surf.jpg'),
('Palas de ping pong', 'Set de 2 palas con 3 pelotas, ideal para jugadores recreativos.', '17.50 €', 'palas_pingpong.jpg'),
('Bolsa de deporte', 'Bolsa de gran capacidad con compartimentos separados y correa ajustable.', '27.99 €', 'bolsa_deporte.jpg'),
('Protector solar deportivo', 'Crema resistente al agua, FPS 50, ideal para actividades al aire libre.', '14.99 €', 'protector_solar.jpg'),
('Gorra de natación', 'Gorra de silicona flexible que se adapta cómodamente a la cabeza.', '9.50 €', 'gorra_natacion.jpg');
```

### flask multipagina
<small>Creado: 2025-10-20 16:30</small>

#### Explicación

Este fragmento de código es el inicio básico de una aplicación web usando Flask, un micro framework para Python. Primero, importamos la clase `Flask` desde el módulo flask. Luego creamos una instancia de esta clase llamada `aplicacion`, que representará nuestra aplicación web.

El decorador `@aplicacion.route("/")` indica a Flask que cuando se acceda a la ruta base (URL) de nuestro sitio web, debe ejecutar la función `raiz()`. Esta función simplemente retorna el texto "Hola mundo", lo que significa que al visitar la página principal del sitio, verás este mensaje.

Finalmente, el bloque `if __name__ == "__main__":` asegura que nuestra aplicación solo se ejecute si el archivo es ejecutado directamente (no importado como un módulo). Dentro de este bloque, llamamos a `aplicacion.run()` para iniciar el servidor web de Flask y poder probar la aplicación en nuestro navegador.

`010-flask multipagina.py`

```python
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "Hola mundo"
  
if __name__ == "__main__":
  aplicacion.run()
```

### muchas rutas
<small>Creado: 2025-10-20 16:33</small>

#### Explicación

Este fragmento de código está desarrollando una aplicación web simple utilizando Flask, un framework en Python muy popular para crear sitios web. La aplicación crea varias páginas web básicas con diferentes rutas (URLs) que el usuario puede visitar.

Primero, se importa la clase `Flask` desde el módulo `flask`. Luego, se crea una instancia de esta clase llamada `aplicacion`, que es nuestra aplicación Flask en sí. Después, se define tres funciones: `raiz()`, `sobremi()` y `contacto()`. Cada función está asociada a una ruta específica utilizando el decorador `@aplicacion.route("/ruta")`.

- La función `raiz()` devuelve un mensaje para la página principal cuando el usuario visita la URL base (por ejemplo, `http://localhost:5000/`).
- La función `sobremi()` muestra información sobre alguien o algo cuando se accede a `/sobremi`.
- Finalmente, `contacto()` proporciona una página de contacto para interactuar con el sitio web cuando se navega hasta la ruta `/contacto`.

Al final del archivo, hay un bloque que asegura que la aplicación solo se ejecute si está siendo ejecutada directamente como un script principal y no importada desde otro módulo. Esto es importante para evitar que la aplicación Flask corra accidentalmente en entornos donde no se desea o no debería hacerlo.

`011-muchas rutas.py`

```python
from flask import Flask  

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return "Esta es la página principal"
  
@aplicacion.route("/sobremi")
def sobremi():
  return "Esta es la página sobre mi"
  
@aplicacion.route("/contacto")
def contacto():
  return "Esta es la página de contacto"

if __name__ == "__main__":
  aplicacion.run()
```

### pagina mas elaborada
<small>Creado: 2025-10-20 16:36</small>

#### Explicación

Este fragmento de código está utilizando una biblioteca llamada Flask para crear un pequeño servidor web en Python. La idea principal aquí es definir diferentes rutas (direcciones del navegador) que devuelven páginas web simples cuando alguien visita esas rutas.

El código comienza creando una aplicación Flask con el nombre `aplicacion`. Luego, define tres funciones (`raiz()`, `sobremi()` y `contacto()`) que se encargan de mostrar contenido diferente dependiendo de la ruta del navegador. Por ejemplo, si alguien visita la página principal (la URL raíz), verá una página con el título "La web de Jose Vicente" y el texto "Esta es la página principal". Si visitan `/sobremi`, verán algo similar pero con el texto "Esta es la página sobre mi", y así sucesivamente.

El contenido que se muestra en cada página está envuelto entre bloques HTML llamados `cabeza` y `pie`, lo cual asegura que todas las páginas tienen una estructura básica común, como un encabezado con el título del sitio web.

Finalmente, si el script es ejecutado directamente (no importado por otro archivo), la aplicación Flask se inicia en modo de desarrollo. Esto significa que podrás ver y probar tu servidor web localmente mientras estás desarrollando.

Este código es importante porque demuestra cómo crear una pequeña aplicación web con múltiples páginas utilizando Flask, lo cual es el primer paso para aprender a construir sitios web dinámicos más complejos.

`012-pagina mas elaborada.py`

```python
from flask import Flask  

aplicacion = Flask(__name__)

cabeza = '<!doctype html><html><head></head><body><header><h1>La web de Jose Vicente</h1></header><main>'
pie = '</main></body></html>'
@aplicacion.route("/")
def raiz():
  return cabeza+"Esta es la página principal"+pie
  
@aplicacion.route("/sobremi")
def sobremi():
  return cabeza+"Esta es la página sobre mi"+pie
  
@aplicacion.route("/contacto")
def contacto():
  return cabeza+"Esta es la página de contacto"+pie

if __name__ == "__main__":
  aplicacion.run()
```

### ahora con estilo y menu
<small>Creado: 2025-10-20 16:38</small>

#### Explicación

Este fragmento de código Python está utilizando el marco Flask para crear una aplicación web simple con tres páginas: "Inicio", "Sobre mi" y "Contacto". La parte más importante es que define la estructura básica de cada página, incluyendo un menú de navegación en la parte superior.

El código comienza importando `Flask` desde el módulo Flask. Luego, se crea una instancia de la aplicación llamada `aplicacion`. A continuación, se definen dos variables `cabeza` y `pie`, que contienen las partes HTML estáticas del encabezado (header) y del pie de página (footer), respectivamente, para todas las páginas. Esto ayuda a mantener una apariencia uniforme en toda la web.

Luego, el código define tres rutas usando decoradores `@aplicacion.route`:
- `/`: Cuando se accede a la raíz de la aplicación (`/`), se devuelve un mensaje que dice "Esta es la página principal" dentro del marco HTML definido por las variables `cabeza` y `pie`.
- `/sobremi`: Para la ruta "/sobremi", el texto devuelto cambia a "Esta es la página sobre mi".
- `/contacto`: Por último, para la ruta "/contacto" se devuelve un mensaje que dice "Esta es la página de contacto".

Finalmente, en la última parte del código, hay una comprobación `if __name__ == "__main__":` para asegurarse de que la aplicación solo se inicie si el archivo se está ejecutando directamente y no importado como un módulo. Esto es importante porque Flask necesita este punto de entrada para comenzar a escuchar los pedidos HTTP.

Este código es una introducción básica al desarrollo web con Python y Flask, mostrando cómo estructurar una aplicación simple que tenga múltiples páginas con enlaces interactivos entre ellas.

`013-ahora con estilo y menu.py`

```python
from flask import Flask  

aplicacion = Flask(__name__)

cabeza = '''
  <!doctype html>
  <html><head>
  </head><body>
  <header><h1>La web de Jose Vicente</h1>
  <nav>
    <a href="/">Inicio</a>
    <a href="/sobremi">Sobre mi</a>
    <a href="/contacto">Contacto</a>
  </nav>
  </header><main>'''
pie = '</main></body></html>'
@aplicacion.route("/")
def raiz():
  return cabeza+"Esta es la página principal"+pie
  
@aplicacion.route("/sobremi")
def sobremi():
  return cabeza+"Esta es la página sobre mi"+pie
  
@aplicacion.route("/contacto")
def contacto():
  return cabeza+"Esta es la página de contacto"+pie

if __name__ == "__main__":
  aplicacion.run()
```

### ahora con css
<small>Creado: 2025-10-20 16:39</small>

#### Explicación

Este código crea una sencilla aplicación web usando Flask, que es un framework para Python. La función principal aquí es definir diferentes páginas web basadas en las rutas (direcciones URL) proporcionadas por el usuario.

El archivo comienza importando `Flask` y creando una instancia de la aplicación llamada `aplicacion`. Luego, define tres bloques HTML: un bloque para la cabecera (`cabeza`) que incluye estilos CSS simples y estructura básica (como el título y menú), y otro bloque final (`pie`) que cierra las etiquetas HTML necesarias.

Las funciones `raiz()`, `sobremi()` y `contacto()` son rutas de la aplicación web. Cada una retorna la cabecera HTML, un mensaje específico para esa página (como "Esta es la página principal"), seguido del bloque final (`pie`). Esto significa que cuando se accede a diferentes URLs como "/", "/sobremi" o "/contacto", se muestra contenido diferente entre las etiquetas `<main>` y `</main>`, pero con una estructura HTML común.

Al final, el código verifica si está siendo ejecutado directamente (no importado como un módulo), y si es así, inicia la aplicación Flask. Esto permite que nuestra app web comience a funcionar en local y pueda ser vista desde un navegador web en localhost:5000 por defecto.

Este tipo de estructura ayuda a organizar el código y separa claramente las partes estáticas del HTML (como la cabecera) de los contenidos dinámicos que varían según la página.

`014-ahora con css.py`

```python
from flask import Flask  

aplicacion = Flask(__name__)

cabeza = '''
  <!doctype html>
  <html><head>
  <style>
    body,html{background:grey;font-family:sans-serif;}
    header,main,footer{background:white;padding:20px;margin:auto;width:600px;}
    nav a{text-decoration:none;color:inherit;}
  </style>
  </head><body>
  <header><h1>La web de Jose Vicente</h1>
  <nav>
    <a href="/">Inicio</a>
    <a href="/sobremi">Sobre mi</a>
    <a href="/contacto">Contacto</a>
  </nav>
  </header><main>'''
pie = '</main></body></html>'
@aplicacion.route("/")
def raiz():
  return cabeza+"Esta es la página principal"+pie
  
@aplicacion.route("/sobremi")
def sobremi():
  return cabeza+"Esta es la página sobre mi"+pie
  
@aplicacion.route("/contacto")
def contacto():
  return cabeza+"Esta es la página de contacto"+pie

if __name__ == "__main__":
  aplicacion.run()
```

### plantillas flask
<small>Creado: 2025-10-20 16:42</small>

#### Explicación

Este fragmento de código es una pequeña aplicación web creada con Flask, que es un framework ligero y muy popular para desarrollar sitios web en Python. En el código, primero importamos dos elementos importantes desde la biblioteca Flask: `Flask` para crear nuestra aplicación web y `render_template` para manejar las plantillas HTML.

Luego, creamos una instancia de la clase `Flask`, llamada `aplicacion`. Este objeto es el corazón de nuestra aplicación web. Dentro del código, definimos una ruta para la página principal usando el decorador `@aplicacion.route("/")`. Esto significa que cuando un usuario acceda a la URL base de nuestro sitio (por ejemplo, `http://localhost:5000/`), se ejecutará la función `raiz()`. En esta función, utilizamos `render_template("index.html")` para renderizar el archivo HTML llamado "index.html" que está en la carpeta de plantillas.

Finalmente, el bloque `if __name__ == "__main__":` asegura que nuestra aplicación solo se inicie si estamos ejecutando directamente este script (no como un módulo importado). Dentro de este bloque, llamamos a `aplicacion.run()`, lo cual lanza nuestro servidor web Flask en modo desarrollo.

Este código es importante porque establece la base para el desarrollo de aplicaciones más complejas usando Flask y plantillas HTML.

`015-plantillas flask.py`

```python
from flask import Flask, render_template 

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return render_template("index.html")
  
if __name__ == "__main__":
  aplicacion.run()
```

### varias paginas y varias plantillas
<small>Creado: 2025-10-20 16:46</small>

#### Explicación

Este fragmento de código es parte de una aplicación web básica creada con Flask, un framework ligero para Python que facilita el desarrollo de sitios web. La función principal del código es definir rutas (URLs) y asociarlas a plantillas HTML específicas.

En primer lugar, importamos las funciones necesarias desde la biblioteca `Flask`. Creamos una instancia de la clase `Flask` llamada `aplicacion`, que representa nuestra aplicación web. Luego, utilizamos decoradores `@aplicacion.route()` para asignar diferentes URLs a distintas funciones: `raiz()`, `sobremi()`, y `contacto()`. Cada una de estas funciones utiliza la función `render_template()` para renderizar un archivo HTML correspondiente (como "index.html", "sobremi.html" o "contacto.html").

Finalmente, el bloque `if __name__ == "__main__":` asegura que la aplicación solo se ejecute si el script es ejecutado directamente y no importado como módulo en otro lugar. La línea `aplicacion.run()` inicia el servidor web de Flask para permitirnos probar nuestra aplicación.

Este código es importante porque demuestra cómo estructurar una aplicación web con múltiples páginas utilizando rutas y plantillas separadas, lo que facilita la organización y mantenimiento del proyecto.

`016-varias paginas y varias plantillas.py`

```python
from flask import Flask, render_template 

aplicacion = Flask(__name__)

@aplicacion.route("/")
def raiz():
  return render_template("index.html")
  
@aplicacion.route("/sobremi")
def sobremi():
  return render_template("sobremi.html")
  
@aplicacion.route("/contacto")
def contacto():
  return render_template("contacto.html")
  
if __name__ == "__main__":
  aplicacion.run()
```

### blog
<small>Creado: 2025-10-20 15:55</small>

#### Explicación

Parece que el código que debes explicar está vacío o no ha sido proporcionado en la solicitud. Si tienes un fragmento de código específico sobre el que quieras obtener información, por favor compártelo y estaré encantado de ayudarte a entenderlo.

`blog.db`

```

```

### Actividades propuestas

It looks like you have several Python Flask applications and SQL scripts to manage data in a SQLite database. Let's break down each step:

1. **Setting up the Flask application with basic routing**:
   - In `015-plantillas flask.py`, you start using Jinja2 templates for rendering HTML.
   - You create an `index.html` file that will be rendered when visiting the root URL (`/`).

2. **Using multiple pages and templates**:
   - In `016-varias paginas y varias plantillas.py`, you have defined routing for different URLs, each pointing to a separate HTML template.
   
3. **Working with a SQLite database using Flask**:
   - You have created an SQL file (`blog.db`) where data is stored in a SQLite database.
   - In `009-20 productos mas.sql` and `010-flask multipagina.py`, you're inserting additional products into the database.

Let's go through some key steps to set up your Flask application properly:

### Step-by-Step Guide

#### 1. Create Your Project Structure
Ensure that your project directory looks something like this:
```
my_flask_app/
│
├── app.py            # Main Flask application file
└── templates/        # Directory for HTML templates
    ├── index.html    
    ├── sobremi.html  
    └── contacto.html 
```

#### 2. Create the Database (SQL Script)
You've already created `009-20 productos mas.sql` and added additional product data. Now, you should run this SQL script to update your database.

Run the following commands:
```sh
sqlite3 blog.db < 009-20_productos_mas.sql
```

#### 3. Set Up Flask Application

##### `app.py`
This is where you define routes and render templates using Jinja2.

```python
from flask import Flask, render_template, g
import sqlite3

app = Flask(__name__)

# Database connection setup
DATABASE = 'blog.db'

def get_db():
    db = getattr(g, '_database', None)
    if db is None:
        db = g._database = sqlite3.connect(DATABASE)
    return db

@app.teardown_appcontext
def close_connection(exception):
    db = getattr(g, '_database', None)
    if db is not None:
        db.close()

# Route for the main page
@app.route("/")
def raiz():
    cursor = get_db().execute("SELECT * FROM productos LIMIT 20")
    productos = cursor.fetchall()
    return render_template("index.html", productos=productos)

# Route for "About Me" page
@app.route("/sobremi")
def sobremi():
    return render_template("sobremi.html")

# Route for contact page
@app.route("/contacto")
def contacto():
    return render_template("contacto.html")

if __name__ == "__main__":
    app.run(debug=True)
```

##### `templates/index.html`
In this template, you can loop through the products fetched from your database and display them.

```html
<!doctype html>
<html>
<head>
  <title>My Flask App</title>
</head>
<body>
<header>
  <h1>Welcome to My Flask App!</h1>
  <nav>
    <a href="/">Home</a>
    <a href="/sobremi">About Me</a>
    <a href="/contacto">Contact Us</a>
  </nav>
</header>

<main>
<h2>Featured Products:</h2>
<ul>
{% for producto in productos %}
<li>{{ producto['nombre'] }} - {{ producto['precio'] }}</li>
{% endfor %}
</ul>
</main>

<footer>&copy; 2023 My Flask App</footer>
</body>
</html>
```

##### `templates/sobremi.html`
A simple "About Me" page.

```html
<!doctype html>
<html>
<head>
  <title>About Me - My Flask App</title>
</head>
<body>
<header>
  <h1>Welcome to My Flask App!</h1>
  <nav>
    <a href="/">Home</a>
    <a href="/sobremi">About Me</a>
    <a href="/contacto">Contact Us</a>
  </nav>
</header>

<main>
<h2>About Me:</h2>
<p>This is a simple about me page.</p>
</main>

<footer>&copy; 2023 My Flask App</footer>
</body>
</html>
```

##### `templates/contacto.html`
A basic contact page.

```html
<!doctype html>
<html>
<head>
  <title>Contact Us - My Flask App</title>
</head>
<body>
<header>
  <h1>Welcome to My Flask App!</h1>
  <nav>
    <a href="/">Home</a>
    <a href="/sobremi">About Me</a>
    <a href="/contacto">Contact Us</a>
  </nav>
</header>

<main>
<h2>Contact Us:</h2>
<p>If you have any questions, feel free to contact us!</p>
</main>

<footer>&copy; 2023 My Flask App</footer>
</body>
</html>
```

### Running Your Application
1. Make sure you have Python and Flask installed.
   ```sh
   pip install flask sqlite3
   ```
2. Run your application using:
   ```sh
   python app.py
   ```

Your project should now be set up with multiple pages, a database connection to fetch product data, and Jinja2 templates rendering HTML dynamically based on the routes defined in `app.py`.


<a id="simulacro-parte-1"></a>
## Simulacro parte 1

### Introducción a los ejercicios

Para que tu servidor Flask escuche en todas las interfaces de red disponibles, puedes usar `host='0.0.0.0'`. Esto hace que el servidor sea accesible desde cualquier dirección IP del sistema, lo cual es útil tanto para desarrollo como para pruebas en entornos donde necesitas acceder al servidor a través de diferentes direcciones IP.

Aquí está tu código modificado para escuchar en todas las interfaces:

```python
"""
Proyecto: Tienda Online de Tecnología
Autor: José Vicente Carratalá Sanchis
Fecha: 2025
Versión: 1.0
Framework: Flask
Base de datos: SQLite

Descripción general:
--------------------
Este proyecto implementa una tienda online básica de productos tecnológicos utilizando
el framework Flask (Python) y una base de datos SQLite. La aplicación web muestra un
listado dinámico de productos obtenidos directamente desde la base de datos y genera
una página HTML con diseño responsivo para simular el frontend de una tienda real.

Características principales:
----------------------------
- Conexión automática a la base de datos SQLite 'tiendaonline.db'.
- Obtención de los registros almacenados en la tabla 'productos'.
- Renderizado dinámico de cada producto con su nombre, descripción, imagen y precio.
- Estructura HTML con estilo CSS embebido para ofrecer una experiencia visual moderna.
- Diseño adaptable con cabecera, menú de navegación, listado de productos y pie de página.
- Interfaz sencilla con botones de "Añadir al carrito" (sin funcionalidad aún implementada).

Estructura esperada de la tabla 'productos':
--------------------------------------------
| id (INTEGER PRIMARY KEY) | nombre (TEXT)   | descripcion (TEXT)  | imagen (TEXT)       | precio (REAL) |

Ejemplo de registro:
--------------------
(1, 'Portátil Lenovo IdeaPad', 'Portátil con procesador Ryzen 5 y 16GB RAM', 'lenovo.jpg', 799.99)

Rutas disponibles:
------------------
/        → Página principal con el listado de productos.

Modo de uso:
------------
1. Asegúrate de tener instalado Flask y SQLite3 en tu entorno de Python.
2. Crea la base de datos 'tiendaonline.db' con una tabla 'productos' y algunos registros.
3. Guarda este archivo como 'app.py' o 'tienda.py'.
4. Ejecuta el servidor con:
       python app.py
5. Abre tu navegador en http://127.0.0.1:5000/ para ver la tienda online.

Notas:
------
- Este proyecto sirve como ejemplo didáctico de integración entre Flask y SQLite.
- El carrito de compras y la gestión de usuarios pueden añadirse en versiones posteriores.
"""

import sqlite3                                  # Importamos el módulo sqlite3 para manejar la base de datos SQLite
from flask import Flask                         # Importamos Flask para crear la aplicación web

app = Flask(__name__)                           # Creamos una instancia de la aplicación Flask

@app.route('/')                                 # Definimos la ruta principal de la aplicación
def listar_productos():                         # Función para listar los productos de la tienda online

    basededatos = sqlite3.connect('./tiendaonline.db')  # Conectamos a la base de datos SQLite llamada 'tiendaonline.db'
    cursor = basededatos.cursor()               # Creamos un cursor para ejecutar consultas SQL
    cadena = '''
    <!-- Maqueta visual del front de una tienda online -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tienda Online de Tecnología</title>
   <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        nav ul {
            list-style: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
        }
        .product-list {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            padding: 20px;
        }
        .product-item {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 15px;
            padding: 15px;
            width: 250px;
            text-align: center;
        }
        .product-item img {
            max-width: 100%;
            height: auto;
        }
        .product-item h2 {
            font-size: 1.2em;
            margin: 10px 0;
        }
        .product-item p {
            font-size: 0.9em;
            color: #555;
        }
        .price {
            font-size: 1.1em;
            color: #e91e63;
            margin: 10px 0;
            display: block;
        }
        button {
            background-color: #28a745;
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: #218838;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            width: 100%;
            bottom: 0;
        }   
   </style>
</head>
<body>
    <header>
        <h1>Tienda Online de Tecnología</h1>
        <nav>
            <ul>
                <li><a href="#">Inicio</a></li>
                <li><a href="#">Productos</a></li>
                <li><a href="#">Ofertas</a></li>
                <li><a href="#">Contacto</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section class="product-list">
    '''                                             # cadena inicial del HTML de la página web

    # ahora listado de productos ########################################

    cursor.execute("SELECT * FROM productos")
    productos = cursor.fetchall()

    for producto in productos:
        cadena += '''
        <div class="product-item">
            <img src="/static/img/''' + producto[3] + '''" alt="''' + producto[1] + '''">
            <h2>''' + producto[1] + '''</h2>
            <p>''' + producto[2] + '''</p>
            <span class="price">$''' + str(producto[4]) + '''</span>
            <button>Añadir al carrito</button>
        </div>
        '''
    # ahora listado de productos ########################################

    cadena += '''
 </section>
    </main>
    <footer>
        <p>&copy; 2024 Tienda Online de Tecnología. Todos los derechos reservados.</p>
    </footer>
</body>
</html>
    '''                                                         # cadena final del HTML de la página web

    basededatos.close()                                         # Cerramos la conexión a la base de datos
    return cadena                                               # Devolvemos la cadena HTML completa como respuesta a la solicitud web


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)  # Ejecutamos la aplicación Flask en modo de depuración
```

Al usar `host='0.0.0.0'`, el servidor escuchará en todas las interfaces de red disponibles y será accesible desde cualquier dirección IP del sistema local.

Para probarlo, simplemente ejecuta el script con:

```bash
python app.py
```

Y podrás acceder a la aplicación a través de `http://127.0.0.1:5000/` o desde otro dispositivo en la misma red utilizando la dirección IP del servidor.

¡Espero que esto sea lo que necesitas!

### creacion de tabla
<small>Creado: 2025-10-27 16:02</small>

#### Explicación

Este fragmento de código SQL crea una tabla llamada "productos" en una base de datos. La tabla tiene cinco columnas: "Identificador", "nombre", "descripcion", "imagen" y "precio". Cada columna almacena un tipo diferente de información:

1. **Identificador**: Es un número entero (INTEGER) que funciona como la clave primaria de la tabla. Al ser la clave primaria, se asegura de que cada fila en la tabla tenga un identificador único e incrementa automáticamente con cada nuevo producto añadido.

2. **nombre**, **descripcion**, y **imagen**: Estas columnas almacenan información textual (TEXT) sobre el nombre del producto, su descripción y la ubicación o ruta de la imagen asociada a ese producto respectivamente.

3. **precio**: Esta columna también almacena texto, lo que significa que los precios pueden ser almacenados como cadenas para permitir fácil manipulación con otras cadenas si es necesario (por ejemplo, concatenar descripciones y precios en una misma cadena).

Esta tabla es importante porque permite organizar y gestionar información sobre productos de manera estructurada y eficiente, lo cual es fundamental para cualquier sistema que necesite almacenar y recuperar datos de productos, como un catálogo en línea o un sistema de inventario.

`001-creacion de tabla.sql`

```sql
CREATE TABLE "productos" (
	"Identificador"	INTEGER,
	"nombre"	TEXT,
	"descripcion"	TEXT,
	"imagen"	TEXT,
	"precio"	TEXT,
	PRIMARY KEY("Identificador" AUTOINCREMENT)
);
```

### insercion de 20 productos
<small>Creado: 2025-10-27 16:11</small>

#### Explicación

Este código SQL está insertando 20 registros en la tabla "productos". Cada registro representa un producto tecnológico ficticio con detalles como el nombre, descripción, imagen y precio. La estructura del comando `INSERT INTO` indica que estamos añadiendo información a una base de datos existente.

Para cada uno de los productos listados, se especifican cuatro columnas: 'nombre', 'descripcion', 'imagen' y 'precio'. Los valores correspondientes para estas columnas son proporcionados en orden. Por ejemplo, el primer producto es "HoloDesk X1", que es un escritorio holográfico con una descripción detallada, una imagen específica (como se indica por el nombre del archivo), y un precio de 1999.99 euros.

Esta operación es importante porque permite cargar datos iniciales en la base de datos para simular un catálogo de productos en una tienda virtual o sistema de gestión de inventario. El uso de imágenes específicas también sugiere que esta base de datos podría ser parte de un sitio web donde los usuarios pueden ver y comprar estos productos visualmente.

`002-insercion de 20 productos.sql`

```sql
INSERT INTO productos (nombre, descripcion, imagen, precio) VALUES
('HoloDesk X1', 'Escritorio holográfico que proyecta pantallas 3D flotantes con control gestual.', 'tech_product_512x512_03_7865796.png', '1999.99'),
('NeuraLinkPad', 'Tableta neuronal que responde a pensamientos simples para tomar notas o dibujar.', 'tech_product_512x512_04_1311171.png', '899.00'),
('QuantumDrive Z', 'Unidad de almacenamiento cuántica con capacidad infinita y transferencia instantánea.', 'tech_product_512x512_05_7864734.png', '4999.00'),
('AeroMouse Pro', 'Ratón flotante que levita sobre la mesa y se controla con microgestos.', 'tech_product_512x512_06_3788182.png', '299.00'),
('PhotonKey', 'Llave universal de acceso digital basada en fotones encriptados.', 'tech_product_512x512_07_3169377.png', '149.00'),
('BioScreen Alpha', 'Pantalla flexible y autorreparable fabricada con polímeros biológicos.', 'tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg', '1199.00'),
('NanoDrone Scout', 'Dron del tamaño de un insecto con cámara térmica y seguimiento automático.', 'tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg', '699.00'),
('EchoBand V', 'Pulsera que traduce en tiempo real cualquier idioma mediante vibraciones hápticas.', 'tech_product_512x512_10_tech-gadget-collection-stockcake.jpg', '349.00'),
('MindCast S2', 'Auriculares de transmisión mental que convierten tus pensamientos en audio digital.', 'tech_product_512x512_07_3169377.png', '899.00'),
('ThermoCube', 'Miniordenador refrigerado por levitación magnética y flujo térmico invertido.', 'tech_product_512x512_06_3788182.png', '1499.00'),
('CloudPet 3000', 'Mascota virtual proyectada en el aire con inteligencia emocional avanzada.', 'tech_product_512x512_04_1311171.png', '259.00'),
('SolarInk Pen', 'Bolígrafo que recarga su tinta con luz solar y convierte escritura en texto digital.', 'solarinkpen.jpg', '89.00'),
('HaptSuit XR', 'Traje háptico completo con retroalimentación térmica y presión localizada.', 'tech_product_512x512_03_7865796.png', '3499.00'),
('OxyPod Air', 'Purificador portátil que genera oxígeno inteligente ajustado a tu ritmo respiratorio.', 'tech_product_512x512_06_3788182.png', '179.00'),
('NeuroLens X', 'Gafas de realidad aumentada conectadas al sistema nervioso óptico.', 'tech_product_512x512_06_3788182.png', '1299.00'),
('QuantumRouter Q9', 'Router de comunicación cuántica con latencia cero y cifrado absoluto.', 'tech_product_512x512_10_tech-gadget-collection-stockcake.jpg', '2499.00'),
('TimeSync Watch', 'Reloj inteligente sincronizado con relojes atómicos globales al nanosegundo.', 'tech_product_512x512_06_3788182.png', '399.00'),
('PulseBook Neo', 'Libro electrónico con páginas físicas reescribibles mediante tinta electromagnética.', 'tech_product_512x512_10_tech-gadget-collection-stockcake.jpg', '229.00'),
('VibeCube Mini', 'Altavoz portátil que adapta su sonido al entorno mediante IA contextual.', 'tech_product_512x512_03_7865796.png', '159.00'),
('DroneShield X', 'Campo de defensa personal que neutraliza drones invasores con pulsos electromagnéticos.', 'tech_product_512x512_06_3788182.png', '799.00');
```

### controlar de leer
<small>Creado: 2025-10-27 16:13</small>

#### Explicación

Este fragmento de código es una parte de un programa en Python que interactúa con una base de datos SQLite para listar todos los productos registrados. La base de datos se conecta a un archivo llamado `tiendaonline.db` y utiliza el módulo `sqlite3` proporcionado por Python.

El código comienza abriendo la conexión a la base de datos y creando un objeto cursor, que es lo que se va a usar para ejecutar las consultas SQL. Luego, se realiza una consulta SQL simple que selecciona todos los registros de la tabla llamada `productos`. Los resultados obtenidos por esta consulta se almacenan en la variable `productos`.

Finalmente, el código itera sobre cada fila del conjunto de resultados y utiliza la función `print` para mostrar información sobre cada producto, incluyendo su ID, nombre, descripción, imagen (que probablemente es una URL o un nombre de archivo), y precio. Cada línea impresa representa los detalles completos de un único producto en formato legible por humanos.

Después de imprimir todos los registros, el programa cierra la conexión a la base de datos para asegurar que no se pierdan cambios ni recursos. Este código es importante porque ayuda a visualizar y verificar fácilmente el contenido de una tabla de productos en una base de datos, lo cual puede ser útil tanto durante el desarrollo como para depuración o mantenimiento.

`003-controlar de leer.py`

```python
import sqlite3

basededatos = sqlite3.connect('./tiendaonline.db')
cursor = basededatos.cursor()

# ahora listado de productos

cursor.execute("SELECT * FROM productos")
productos = cursor.fetchall()

for producto in productos:
    print(f"ID: {producto[0]}, Nombre: {producto[1]}, Descripción: {producto[2]}, Imagen: {producto[3]}, Precio: {producto[4]}")    


basededatos.close()
```

### maqueta visual de tienda online
<small>Creado: 2025-10-27 16:16</small>

#### Explicación

Este código HTML crea la estructura básica para el diseño visual de una página web que simula una tienda online de tecnología. En la parte superior, se encuentra un bloque `header` que incluye el título de la tienda y un menú de navegación (`nav`) con cuatro opciones: Inicio, Productos, Ofertas y Contacto.

En la sección principal del sitio web (`main`), hay una lista de productos (`section product-list`) con dos artículos (`article product-item`). Cada artículo incluye una imagen del producto, su nombre (`h2`), una breve descripción (`p`), el precio del producto (`span price`) y un botón para añadirlo al carrito.

Por último, en la parte inferior de la página se encuentra el `footer`, que contiene información sobre los derechos autorales del sitio web. Este diseño básico es importante porque proporciona a los visitantes una estructura clara y fácil de usar, permitiéndoles navegar por las diferentes secciones del sitio para explorar productos y servicios ofrecidos por la tienda online.

`004-maqueta visual de tienda online.html`

```html
<!-- Maqueta visual del front de una tienda online -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tienda Online de Tecnología</title>
   <style>


   </style>
</head>
<body>
    <header>
        <h1>Tienda Online de Tecnología</h1>
        <nav>
            <ul>
                <li><a href="#">Inicio</a></li>
                <li><a href="#">Productos</a></li>
                <li><a href="#">Ofertas</a></li>
                <li><a href="#">Contacto</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section class="product-list">
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
        </section>
    </main>
    <footer>
        <p>&copy; 2024 Tienda Online de Tecnología. Todos los derechos reservados.</p>
    </footer>
</body>
</html>
```

### estilo de la tienda
<small>Creado: 2025-10-27 16:17</small>

#### Explicación

Este código HTML es la estructura y diseño básico de una página web que representa el frontend (la parte visible del usuario) de una tienda online especializada en tecnología. La página incluye varias secciones clave:

1. **Encabezado (`header`)**: Muestra el nombre de la tienda "Tienda Online de Tecnología" en un título grande y tiene un menú de navegación que contiene enlaces a páginas como Inicio, Productos, Ofertas y Contacto.

2. **Estilo personalizado**: Dentro del bloque `<style>`, se definen las reglas CSS para controlar la apariencia general del sitio, incluyendo el color de fondo (`background-color`), los estilos de los enlaces en el menú (`nav ul li a`), y cómo deben verse los productos listados (`product-item`).

3. **Sección principal (`main`)**: Contiene una sección llamada "product-list" que muestra varios artículos de producto, cada uno con su imagen, título del producto, descripción, precio y un botón para añadir el producto al carrito.

4. **Pie de página (`footer`)**: Proporciona información sobre los derechos de autor y la marca.

El código es importante porque proporciona una estructura clara y estética para presentar productos en línea a los clientes potenciales, lo que puede aumentar su interés y mejorar las ventas. Además, el uso del CSS dentro de la etiqueta `<style>` permite un control preciso sobre cómo se visualiza cada parte de la página, asegurando una experiencia de usuario coherente e intuitiva.

`005-estilo de la tienda.html`

```html
<!-- Maqueta visual del front de una tienda online -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tienda Online de Tecnología</title>
   <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        nav ul {
            list-style: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
        }
        .product-list {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            padding: 20px;
        }
        .product-item {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 15px;
            padding: 15px;
            width: 250px;
            text-align: center;
        }
        .product-item img {
            max-width: 100%;
            height: auto;
        }
        .product-item h2 {
            font-size: 1.2em;
            margin: 10px 0;
        }
        .product-item p {
            font-size: 0.9em;
            color: #555;
        }
        .price {
            font-size: 1.1em;
            color: #e91e63;
            margin: 10px 0;
            display: block;
        }
        button {
            background-color: #28a745;
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: #218838;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            width: 100%;
            bottom: 0;
        }   
   </style>
</head>
<body>
    <header>
        <h1>Tienda Online de Tecnología</h1>
        <nav>
            <ul>
                <li><a href="#">Inicio</a></li>
                <li><a href="#">Productos</a></li>
                <li><a href="#">Ofertas</a></li>
                <li><a href="#">Contacto</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section class="product-list">
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_08_tech-gadget-assortment-stockcake.jpg" alt="BioScreen Alpha">
                <h2>BioScreen Alpha</h2>
                <p>Pantalla flexible y autorreparable fabricada con polímeros           biológicos.</p>
                <span class="price">1199.00 €</span>
                <button>Añadir al carrito</button>
            </article>
            <article class="product-item">
                <img src="tech_product_512x512_09_marketing-innovation-technology-service-technological-innovation-product-innovation-quality-organization-png-clipart.jpg" alt="NanoDrone Scout">
                <h2>NanoDrone Scout</h2>
                <p>Dron del tamaño de un insecto con cámara térmica y seguimiento automático.</p>
                <span class="price">699.00 €</span>
                <button>Añadir al carrito</button>
            </article>
        </section>
    </main>
    <footer>
        <p>&copy; 2024 Tienda Online de Tecnología. Todos los derechos reservados.</p>
    </footer>
</body>
</html>
```

### generar web
<small>Creado: 2025-10-27 16:23</small>

#### Explicación

Este fragmento de código es una combinación de Python y HTML que se utiliza para crear una página web dinámica que lista los productos desde una base de datos SQLite. La función principal del código es iniciar un servidor web sencillo con Flask, leer información sobre productos desde la base de datos 'tiendaonline.db', y generar automáticamente el contenido HTML necesario para mostrar estos productos en una página web.

El archivo comienza importando las bibliotecas necesarias: `sqlite3` para interactuar con la base de datos y `Flask` para crear la aplicación web. Luego, se define la ruta principal del servidor (`/`) que llama a la función `listar_productos()`. Dentro de esta función:

1. Se conecta a una base de datos SQLite llamada 'tiendaonline.db'.
2. Ejecuta una consulta SQL simple para obtener todos los registros de una tabla llamada 'productos'. Esta tabla probablemente contiene información sobre productos, como nombre, descripción, imagen y precio.
3. Utiliza un bucle `for` para iterar a través de los resultados obtenidos (los productos) y generar HTML dinámico que muestra cada producto en formato de tarjeta. Cada tarjeta incluye detalles del producto como el nombre, la imagen, la descripción y el precio.

Finalmente, el código cierra la conexión con la base de datos y devuelve toda la cadena de HTML generada al navegador web para que se pueda visualizar correctamente.

Este tipo de implementación es importante porque permite a los desarrolladores crear sitios web interactivos y dinámicos sin tener que escribir manualmente cada página. En lugar de eso, las páginas se crean en tiempo real utilizando datos de una base de datos, lo cual facilita la actualización y mantenimiento del sitio web.

`006-generar web.py`

```python
import sqlite3
from flask import Flask
app = Flask(__name__)

@app.route('/')
def listar_productos(): 

    basededatos = sqlite3.connect('./tiendaonline.db')
    cursor = basededatos.cursor()
    cadena = '''
    <!-- Maqueta visual del front de una tienda online -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tienda Online de Tecnología</title>
   <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        nav ul {
            list-style: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
        }
        .product-list {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            padding: 20px;
        }
        .product-item {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 15px;
            padding: 15px;
            width: 250px;
            text-align: center;
        }
        .product-item img {
            max-width: 100%;
            height: auto;
        }
        .product-item h2 {
            font-size: 1.2em;
            margin: 10px 0;
        }
        .product-item p {
            font-size: 0.9em;
            color: #555;
        }
        .price {
            font-size: 1.1em;
            color: #e91e63;
            margin: 10px 0;
            display: block;
        }
        button {
            background-color: #28a745;
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: #218838;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            width: 100%;
            bottom: 0;
        }   
   </style>
</head>
<body>
    <header>
        <h1>Tienda Online de Tecnología</h1>
        <nav>
            <ul>
                <li><a href="#">Inicio</a></li>
                <li><a href="#">Productos</a></li>
                <li><a href="#">Ofertas</a></li>
                <li><a href="#">Contacto</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section class="product-list">
    '''
    # ahora listado de productos

    cursor.execute("SELECT * FROM productos")
    productos = cursor.fetchall()

    for producto in productos:
        cadena += '''
        <div class="product-item">
            <img src="/static/''' + producto[3] + '''" alt="''' + producto[1] + '''">
            <h2>''' + producto[1] + '''</h2>
            <p>''' + producto[2] + '''</p>
            <span class="price">$''' + str(producto[4]) + '''</span>
            <button>Añadir al carrito</button>
        </div>
        '''

    cadena += '''
 </section>
    </main>
    <footer>
        <p>&copy; 2024 Tienda Online de Tecnología. Todos los derechos reservados.</p>
    </footer>
</body>
</html>
    '''

    return cadena
    basededatos.close()

if __name__ == '__main__':
    app.run(debug=True)
```

### revisamos url de las iagenes
<small>Creado: 2025-10-27 16:24</small>

#### Explicación

Este fragmento de código es una aplicación web simple escrita en Python utilizando el framework Flask. La función principal de este código es listar los productos disponibles en una tienda online y mostrarlos en un formato HTML visualmente atractivo.

El programa comienza importando la librería `sqlite3` para conectarse a una base de datos SQLite llamada `tiendaonline.db`, que contiene información sobre los productos. Luego, crea una instancia del servidor web Flask (`app`) y define una ruta raíz ('/') que se activa cuando un usuario visita el sitio en su navegador.

Cuando esta función es accedida, la aplicación conecta a la base de datos y selecciona todos los registros desde la tabla `productos`. Cada producto tiene información como nombre, descripción, imagen URL y precio. La cadena HTML que genera el código incluye una estructura básica para un sitio web, con estilos CSS incorporados directamente en el `<head>`.

La parte más importante es cómo se generan las tarjetas de productos dinámicamente usando un bucle `for`. Para cada producto obtenido de la base de datos, el código añade al HTML una nueva tarjeta que muestra la imagen del producto (enlace a imágenes estáticas), el nombre y descripción del producto, su precio, y un botón para agregar el producto al carrito.

Finalmente, después de cerrar todas las secciones HTML necesarias, la función retorna toda esta cadena como respuesta web. Esto significa que cuando un usuario accede al sitio web, verá una página con todos los productos listados en tarjetas individuales, cada una con sus propios detalles y estilos.

Esta implementación es útil porque combina bases de datos, lenguajes de programación y HTML/CSS para crear una interfaz interactiva que puede ser fácilmente mantenida y actualizada a medida que la tienda añade nuevos productos o cambia las imágenes.

`007-revisamos url de las iagenes.py`

```python
import sqlite3
from flask import Flask
app = Flask(__name__)

@app.route('/')
def listar_productos(): 

    basededatos = sqlite3.connect('./tiendaonline.db')
    cursor = basededatos.cursor()
    cadena = '''
    <!-- Maqueta visual del front de una tienda online -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tienda Online de Tecnología</title>
   <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        nav ul {
            list-style: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
        }
        .product-list {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            padding: 20px;
        }
        .product-item {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 15px;
            padding: 15px;
            width: 250px;
            text-align: center;
        }
        .product-item img {
            max-width: 100%;
            height: auto;
        }
        .product-item h2 {
            font-size: 1.2em;
            margin: 10px 0;
        }
        .product-item p {
            font-size: 0.9em;
            color: #555;
        }
        .price {
            font-size: 1.1em;
            color: #e91e63;
            margin: 10px 0;
            display: block;
        }
        button {
            background-color: #28a745;
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: #218838;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            width: 100%;
            bottom: 0;
        }   
   </style>
</head>
<body>
    <header>
        <h1>Tienda Online de Tecnología</h1>
        <nav>
            <ul>
                <li><a href="#">Inicio</a></li>
                <li><a href="#">Productos</a></li>
                <li><a href="#">Ofertas</a></li>
                <li><a href="#">Contacto</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section class="product-list">
    '''
    # ahora listado de productos

    cursor.execute("SELECT * FROM productos")
    productos = cursor.fetchall()

    for producto in productos:
        cadena += '''
        <div class="product-item">
            <img src="/static/img/''' + producto[3] + '''" alt="''' + producto[1] + '''">
            <h2>''' + producto[1] + '''</h2>
            <p>''' + producto[2] + '''</p>
            <span class="price">$''' + str(producto[4]) + '''</span>
            <button>Añadir al carrito</button>
        </div>
        '''

    cadena += '''
 </section>
    </main>
    <footer>
        <p>&copy; 2024 Tienda Online de Tecnología. Todos los derechos reservados.</p>
    </footer>
</body>
</html>
    '''

    return cadena
    basededatos.close()

if __name__ == '__main__':
    app.run(debug=True)
```

### comentarios en el software
<small>Creado: 2025-10-27 16:28</small>

#### Explicación

Este código Python implementa una pequeña tienda online básica utilizando el framework Flask y una base de datos SQLite. La aplicación web muestra un listado dinámico de productos tecnológicos, donde cada producto se obtiene desde una tabla llamada 'productos' en la base de datos 'tiendaonline.db'. El código genera HTML dinámicamente para representar cada producto con su nombre, descripción, imagen y precio.

Lo primero que hace el script es importar las bibliotecas necesarias: sqlite3 para gestionar la base de datos y Flask para crear la aplicación web. Luego, establece una ruta principal ("/") donde se ejecuta una función llamada `listar_productos()`. Esta función conecta a la base de datos SQLite, obtiene los registros desde la tabla 'productos', y genera HTML dinámico que muestra cada producto en una estructura de página web con estilos CSS embebidos.

Importante es que el código se asegura de cerrar la conexión a la base de datos después de obtener los datos. Finalmente, si el archivo se ejecuta directamente (y no importado), inicia el servidor Flask en modo de depuración para permitir el desarrollo y pruebas fácilmente accesibles.

Esta implementación es un ejemplo práctico de cómo integrar una aplicación web básica con una base de datos SQLite utilizando Flask, lo que es muy útil para estudiantes que están aprendiendo a desarrollar aplicaciones web interactivas.

`008-comentarios en el software.py`

```python
"""
Proyecto: Tienda Online de Tecnología
Autor: José Vicente Carratalá Sanchis
Fecha: 2025
Versión: 1.0
Framework: Flask
Base de datos: SQLite

Descripción general:
--------------------
Este proyecto implementa una tienda online básica de productos tecnológicos utilizando
el framework Flask (Python) y una base de datos SQLite. La aplicación web muestra un
listado dinámico de productos obtenidos directamente desde la base de datos y genera
una página HTML con diseño responsivo para simular el frontend de una tienda real.

Características principales:
----------------------------
- Conexión automática a la base de datos SQLite 'tiendaonline.db'.
- Obtención de los registros almacenados en la tabla 'productos'.
- Renderizado dinámico de cada producto con su nombre, descripción, imagen y precio.
- Estructura HTML con estilo CSS embebido para ofrecer una experiencia visual moderna.
- Diseño adaptable con cabecera, menú de navegación, listado de productos y pie de página.
- Interfaz sencilla con botones de "Añadir al carrito" (sin funcionalidad aún implementada).

Estructura esperada de la tabla 'productos':
--------------------------------------------
| id (INTEGER PRIMARY KEY) | nombre (TEXT) | descripcion (TEXT) | imagen (TEXT) | precio (REAL) |

Ejemplo de registro:
--------------------
(1, 'Portátil Lenovo IdeaPad', 'Portátil con procesador Ryzen 5 y 16GB RAM', 'lenovo.jpg', 799.99)

Rutas disponibles:
------------------
/        → Página principal con el listado de productos.

Modo de uso:
------------
1. Asegúrate de tener instalado Flask y SQLite3 en tu entorno de Python.
2. Crea la base de datos 'tiendaonline.db' con una tabla 'productos' y algunos registros.
3. Guarda este archivo como 'app.py' o 'tienda.py'.
4. Ejecuta el servidor con:
       python app.py
5. Abre tu navegador en http://127.0.0.1:5000/ para ver la tienda online.

Notas:
------
- Este proyecto sirve como ejemplo didáctico de integración entre Flask y SQLite.
- El carrito de compras y la gestión de usuarios pueden añadirse en versiones posteriores.
"""

import sqlite3                                  # Importamos el módulo sqlite3 para manejar la base de datos SQLite
from flask import Flask                         # Importamos Flask para crear la aplicación web
app = Flask(__name__)                           # Creamos una instancia de la aplicación Flask

@app.route('/')                                 # Definimos la ruta principal de la aplicación
def listar_productos():                         # Función para listar los productos de la tienda online

    basededatos = sqlite3.connect('./tiendaonline.db')  # Conectamos a la base de datos SQLite llamada 'tiendaonline.db'
    cursor = basededatos.cursor()               # Creamos un cursor para ejecutar consultas SQL
    cadena = '''
    <!-- Maqueta visual del front de una tienda online -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tienda Online de Tecnología</title>
   <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        nav ul {
            list-style: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
        }
        .product-list {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            padding: 20px;
        }
        .product-item {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 15px;
            padding: 15px;
            width: 250px;
            text-align: center;
        }
        .product-item img {
            max-width: 100%;
            height: auto;
        }
        .product-item h2 {
            font-size: 1.2em;
            margin: 10px 0;
        }
        .product-item p {
            font-size: 0.9em;
            color: #555;
        }
        .price {
            font-size: 1.1em;
            color: #e91e63;
            margin: 10px 0;
            display: block;
        }
        button {
            background-color: #28a745;
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: #218838;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            width: 100%;
            bottom: 0;
        }   
   </style>
</head>
<body>
    <header>
        <h1>Tienda Online de Tecnología</h1>
        <nav>
            <ul>
                <li><a href="#">Inicio</a></li>
                <li><a href="#">Productos</a></li>
                <li><a href="#">Ofertas</a></li>
                <li><a href="#">Contacto</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section class="product-list">
    '''                                             # cadena inicial del HTML de la página web

    # ahora listado de productos ########################################

    cursor.execute("SELECT * FROM productos")
    productos = cursor.fetchall()

    for producto in productos:
        cadena += '''
        <div class="product-item">
            <img src="/static/img/''' + producto[3] + '''" alt="''' + producto[1] + '''">
            <h2>''' + producto[1] + '''</h2>
            <p>''' + producto[2] + '''</p>
            <span class="price">$''' + str(producto[4]) + '''</span>
            <button>Añadir al carrito</button>
        </div>
        '''
    # ahora listado de productos ########################################

    cadena += '''
 </section>
    </main>
    <footer>
        <p>&copy; 2024 Tienda Online de Tecnología. Todos los derechos reservados.</p>
    </footer>
</body>
</html>
    '''                                                         # cadena final del HTML de la página web

    return cadena                                               # Devolvemos la cadena HTML completa como respuesta a la solicitud web
    basededatos.close()                                         # Cerramos la conexión a la base de datos

if __name__ == '__main__':                                      # Si este archivo se ejecuta directamente
    app.run(debug=True)                                         # Ejecutamos la aplicación Flask en modo de depuración
```

### escuchar en todas las interfaces
<small>Creado: 2025-10-27 17:04</small>

#### Explicación

Este código es una parte de un proyecto que implementa una tienda online básica utilizando el framework Flask y una base de datos SQLite. La función principal del fragmento mostrado es generar una página web HTML con información sobre los productos almacenados en la base de datos.

El script se encarga de establecer una conexión a la base de datos `tiendaonline.db` donde se almacenan los registros de productos en una tabla llamada `productos`. Luego, ejecuta una consulta SQL para obtener todos estos registros y los itera uno por uno para generar HTML dinámico que muestra la información del producto (nombre, descripción, imagen y precio) dentro de tarjetas de producto.

El código también incluye un diseño básico con estilos CSS en línea para mejorar la apariencia visual de la página web. Esta estructura permite a los usuarios ver una lista de productos con sus respectivas imágenes, descripciones y precios, además de botones "Añadir al carrito" (que no tienen funcionalidad implementada en este momento).

Finalmente, se especifica que el servidor Flask debe escuchar tanto en la dirección IP `192.168.1.129` como en todas las interfaces disponibles, lo cual facilita el acceso a esta aplicación web desde otros dispositivos en la misma red local.

Este tipo de código es importante porque demuestra cómo integrar un backend basado en Flask con una base de datos SQLite para proporcionar contenido dinámico y adaptable en una página web.

`009-escuchar en todas las interfaces.py`

```python
"""
Proyecto: Tienda Online de Tecnología
Autor: José Vicente Carratalá Sanchis
Fecha: 2025
Versión: 1.0
Framework: Flask
Base de datos: SQLite

Descripción general:
--------------------
Este proyecto implementa una tienda online básica de productos tecnológicos utilizando
el framework Flask (Python) y una base de datos SQLite. La aplicación web muestra un
listado dinámico de productos obtenidos directamente desde la base de datos y genera
una página HTML con diseño responsivo para simular el frontend de una tienda real.

Características principales:
----------------------------
- Conexión automática a la base de datos SQLite 'tiendaonline.db'.
- Obtención de los registros almacenados en la tabla 'productos'.
- Renderizado dinámico de cada producto con su nombre, descripción, imagen y precio.
- Estructura HTML con estilo CSS embebido para ofrecer una experiencia visual moderna.
- Diseño adaptable con cabecera, menú de navegación, listado de productos y pie de página.
- Interfaz sencilla con botones de "Añadir al carrito" (sin funcionalidad aún implementada).

Estructura esperada de la tabla 'productos':
--------------------------------------------
| id (INTEGER PRIMARY KEY) | nombre (TEXT) | descripcion (TEXT) | imagen (TEXT) | precio (REAL) |

Ejemplo de registro:
--------------------
(1, 'Portátil Lenovo IdeaPad', 'Portátil con procesador Ryzen 5 y 16GB RAM', 'lenovo.jpg', 799.99)

Rutas disponibles:
------------------
/        → Página principal con el listado de productos.

Modo de uso:
------------
1. Asegúrate de tener instalado Flask y SQLite3 en tu entorno de Python.
2. Crea la base de datos 'tiendaonline.db' con una tabla 'productos' y algunos registros.
3. Guarda este archivo como 'app.py' o 'tienda.py'.
4. Ejecuta el servidor con:
       python app.py
5. Abre tu navegador en http://127.0.0.1:5000/ para ver la tienda online.

Notas:
------
- Este proyecto sirve como ejemplo didáctico de integración entre Flask y SQLite.
- El carrito de compras y la gestión de usuarios pueden añadirse en versiones posteriores.
"""

import sqlite3                                  # Importamos el módulo sqlite3 para manejar la base de datos SQLite
from flask import Flask                         # Importamos Flask para crear la aplicación web
app = Flask(__name__)                           # Creamos una instancia de la aplicación Flask

@app.route('/')                                 # Definimos la ruta principal de la aplicación
def listar_productos():                         # Función para listar los productos de la tienda online

    basededatos = sqlite3.connect('./tiendaonline.db')  # Conectamos a la base de datos SQLite llamada 'tiendaonline.db'
    cursor = basededatos.cursor()               # Creamos un cursor para ejecutar consultas SQL
    cadena = '''
    <!-- Maqueta visual del front de una tienda online -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tienda Online de Tecnología</title>
   <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        nav ul {
            list-style: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
        }
        .product-list {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            padding: 20px;
        }
        .product-item {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 15px;
            padding: 15px;
            width: 250px;
            text-align: center;
        }
        .product-item img {
            max-width: 100%;
            height: auto;
        }
        .product-item h2 {
            font-size: 1.2em;
            margin: 10px 0;
        }
        .product-item p {
            font-size: 0.9em;
            color: #555;
        }
        .price {
            font-size: 1.1em;
            color: #e91e63;
            margin: 10px 0;
            display: block;
        }
        button {
            background-color: #28a745;
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: #218838;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            width: 100%;
            bottom: 0;
        }   
   </style>
</head>
<body>
    <header>
        <h1>Tienda Online de Tecnología</h1>
        <nav>
            <ul>
                <li><a href="#">Inicio</a></li>
                <li><a href="#">Productos</a></li>
                <li><a href="#">Ofertas</a></li>
                <li><a href="#">Contacto</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section class="product-list">
    '''                                             # cadena inicial del HTML de la página web

    # ahora listado de productos ########################################

    cursor.execute("SELECT * FROM productos")
    productos = cursor.fetchall()

    for producto in productos:
        cadena += '''
        <div class="product-item">
            <img src="/static/img/''' + producto[3] + '''" alt="''' + producto[1] + '''">
            <h2>''' + producto[1] + '''</h2>
            <p>''' + producto[2] + '''</p>
            <span class="price">$''' + str(producto[4]) + '''</span>
            <button>Añadir al carrito</button>
        </div>
        '''
    # ahora listado de productos ########################################

    cadena += '''
 </section>
    </main>
    <footer>
        <p>&copy; 2024 Tienda Online de Tecnología. Todos los derechos reservados.</p>
    </footer>
</body>
</html>
    '''                                                         # cadena final del HTML de la página web

    return cadena                                               # Devolvemos la cadena HTML completa como respuesta a la solicitud web
    basededatos.close()                                         # Cerramos la conexión a la base de datos

if __name__ == '__main__':                                      # Si este archivo se ejecuta directamente
    # Quiero escuchar en 192.168.1.129 y en todas las interfaces
    app.run(host='192.168.1.129', port=5000, debug=True)  # Ejecutamos la aplicación Flask en el host y puerto especificados
```

### Actividades propuestas

Para que tu servidor Flask escuche en todas las interfaces disponibles (es decir, acepte conexiones desde cualquier dirección IP), puedes utilizar `host='0.0.0.0'` en lugar de un host específico como `'192.168.1.129'`. De esta manera, el servidor estará disponible para solicitudes entrantes en todas las interfaces de red disponibles del equipo.

Aquí está tu código modificado para escuchar en todas las interfaces:

```python
"""
Proyecto: Tienda Online de Tecnología
Autor: José Vicente Carratalá Sanchis
Fecha: 2025
Versión: 1.0
Framework: Flask
Base de datos: SQLite

Descripción general:
--------------------
Este proyecto implementa una tienda online básica de productos tecnológicos utilizando
el framework Flask (Python) y una base de datos SQLite. La aplicación web muestra un
listado dinámico de productos obtenidos directamente desde la base de datos y genera
una página HTML con diseño responsivo para simular el frontend de una tienda real.

Características principales:
----------------------------
- Conexión automática a la base de datos SQLite 'tiendaonline.db'.
- Obtención de los registros almacenados en la tabla 'productos'.
- Renderizado dinámico de cada producto con su nombre, descripción, imagen y precio.
- Estructura HTML con estilo CSS embebido para ofrecer una experiencia visual moderna.
- Diseño adaptable con cabecera, menú de navegación, listado de productos y pie de página.
- Interfaz sencilla con botones de "Añadir al carrito" (sin funcionalidad aún implementada).

Estructura esperada de la tabla 'productos':
--------------------------------------------
| id (INTEGER PRIMARY KEY) | nombre (TEXT) | descripcion (TEXT) | imagen (TEXT) | precio (REAL) |

Ejemplo de registro:
--------------------
(1, 'Portátil Lenovo IdeaPad', 'Portátil con procesador Ryzen 5 y 16GB RAM', 'lenovo.jpg', 799.99)

Rutas disponibles:
------------------
/        → Página principal con el listado de productos.

Modo de uso:
------------
1. Asegúrate de tener instalado Flask y SQLite3 en tu entorno de Python.
2. Crea la base de datos 'tiendaonline.db' con una tabla 'productos' y algunos registros.
3. Guarda este archivo como 'app.py'.
4. Ejecuta el servidor con:
       python app.py
5. Abre tu navegador en http://192.168.1.129:5000 o http://localhost:5000 para ver la tienda online.

Notas:
------
- Este proyecto sirve como ejemplo didáctico de integración entre Flask y SQLite.
- El carrito de compras y la gestión de usuarios pueden añadirse en versiones posteriores.
"""

import sqlite3                                  # Importamos el módulo sqlite3 para manejar la base de datos SQLite
from flask import Flask                         # Importamos Flask para crear la aplicación web
app = Flask(__name__)                           # Creamos una instancia de la aplicación Flask

@app.route('/')                                 # Definimos la ruta principal de la aplicación
def listar_productos():                         # Función para listar los productos de la tienda online

    basededatos = sqlite3.connect('./tiendaonline.db')  # Conectamos a la base de datos SQLite llamada 'tiendaonline.db'
    cursor = basededatos.cursor()               # Creamos un cursor para ejecutar consultas SQL
    cadena = '''
    <!-- Maqueta visual del front de una tienda online -->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tienda Online de Tecnología</title>
   <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        nav ul {
            list-style: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin: 0 15px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
        }
        .product-list {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            padding: 20px;
        }
        .product-item {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 15px;
            padding: 15px;
            width: 250px;
            text-align: center;
        }
        .product-item img {
            max-width: 100%;
            height: auto;
        }
        .product-item h2 {
            font-size: 1.2em;
            margin: 10px 0;
        }
        .product-item p {
            font-size: 0.9em;
            color: #555;
        }
        .price {
            font-size: 1.1em;
            color: #e91e63;
            margin: 10px 0;
            display: block;
        }
        button {
            background-color: #28a745;
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: #218838;
        }
        footer {
            background-color: #333;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            position: fixed;
            width: 100%;
            bottom: 0;
        }   
   </style>
</head>
<body>
    <header>
        <h1>Tienda Online de Tecnología</h1>
        <nav>
            <ul>
                <li><a href="#">Inicio</a></li>
                <li><a href="#">Productos</a></li>
                <li><a href="#">Ofertas</a></li>
                <li><a href="#">Contacto</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section class="product-list">
    '''                                             # cadena inicial del HTML de la página web

    # ahora listado de productos ########################################

    cursor.execute("SELECT * FROM productos")
    productos = cursor.fetchall()

    for producto in productos:
        cadena += '''
        <div class="product-item">
            <img src="/static/img/''' + producto[3] + '''" alt="''' + producto[1] + '''">
            <h2>''' + producto[1] + '''</h2>
            <p>''' + producto[2] + '''</p>
            <span class="price">$''' + str(producto[4]) + '''</span>
            <button>Añadir al carrito</button>
        </div>
        '''
    # ahora listado de productos ########################################

    cadena += '''
     </section>
    </main>
    <footer>
        <p>&copy; 2024 Tienda Online de Tecnología. Todos los derechos reservados.</p>
    </footer>
</body>
</html>
    '''                                                         # cadena final del HTML de la página web

    return cadena                                               # Devolvemos la cadena HTML completa como respuesta a la solicitud web
    basededatos.close()                                         # Cerramos la conexión a la base de datos

if __name__ == '__main__':                                      # Si este archivo se ejecuta directamente
    app.run(host='0.0.0.0', port=5000, debug=True)  # Ejecutamos la aplicación Flask en el host y puerto especificados
```

### Explicación:
- **`host='0.0.0.0'`:** Esto configura al servidor Flask para escuchar conexiones desde cualquier dirección IP disponible en tu sistema.
- **`port=5000`:** Este es el puerto en el que el servidor Flask estará disponible (por defecto, este puerto).
- **`debug=True`:** Permite ejecutar la aplicación en modo de depuración.

Al ejecutar este código, tu servidor Flask será accesible desde cualquier dirección IP, lo cual facilita su acceso tanto local como remoto.


<a id="simulacro-examen-1"></a>
## Simulacro examen 1

### Introducción a los ejercicios

Esta carpeta contiene un conjunto de ejercicios diseñados para ayudarte a prepararte para el examen intermodular, enfocándose en la integración entre bases de datos MySQL y aplicaciones web Flask. Los problemas trabajan con la extracción y manipulación de datos desde una base de datos y su visualización en formato HTML vía una aplicación web simple. A lo largo de los ejercicios, practicarás habilidades como consultas SQL básicas, manejo de conexiones a bases de datos, uso del framework Flask para crear rutas web, y construcción básica de páginas web con HTML.

### seleccionar
<small>Creado: 2025-10-30 16:54</small>

#### Explicación

Este fragmento de código se utiliza para conectarse a una base de datos MySQL y recuperar información de una tabla llamada `entradas_con_autores`. Primero, el código importa la biblioteca `mysql.connector`, que permite conectar con bases de datos MySQL desde Python.

Luego, se establece una conexión a la base de datos usando los detalles proporcionados: host (ubicación del servidor), usuario y contraseña. Estos son necesarios para autenticarse en la base de datos. Después, se crea un objeto `cursor` que permite ejecutar comandos SQL y manipular los resultados.

El código ejecuta una consulta SQL simple (`SELECT * FROM entradas_con_autores;`) que recupera todos los registros de la tabla especificada. Luego, las líneas de resultado son almacenadas en la variable `lineas`. Finalmente, se itera sobre cada línea del conjunto de resultados y se imprime en el formato: `| ID | campo1 | campo2 | campo3 | campo4 | campo5 |`.

Este tipo de código es importante porque permite a los desarrolladores interactuar con bases de datos para almacenar, recuperar y manipular información necesaria para aplicaciones web o sistemas administrativos.

`001-seleccionar.py`

```python
import mysql.connector

conexion = mysql.connector.connect(
  host="localhost",
  user="blog2526",
  password="blog2526",
  database="blog2526"
)

cursor = conexion.cursor()

cursor.execute("SELECT * FROM entradas_con_autores;")
lineas = cursor.fetchall()
for linea in lineas:
  print("|",linea[0],"|",linea[1],"|",linea[2],"|",linea[3],"|",linea[4],"|",linea[5])
  
```

### importamos flask
<small>Creado: 2025-10-30 16:56</small>

#### Explicación

Este código es una pequeña aplicación web desarrollada con Flask, un framework de Python popular para crear sitios web. La aplicación también conecta a una base de datos MySQL para recuperar información y mostrarla en el navegador.

El código comienza importando dos módulos importantes: `mysql.connector` para gestionar la conexión con la base de datos y `Flask` para iniciar la aplicación web. Luego, se crea un objeto `Flask` llamado `aplicacion`.

Después, el programa establece una conexión a una base de datos MySQL local llamada "blog2526". Utiliza un cursor para ejecutar una consulta SQL que selecciona todos los registros de la tabla `entradas_con_autores`. Esta consulta devuelve una lista de tuplas que se almacenan en la variable `lineas`.

El siguiente bloque recorre cada línea obtenida y las imprime en el terminal, mostrando cinco campos de datos separados por barras verticales (|), lo que sugiere que estos datos podrían representar una tabla con cinco columnas.

Finalmente, se define un endpoint para la raíz del sitio web ("/") utilizando el decorador `@aplicacion.route("/")`. Cuando alguien accede a esta URL, la función `raiz()` devuelve el mensaje "Hola mundo".

El bloque `if __name__ == "__main__":` asegura que cuando se ejecute este script directamente (no como un módulo importado), Flask iniciará el servidor web y ejecutará la aplicación.

Esta aplicación es importante porque combina los conceptos básicos de programación orientada a objetos con frameworks web, manejo de bases de datos y la creación de interfaces web simples.

`002-importamos flask.py`

```python
import mysql.connector
from flask import Flask

aplicacion = Flask(__name__)

conexion = mysql.connector.connect(
  host="localhost",
  user="blog2526",
  password="blog2526",
  database="blog2526"
)

cursor = conexion.cursor()

cursor.execute("SELECT * FROM entradas_con_autores;")
lineas = cursor.fetchall()
for linea in lineas:
  print("|",linea[0],"|",linea[1],"|",linea[2],"|",linea[3],"|",linea[4],"|",linea[5])
  
@aplicacion.route("/")
def raiz():
  return "Hola mundo"
  
if __name__ == "__main__":
  aplicacion.run()
```

### que lo saque en la web
<small>Creado: 2025-10-30 16:58</small>

#### Explicación

Este código es un ejemplo sencillo de una aplicación web creada con Flask, que se utiliza para mostrar datos desde una base de datos MySQL en el navegador. La aplicación crea una conexión a una base de datos específica llamada "blog2526" y luego ejecuta una consulta SQL para obtener todos los registros de la tabla `entradas_con_autores`. Los resultados obtenidos se formatean en una cadena que finalmente se devuelve al usuario cuando accede a la página principal del sitio web.

El fragmento también muestra cómo se maneja la conexión a la base de datos y el cursor que permite ejecutar consultas SQL. En este caso, después de obtener los registros, el código recorre cada fila para concatenarlos en una sola cadena de texto con un formato específico (usando barras verticales `|` como separadores). Esta cadena es lo que se mostrará al usuario cuando visite la página web.

Es importante destacar que este tipo de manejo directo de resultados en una cadena puede no ser el más eficiente ni seguro para aplicaciones grandes o con muchos usuarios, pero sirve bien como introducción a cómo interactuar entre Flask y MySQL.

`003-que lo saque en la web.py`

```python
import mysql.connector
from flask import Flask

aplicacion = Flask(__name__)

conexion = mysql.connector.connect(
  host="localhost",
  user="blog2526",
  password="blog2526",
  database="blog2526"
)

@aplicacion.route("/")
def raiz():
  cursor = conexion.cursor() 
  cursor.execute("SELECT * FROM entradas_con_autores;")
  cadena = ""
  lineas = cursor.fetchall()
  for linea in lineas:
    cadena += "|"+linea[0]+"|"+linea[1]+"|"+linea[2]+"|"+linea[3]+"|"+linea[4]+"|"+linea[5]
  return cadena
  
if __name__ == "__main__":
  aplicacion.run()
```

### creamos un articulo
<small>Creado: 2025-10-30 17:01</small>

#### Explicación

Este fragmento de código es una aplicación Flask básica que muestra entradas de un blog desde una base de datos MySQL. Primero, el programa importa las bibliotecas necesarias: `mysql.connector` para la conexión con la base de datos y `Flask` para crear la aplicación web.

Luego, crea una instancia de la clase `Flask`, llamada `aplicacion`. Establece una conexión a la base de datos MySQL utilizando credenciales específicas (host local, usuario "blog2526", contraseña "blog2526" y la base de datos "blog2526"). El decorador `@aplicacion.route("/")` indica que la función `raiz()` será ejecutada cuando se acceda a la raíz del sitio web.

La función `raiz()` conecta al cursor de la base de datos, realiza una consulta SQL para obtener todas las entradas desde la tabla `entradas_con_autores`, y luego recorre cada fila devuelta por el SELECT. Para cada entrada, construye un artículo HTML con detalles como título, autor, fecha y contenido del post, que se añaden a una cadena final.

Finalmente, cuando alguien visita la página raíz del sitio web (localhost:5000), esta función devuelve esa cadena de HTML, mostrando todos los artículos en formato web. La línea `if __name__ == "__main__":` asegura que el servidor Flask se ejecute solo si este script es ejecutado directamente y no importado como un módulo.

Esta implementación combina conceptos importantes para proyectos de desarrollo web, incluyendo conectividad a bases de datos, manejo de solicitudes HTTP mediante Flask y generación de contenido dinámico.

`004-creamos un articulo.py`

```python
import mysql.connector
from flask import Flask

aplicacion = Flask(__name__)

conexion = mysql.connector.connect(
  host="localhost",
  user="blog2526",
  password="blog2526",
  database="blog2526"
)

@aplicacion.route("/")
def raiz():
  cursor = conexion.cursor() 
  cursor.execute("SELECT * FROM entradas_con_autores;")
  cadena = ""
  lineas = cursor.fetchall()
  for linea in lineas:
    cadena += '''
      <article>
        <h3>'''+linea[0]+'''</h3>
        <p>'''+linea[3]+''' '''+linea[4]+''' - '''+linea[5]+'''</p>
        <time>'''+linea[2]+'''</time>
        <p>'''+linea[1]+'''</p>
      </article>
    '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run()
```

### estilo mas consistente
<small>Creado: 2025-10-30 17:05</small>

#### Explicación

Este fragmento de código es un ejemplo de cómo se puede crear una aplicación web simple usando Flask, que es una librería en Python para hacer páginas web. La aplicación conecta a una base de datos MySQL y muestra información desde esa base de datos en la página web.

Primero, el código importa las bibliotecas necesarias: `mysql.connector` para gestionar la conexión con la base de datos y `Flask` para crear la aplicación web. Luego, crea un objeto `aplicacion` a partir de Flask que será nuestra aplicación web principal.

El código establece una conexión a una base de datos MySQL ubicada en el servidor local (`localhost`). La base de datos se llama `blog2526`, y utiliza las credenciales de usuario `blog2526`.

La función `raiz()` es la que Flask llamará cuando alguien visite la página principal del sitio web (la "ruta" `/`). Esta función obtiene los datos de una tabla llamada `entradas_con_autores` en la base de datos y los organiza en un formato HTML. Cada entrada se muestra como un artículo en el diseño HTML generado, incluyendo detalles como el título, autor, fecha y contenido del post.

Finalmente, si este archivo es ejecutado directamente (no importado por otro script), llama a `aplicacion.run()`, lo que inicia el servidor web de Flask para que pueda ser accedido desde un navegador web en la dirección local.

Este tipo de código es importante porque permite conectar bases de datos y servidores web con aplicaciones escritas en Python, abriendo una gran cantidad de posibilidades para crear sitios web dinámicos.

`005-estilo mas consistente.py`

```python
import mysql.connector
from flask import Flask

aplicacion = Flask(__name__)

conexion = mysql.connector.connect(
  host="localhost",
  user="blog2526",
  password="blog2526",
  database="blog2526"
)

@aplicacion.route("/")
def raiz():
  cursor = conexion.cursor() 
  cursor.execute("SELECT * FROM entradas_con_autores;")
  cadena = '''
  <!doctype html>
  <html>
  <head>
    <style>
      *{padding:2px;margin:2px;}
      body{background:grey;font-family:sans-serif;}
      header,main,footer{width:500px;background:white;padding:20px;margin:auto;}
      article{padding-bottom:20px;border-bottom:1px solid grey;margin-bottom:20px;}
      p{font-size:11px;}
    </style>
  </head>
  <body>
  <header>
    <h1>El blog de Jose Vicente</h1>
  </header>
  <main>
  '''
  lineas = cursor.fetchall()
  for linea in lineas:
    cadena += '''
      <article>
        <h3>'''+linea[0]+'''</h3>
        <p>'''+linea[3]+''' '''+linea[4]+''' - '''+linea[5]+'''</p>
        <time>'''+linea[2]+'''</time>
        <p>'''+linea[1]+'''</p>
      </article>
    '''
  cadena += '''
  </main>
  <footer>
  </footer>
  </body>
  </html>
  '''
  return cadena
  
if __name__ == "__main__":
  aplicacion.run()
```

### Actividades propuestas

### Actividad 1: Conexión a Base de Datos con MySQL y Python

**Descripción:** 
Los estudiantes deben crear un programa en Python que se conecte a una base de datos MySQL local (usando las credenciales proporcionadas) y ejecute una consulta SELECT para obtener información específica. El objetivo es familiarizarse con la conexión a bases de datos mediante bibliotecas de Python.

### Actividad 2: Introducción al Framework Flask

**Descripción:** 
Los estudiantes deben implementar un servicio web simple usando el framework Flask que responda con "Hola mundo" cuando se accede a la ruta raíz. Esto permitirá que los estudiantes comprendan cómo configurar y ejecutar aplicaciones de Flask.

### Actividad 3: Mostrar Datos en una Página Web

**Descripción:** 
Los alumnos deben modificar el código para que, al realizar una consulta SELECT a la base de datos, se muestren los resultados directamente en la página web principal. Esto permitirá combinar las habilidades adquiridas con MySQL y Flask.

### Actividad 4: Formatear Contenido HTML

**Descripción:** 
Los estudiantes deben refactorizar el contenido de una consulta SELECT para que se muestre como artículos formateados dentro de un bloque de contenido web. Esto proporcionará experiencia en el uso básico de etiquetas HTML con datos dinámicos.

### Actividad 5: Mejora Visual del Contenido Web

**Descripción:** 
Los alumnos deben añadir estilos CSS a la página web para mejorar su apariencia y legibilidad. Se espera que integren hojas de estilo CSS directamente en el código, aprendiendo así cómo estructurar HTML y CSS.

### Actividad 6: Manejo de Errores

**Descripción:** 
Los estudiantes deben identificar posibles errores en los ejemplos proporcionados (por ejemplo, manejo inadecuado de conexiones a la base de datos) y agregar código para capturar y gestionar excepciones correctamente.

### Actividad 7: Consultas Personalizadas

**Descripción:** 
Los alumnos deben modificar las consultas SELECT existentes para filtrar o ordenar los resultados según criterios específicos. Esto permitirá que se familiaricen con la estructura de consultas SQL más avanzada.

### Actividad 8: Implementación Básica de Seguridad

**Descripción:** 
Los estudiantes deben implementar medidas básicas de seguridad en sus aplicaciones web, como el uso seguro de contraseñas y validación de entradas. Esto familiarizará a los alumnos con conceptos esenciales para la protección contra ataques comunes.

Estas actividades buscan cubrir desde el manejo básico hasta aspectos más avanzados del desarrollo web en Python, preparando así a los estudiantes para proyectos más complejos en ciclos formativos de nivel superior.


<a id="simulacro-examen-2"></a>
## Simulacro examen 2


<a id="simulacro-examen-3"></a>
## Simulacro examen 3


<a id="resolucion-de-dudas"></a>
## Resolucion de dudas


<a id="examen-final"></a>
## Examen final

### Introducción a los ejercicios

En esta carpeta, encontrarás una serie de ejercicios diseñados para repasar y consolidar tus conocimientos en SQL, centrándote principalmente en el manejo de bases de datos relacionales. Los problemas abordan la creación de tablas con relaciones entre ellas, inserción de datos, definición de claves foráneas, selección de datos mediante consultas simples y avanzadas, y gestión de usuarios y privilegios en MySQL. A través de estos ejercicios, aprenderás a estructurar correctamente una base de datos, realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar), y trabajar con vistas para simplificar la consulta y visualización de datos complejos.

### crear tablas
<small>Creado: 2025-11-13 15:47</small>

#### Explicación

Este fragmento de código SQL está diseñado para crear una base de datos y dos tablas dentro de ella. Primero, se crea una base de datos llamada `portafolioceac` con el comando `CREATE DATABASE`. Luego, se selecciona esta base de datos recién creada usando el comando `USE portafolioceac`.

Después, se crean dos tablas: `Piezas` y `Categorias`. La tabla `Piezas` almacena información sobre diferentes piezas que podrían ser parte de un catálogo o inventario. Cada fila en esta tabla contiene datos como el identificador único de la pieza (que es autoincremental), el título, una descripción, el nombre del archivo imagen y un URL asociado, así como una referencia a la categoría a la que pertenece con `id_categoria`.

La tabla `Categorias`, por otro lado, almacena información sobre las diferentes categorías a las que pueden pertenecer estas piezas. Cada fila en esta tabla tiene un identificador único autoincremental y campos para el título y descripción de cada categoría.

Esta estructura es importante porque permite organizar y relacionar datos de manera eficiente, facilitando la búsqueda y gestión de piezas según sus categorías.

`001-crear tablas.sql`

```sql
CREATE DATABASE portafolioceac;

USE portafolioceac;


CREATE TABLE Piezas(
  Identificador INT auto_increment PRIMARY KEY,
  titulo VARCHAR(255),
  descripcion VARCHAR(255),
  imagen VARCHAR(255),
  url VARCHAR(255),
  id_categoria INT
);

CREATE TABLE Categorias(
  Identificador INT auto_increment PRIMARY KEY,
  titulo VARCHAR(255),
  descripcion VARCHAR(255)
);
```

### insertar
<small>Creado: 2025-11-13 15:47</small>

#### Explicación

Este fragmento de código SQL está realizando inserciones en dos tablas diferentes: `Categorias` y `Piezas`. En la tabla `Categorias`, se inserta un nuevo registro que representa una categoría general. La primera columna (`ID`) se deja en NULL, lo cual permite al motor de base de datos generar automáticamente un valor único para este campo. Luego, se especifican el nombre 'General' y una descripción detallada.

En la tabla `Piezas`, también se inserta un nuevo registro que representa una pieza específica con detalles como su nombre ('Primera pieza'), descripción ('Esta es la descripcion de la primera pieza'), imagen asociada ('josevicente.jpg'), URL del sitio web ('https://jocarsa.com') y finalmente, el campo `ID_Categoria` se establece en 1, lo que indica que esta pieza pertenece a la categoría con ID 1 (la recién creada 'General').

Estas inserciones son esenciales para poblar una base de datos con información inicial, permitiendo así el funcionamiento correcto del sistema o aplicación que se está desarrollando.

`002-insertar.sql`

```sql
INSERT INTO Categorias VALUES(
  NULL,
  'General',
  'Esta es la categoria general'
);

INSERT INTO Piezas VALUES(
  NULL,
  'Primera pieza',
  'Esta es la descripcion de la primera pieza',
  'josevicente.jpg',
  'https://jocarsa.com',
  1
);
```

### fk
<small>Creado: 2025-11-13 15:47</small>

#### Explicación

Este código SQL se utiliza para modificar una tabla existente llamada `Piezas`. En particular, agrega una restricción de clave externa (foreign key en inglés), que es un tipo especial de columna en una base de datos relacional que vincula las filas entre dos tablas. La restricción que se añade aquí se llama `fk_piezas_categorias` y conecta la tabla `Piezas` con la tabla `Categorias`.

La columna `id_categoria` en la tabla `Piezas` se ha establecido como una clave externa referenciando a la columna `identificador` de la tabla `Categorias`. Esto significa que cada valor en la columna `id_categoria` debe existir también en la columna `identificador` de la tabla `Categorias`, lo que ayuda a mantener la integridad y consistencia de los datos.

Además, se especifican dos acciones adicionales cuando ocurren cambios en las tablas relacionadas: `ON DELETE CASCADE` indica que si un registro es eliminado de la tabla `Categorias`, todos los registros asociados en `Piezas` también serán eliminados automáticamente. De igual manera, `ON UPDATE CASCADE` asegura que si el valor de `identificador` se actualiza en la tabla `Categorias`, este cambio será reflejado automáticamente en la columna `id_categoria` de la tabla `Piezas`. Esto es útil para mantener los datos sincronizados entre las tablas relacionadas.

`003-fk.sql`

```sql
ALTER TABLE Piezas
ADD CONSTRAINT fk_piezas_categorias
FOREIGN KEY (id_categoria) REFERENCES Categorias(identificador)
ON DELETE CASCADE
ON UPDATE CASCADE;
```

### selecciones
<small>Creado: 2025-11-13 15:47</small>

#### Explicación

Este fragmento de código SQL consta de dos consultas simples que seleccionan todos los registros de dos tablas diferentes llamadas "Categorias" y "Piezas". La primera consulta, `SELECT * FROM Categorias;`, recupera toda la información almacenada en la tabla "Categorias", mostrando todas las columnas y filas disponibles. De manera similar, la segunda consulta, `SELECT * FROM Piezas;`, hace lo mismo pero para la tabla "Piezas".

Estos comandos son útiles cuando necesitas revisar el contenido actual de estas tablas, por ejemplo, al comprobar que los datos se han insertado correctamente o simplemente para entender mejor cómo están estructuradas tus bases de datos. Es importante tener claro cuáles son las tablas involucradas y qué información contiene cada una, ya que esto te ayudará a realizar consultas más complejas en el futuro.

`004-selecciones.sql`

```sql
SELECT * FROM Categorias;

SELECT * FROM Piezas;
```

### left join
<small>Creado: 2025-11-13 15:47</small>

#### Explicación

Este código SQL realiza una operación llamada `LEFT JOIN` entre dos tablas, que en este caso son "Piezas" y "Categorias". La función de un LEFT JOIN es combinar filas de ambas tablas basándose en la condición especificada en el ON (en este caso, donde `Piezas.id_categoria` coincide con `Categorias.Identificador`). Esto significa que se incluirán todas las piezas de la tabla "Piezas", incluso si no tienen una categoría correspondiente en la tabla "Categorias". La estrella (`*`) al principio indica que se seleccionarán todos los campos de ambas tablas resultantes del JOIN. Esta consulta es útil para obtener información detallada sobre cada pieza, incluyendo sus categorías asociadas, y mantener registros de las piezas incluso cuando no existen datos en la tabla de categorías relacionados con ellas.

`005-left join.sql`

```sql
SELECT 
* 
FROM Piezas
LEFT JOIN Categorias
ON Piezas.id_categoria = Categorias.Identificador;
```

### ahora creo la vista
<small>Creado: 2025-11-13 15:47</small>

#### Explicación

Este fragmento de código SQL está formado por dos partes principales: la creación de una vista llamada `piezas_y_categorias` y un SELECT que consulta esta vista recién creada. La vista combina información de dos tablas diferentes, `Categorias` y `Piezas`, utilizando una operación LEFT JOIN para asociar las piezas con sus respectivas categorías basándose en el identificador único de la categoría (`id_categoria`) de cada pieza.

La primera parte del código crea una nueva vista que contiene columnas específicas como el título y descripción tanto de las categorías como de las piezas, además de la imagen y URL asociadas a cada pieza. Esta vista facilita la visualización combinada de los datos entre estas dos tablas, permitiendo a otros usuarios o scripts acceder fácilmente a esta información sin tener que escribir una consulta JOIN compleja cada vez.

La segunda parte del código simplemente selecciona todos los campos (`*`) desde la vista `piezas_y_categorias`, lo cual muestra directamente en el resultado de la consulta toda la información que se acaba de combinar al crear la vista. Esto es útil para verificar rápidamente si la vista ha sido creada correctamente y contiene los datos esperados.

Esta técnica de creación de vistas puede ser muy valiosa cuando trabajas con tablas relacionadas porque simplifica el acceso a datos combinados sin necesidad de repetir las mismas consultas JOIN cada vez que se requiere esta información.

`006-ahora creo la vista.sql`

```sql
CREATE VIEW piezas_y_categorias AS 
SELECT 
Categorias.titulo AS categoriatitulo,
Categorias.descripcion AS categoriadescripcion,
Piezas.titulo AS piezatitulo,
Piezas.descripcion AS piezadescripcion,
imagen,
url
FROM Piezas
LEFT JOIN Categorias
ON Piezas.id_categoria = Categorias.Identificador;

SELECT * FROM piezas_y_categorias;
```

### usuario
<small>Creado: 2025-11-13 15:47</small>

#### Explicación

Este fragmento de código SQL se utiliza para gestionar los usuarios y sus permisos en una base de datos MySQL. En primer lugar, crea un nuevo usuario llamado `portafolioceac` que tiene acceso a la base de datos desde el servidor local (`localhost`). Luego, le asigna al usuario el nivel mínimo de privilegios, permitiéndole sólo conectarse sin restricciones adicionales mediante la sentencia `GRANT USAGE`. Después, se modifican los límites del usuario para eliminar cualquier tipo de restricción (como el número máximo de consultas por hora), lo que hace que pueda realizar operaciones sin límites temporales o cuota. Finalmente, se le otorga acceso completo (`ALL PRIVILEGES`) a todas las tablas en la base de datos `portafolioceac`. La última línea del código actualiza los privilegios actuales para aplicar estos cambios inmediatamente. Este proceso es crucial para establecer un entorno de prueba o desarrollo seguro y configurado según las necesidades específicas del proyecto.

`007-usuario.sql`

```sql
-- crea usuario nuevo con contraseña
-- creamos el nombre de usuario que queramos
CREATE USER 
'portafolioceac'@'localhost' 
IDENTIFIED  BY 'portafolioceac';

-- permite acceso a ese usuario
GRANT USAGE ON *.* TO 'portafolioceac'@'localhost';
--[tuservidor] == localhost
-- La contraseña puede requerir Mayus, minus, numeros, caracteres, min len

-- quitale todos los limites que tenga
ALTER USER 'portafolioceac'@'localhost' 
REQUIRE NONE 
WITH MAX_QUERIES_PER_HOUR 0 
MAX_CONNECTIONS_PER_HOUR 0 
MAX_UPDATES_PER_HOUR 0 
MAX_USER_CONNECTIONS 0;

-- dale acceso a la base de datos empresadam
GRANT ALL PRIVILEGES ON portafolioceac.* 
TO 'portafolioceac'@'localhost';

-- recarga la tabla de privilegios
FLUSH PRIVILEGES;
```

### Actividades propuestas

### Actividad 1: Crear una Base de Datos y Tablas

**Descripción:** Crea una base de datos llamada `biblioteca` y dos tablas: `Libros` e `Autores`. La tabla `Libros` debe tener campos para el título, autor, año de publicación y género. La tabla `Autores` debe contener los nombres y apellidos de los autores. Aprenderás a definir esquemas y relaciones entre tablas.

### Actividad 2: Insertar Datos en Tablas

**Descripción:** Introduce al menos tres registros en las tablas creadas en la actividad anterior, asegurándote de que cada libro tenga un autor asociado. Aprenderás cómo realizar inserciones eficientes en múltiples tablas.

### Actividad 3: Crear Relaciones entre Tablas

**Descripción:** Establece una relación "uno a muchos" entre la tabla `Autores` y la tabla `Libros`, utilizando claves foráneas. Aprenderás cómo utilizar instrucciones SQL para vincular datos entre tablas.

### Actividad 4: Consultar Datos de Tablas

**Descripción:** Escribe consultas que seleccionen todos los registros de ambas tablas creadas en las actividades anteriores, aprendiendo a usar `SELECT * FROM`. Aprenderás cómo obtener información completa desde tus bases de datos.

### Actividad 5: Realizar Consultas JOIN

**Descripción:** Utiliza la instrucción SQL `LEFT JOIN` para unir los registros de las tablas `Libros` y `Autores`, mostrando todos los libros con sus autores asociados. Aprenderás a manipular datos entre múltiples tablas utilizando JOINs.

### Actividad 6: Crear una Vista

**Descripción:** Crea una vista que unifique la información de las tablas `Libros` y `Autores`, mostrando los detalles de cada libro junto con el nombre del autor. Aprenderás a simplificar consultas complejas mediante vistas.

### Actividad 7: Crear y Configurar Usuario para Base de Datos

**Descripción:** Crea un usuario nuevo en tu base de datos de biblioteca, asigna privilegios necesarios y configura las restricciones para este usuario. Aprenderás a gestionar usuarios y permisos en MySQL.

### Actividad 8: Borrado Lógico con Cascada

**Descripción:** Modifica la relación existente entre `Libros` y `Autores` para que al eliminar un autor, los libros asociados no se borren pero queden marcados como "eliminados" (cambiando un campo de estado). Aprenderás a utilizar cláusulas ON DELETE en las relaciones con MySQL.

### Actividad 9: Mejora de Consultas JOIN

**Descripción:** Realiza consultas más complejas utilizando múltiples `JOINs` para combinar información desde varias tablas relacionadas, aprendiendo cómo obtener datos completos y bien estructurados a partir de diferentes fuentes en tu base de datos.

### Actividad 10: Análisis de Datos con Consultas Agrupadas

**Descripción:** Escribe consultas que agrupen los libros por género y muestren cuántos libros hay en cada categoría. Aprenderás cómo utilizar funciones agregadas como COUNT() junto con GROUP BY para analizar datos.

Estas actividades están diseñadas para cubrir desde la creación de esquemas hasta el análisis avanzado, proporcionando una base sólida sobre SQL y bases de datos para estudiantes de Formación Profesional.


<a id="instalacion-de-ollama"></a>
## Instalacion de Ollama



<a id="ejercicios-segundo-trimestre"></a>
# Ejercicios segundo trimestre

<a id="proyecto-piero"></a>
## Proyecto Piero

### Introducción a los ejercicios

El código proporcionado es una implementación que busca y descarga imágenes de Google Images usando Python. Aquí están los detalles importantes:

1. **Importaciones Necesarias**:
   - `requests`: Para hacer solicitudes HTTP.
   - `BeautifulSoup` desde `bs4`: Para analizar el contenido HTML recibido.
   - `os`, `re`: Módulos estándar de Python para manejar archivos y expresiones regulares respectivamente.
   - `urllib.parse`: Para trabajar con URL.
   - `time`, `random`: Para añadir un retraso aleatorio en las peticiones HTTP.

2. **Configuración**:
   - Define el término de búsqueda (`SEARCH_QUERY`) que es solicitado al usuario antes de ejecutar el script.
   - Crea una carpeta llamada `'google_images'` donde se guardarán los archivos descargados usando `os.makedirs()`.
   - Establece las cabeceras HTTP para simular un navegador web con los valores de `'User-Agent'`, `'Accept-Language'`, y otros parámetros.

3. **Funciones**:
   - **build_google_images_url(query, start=0)**: Construye la URL de búsqueda en Google Images basada en el término de búsqueda y el número inicial de resultados a partir del cual se empieza a buscar.
   
   - **download_google_images(query, num_images=20)**: Descarga las páginas HTML con los resultados de búsqueda y extrae URLs de imágenes. Utiliza expresiones regulares para encontrar URLS en contenido JSON dentro de etiquetas `<script>`.
   
   - **download_images(image_urls)**: Descarga cada imagen encontrada desde la URL dada, verifica su tipo MIME para asegurarse de que se trata realmente de una imagen y maneja los nombres de archivo para evitar sobrescribir archivos existentes.

4. **Ejecución Principal**:
   - Busca imágenes basándose en el término proporcionado por el usuario.
   - Descarga las imágenes encontradas en la carpeta especificada.
   - Imprime un mensaje final con la cantidad de imágenes descargadas exitosamente.

Es importante tener en cuenta que este tipo de scraper puede violar los términos de servicio del sitio web al que está haciendo scraping, ya que Google tiene una política estricta contra el uso de bots y scrapers. Si bien esta herramienta es útil para aprendizaje y prueba, no se recomienda su uso en entornos reales o comerciales sin permiso explícito.

Además, este script maneja la limitación del número total de imágenes a descargar (por defecto 20) y añade un retraso aleatorio entre las solicitudes para hacer el comportamiento más humano. Sin embargo, esto no garantiza necesariamente que evite ser detectado por Google como una actividad sospechosa o maliciosa.

Para mejorar la robustez del scraper:
- Podrías implementar mecanismos de reintentos en caso de fallos.
- Puedes agregar manejo de cookies para mantener sesiones (aunque esto también puede complicarse debido a las políticas de Google).
- También podrías considerar usar una librería más especializada como Selenium que permite controlar un navegador web de forma programática, lo cual podría hacer el comportamiento del scraper aún más similar al humano.

### peticiones
<small>Creado: 2025-11-17 15:58</small>

#### Explicación

Este fragmento de código es el inicio de un script en Python y muestra la importación de una biblioteca llamada `requests`. La línea `import requests` sirve para incluir todos los métodos, funciones y clases que ofrece esta biblioteca en tu programa. La biblioteca `requests` es muy útil cuando necesitas hacer peticiones HTTP (como GET o POST) a un servidor web desde tu código Python. Esto puede ser importante si estás trabajando en aplicaciones que requieren interactuar con servicios de internet, como solicitar datos de una API.

Esencialmente, esta línea te permite utilizar todas las capacidades proporcionadas por `requests` para manejar comunicaciones HTTP en tu programa. Aunque el código se detiene aquí, es probable que el script continúe luego utilizando esta biblioteca para realizar tareas relacionadas con la web y los datos externos.

`001-peticiones.py`

```python
import requests
```

### pido mi propia web
<small>Creado: 2025-11-17 15:59</small>

#### Explicación

Este fragmento de código es una sencilla solicitud a un sitio web utilizando la biblioteca `requests` en Python. Lo que hace este código es enviar una petición GET al servidor del sitio web ubicado en la dirección "https://jocarsa.com". 

La respuesta del servidor, que incluye el contenido HTML del sitio, se almacena en la variable `response`. Luego, el programa imprime el código de estado de la respuesta para verificar si la petición fue exitosa (por ejemplo, un código 200 significa "OK"). Después, imprime todo el contenido HTML devuelto por el servidor.

Este tipo de operación es importante porque permite a los programadores interactuar con sitios web y extraer información o realizar acciones en ellos, lo que puede ser útil para tareas como la recopilación de datos (web scraping), automatización de formularios o incluso el desarrollo de aplicaciones que integran servicios web.

`002-pido mi propia web.py`

```python
import requests

url = "https://jocarsa.com"

response = requests.get(url)

# si quieres ver el código de estado
print("Status:", response.status_code)

# y aquí tienes el HTML completito
html = response.text
print(html)
```

### guardar mis propias imagenes
<small>Creado: 2025-11-17 16:00</small>

#### Explicación

Este código es una herramienta para descargar todas las imágenes de un sitio web dado. El objetivo principal es extraer y guardar en el directorio local todas las imágenes que se encuentran dentro del contenido HTML o en los estilos CSS del sitio web especificado.

1. **Configuración Inicial**: Comienza configurando la URL del sitio web desde donde se descargarán las imágenes (en este caso, "https://jocarsa.com") y establece una carpeta de salida llamada "imagenes" para guardar las descargas. Si la carpeta no existe, el código la crea automáticamente.

2. **Descarga del HTML**: El programa utiliza la librería `requests` para obtener el contenido HTML desde la URL especificada. Luego, emplea BeautifulSoup para analizar y extraer elementos relevantes del documento HTML.

3. **Recopilación de Imágenes**:
   - Primero, busca todas las etiquetas `<img>` en el HTML y recoge los atributos `src`, que son las URLs de las imágenes.
   - Luego, revisa cada elemento con un estilo CSS para encontrar URLs dentro del atributo `background-image` de las reglas CSS. Esto ayuda a capturar imágenes que pueden no estar explícitamente en la etiqueta `<img>` pero están cargadas por CSS.

4. **Descarga y Guardado**: Una vez recopiladas todas las URLs únicas de las imágenes, el código itera sobre cada URL, descarga el contenido binario del archivo de imagen utilizando `requests`, y finalmente lo guarda en el directorio local especificado.

Esta técnica es útil para hacer copias de seguridad o análisis de sitios web sin necesidad de usar sus interfaces de API públicas. Es importante destacar que al descargar imágenes desde un sitio web, siempre se debe tener en cuenta la legalidad y las políticas del sitio respecto a la reproducción de su contenido.

`003-guardar mis propias imagenes.py`

```python
import requests
from bs4 import BeautifulSoup
import os
import re
from urllib.parse import urljoin, urlparse

# ----------------------------
# CONFIG
# ----------------------------
URL = "https://jocarsa.com"
OUTPUT_DIR = "imagenes"

# Crear carpeta si no existe
os.makedirs(OUTPUT_DIR, exist_ok=True)

# ----------------------------
# Descargar HTML
# ----------------------------
print(f"Descargando HTML desde {URL}...")
response = requests.get(URL)
html = response.text

soup = BeautifulSoup(html, "html.parser")

image_urls = set()

# ----------------------------
# 1. Extraer <img src="...">
# ----------------------------
for img in soup.find_all("img"):
    src = img.get("src")
    if src:
        full_url = urljoin(URL, src)
        image_urls.add(full_url)

# ----------------------------
# 2. Extraer CSS background-image dentro de style=""
#    Ejemplo: style="background-image:url('img/bg.jpg');"
# ----------------------------
pattern = re.compile(r"background-image\s*:\s*url\(['\"]?(.*?)['\"]?\)", re.IGNORECASE)

for elem in soup.find_all(style=True):
    styles = elem["style"]
    matches = pattern.findall(styles)
    for m in matches:
        full_url = urljoin(URL, m)
        image_urls.add(full_url)

# ----------------------------
# Descargar todas las imágenes encontradas
# ----------------------------
print(f"\nEncontradas {len(image_urls)} imágenes:")
for img_url in image_urls:
    print(" -", img_url)

print("\nDescargando imágenes...\n")

for img_url in image_urls:
    try:
        filename = os.path.basename(urlparse(img_url).path)
        if not filename:  # fallback
            filename = "image_" + str(abs(hash(img_url))) + ".jpg"

        filepath = os.path.join(OUTPUT_DIR, filename)

        img_data = requests.get(img_url).content

        with open(filepath, "wb") as f:
            f.write(img_data)

        print(f"✔ Guardada: {filepath}")

    except Exception as e:
        print(f"✘ Error con {img_url}: {e}")

print("\nTerminado.")
```

### scrapeo google
<small>Creado: 2025-11-17 16:04</small>

#### Explicación

Este código Python se utiliza para buscar y descargar imágenes de una página web específica de Google. La página objetivo es un resultado de búsqueda de "ardilla", y el script extrae todas las URLs de las imágenes presentes en esa página.

El proceso principal del código es el siguiente:
1. **Configuración inicial**: Se importan las librerías necesarias y se establece la URL de inicio para buscar imágenes, así como una carpeta de salida para guardarlas.
2. **Descarga del HTML**: El script hace una solicitud HTTP a la URL proporcionada y obtiene el contenido HTML.
3. **Extracción de URLs de imagen**:
   - Se buscan todos los elementos `<img>` en el HTML que contienen las URLs de imágenes directas y se guardan.
   - También busca cadenas CSS `background-image` que pueden contener URLs de imágenes adicionales dentro del atributo `style` de otros elementos web.
4. **Descarga e almacenamiento de imágenes**: Una vez que tiene todas las URLs de imagen, el script descarga cada imagen individualmente y la guarda en la carpeta especificada.

Este tipo de script es útil para tareas como la creación de bases de datos de imágenes personalizadas basadas en búsquedas web específicas o para análisis de cómo los sitios web presentan las imágenes a sus visitantes. Es importante tener en cuenta que al utilizar este script, se deben respetar los términos y condiciones de uso del sitio web desde donde se están descargando las imágenes, ya que no todas las páginas permiten la extracción masiva de contenidos como ésta realiza.

`004-scrapeo google.py`

```python
import requests
from bs4 import BeautifulSoup
import os
import re
from urllib.parse import urljoin, urlparse

# ----------------------------
# CONFIG
# ----------------------------
URL = "https://www.google.com/search?client=ubuntu-chr&hs=zc5&sca_esv=6405bf69fd380f07&sxsrf=AE3TifNt_yEjQ4Met0O46fu4_IZCFjp1ow:1763391692306&udm=2&fbs=AIIjpHx4nJjfGojPVHhEACUHPiMQht6_BFq6vBIoFFRK7qchKEWEvuc0Hbw31oEI7c8o3y4MyqtV5m4rLCGDMco7dQbsn3LCPjOfwb34Pr7sZ7pnaif_wxkbmQ1RDXUJKmgZFKA0yxjAW_dJQshoFr_Eza33GZmyYOVuvA5oknEnCdniqMIxxsRvdOoVFuW0LrZXtURuPEoR&q=ardilla&sa=X&ved=2ahUKEwiFwa37ufmQAxXlhf0HHdPdAIQQtKgLegQIERAB&biw=1920&bih=884&dpr=1"
OUTPUT_DIR = "imagenes"

# Crear carpeta si no existe
os.makedirs(OUTPUT_DIR, exist_ok=True)

# ----------------------------
# Descargar HTML
# ----------------------------
print(f"Descargando HTML desde {URL}...")
response = requests.get(URL)
html = response.text

soup = BeautifulSoup(html, "html.parser")

image_urls = set()

# ----------------------------
# 1. Extraer <img src="...">
# ----------------------------
for img in soup.find_all("img"):
    src = img.get("src")
    if src:
        full_url = urljoin(URL, src)
        image_urls.add(full_url)

# ----------------------------
# 2. Extraer CSS background-image dentro de style=""
#    Ejemplo: style="background-image:url('img/bg.jpg');"
# ----------------------------
pattern = re.compile(r"background-image\s*:\s*url\(['\"]?(.*?)['\"]?\)", re.IGNORECASE)

for elem in soup.find_all(style=True):
    styles = elem["style"]
    matches = pattern.findall(styles)
    for m in matches:
        full_url = urljoin(URL, m)
        image_urls.add(full_url)

# ----------------------------
# Descargar todas las imágenes encontradas
# ----------------------------
print(f"\nEncontradas {len(image_urls)} imágenes:")
for img_url in image_urls:
    print(" -", img_url)

print("\nDescargando imágenes...\n")

for img_url in image_urls:
    try:
        filename = os.path.basename(urlparse(img_url).path)
        if not filename:  # fallback
            filename = "image_" + str(abs(hash(img_url))) + ".jpg"

        filepath = os.path.join(OUTPUT_DIR, filename)

        img_data = requests.get(img_url).content

        with open(filepath, "wb") as f:
            f.write(img_data)

        print(f"✔ Guardada: {filepath}")

    except Exception as e:
        print(f"✘ Error con {img_url}: {e}")

print("\nTerminado.")
```

### probamos con deepseek
<small>Creado: 2025-11-17 16:07</small>

#### Explicación

Este código es una herramienta que permite descargar imágenes de Google Images basándose en un término de búsqueda específico. El objetivo principal del script es automatizar la tarea de buscar y descargar hasta 20 imágenes relacionadas con el término "ardillas" especificado, aunque este valor puede ser cambiado fácilmente.

El código funciona dividiéndose en varias partes:
1. **Configuración inicial**: Define variables como `SEARCH_QUERY` (el término de búsqueda), `OUTPUT_DIR` (donde se guardarán las imágenes descargadas) y establece un conjunto de encabezados para simular una solicitud desde un navegador web real.
2. **Función build_google_images_url**: Construye la URL que será usada para buscar imágenes en Google basándose en los parámetros proporcionados, como el término de búsqueda y cuántos resultados se deben empezar a buscar (útil para páginas sucesivas).
3. **Descarga de HTML desde Google Images**: Utiliza las funciones definidas anteriormente para obtener la página web de Google Images con imágenes relacionadas al término dado.
4. **Extracción e interpretación del contenido HTML y JSON**: Busca URLs de imágenes dentro del contenido HTML obtenido, tanto en etiquetas `<img>` como en datos JSON que pueden contener más URLs.
5. **Descarga de las imágenes**: Crea funciones para descargar físicamente cada imagen encontrada a un directorio local.

Es importante notar que este código podría violar los términos y condiciones de Google ya que implica el uso automático no autorizado de su servicio de búsqueda de imágenes. Además, la página web puede cambiar en estructura o contenido, lo cual afectaría cómo funciona el script actualmente.

`005-probamos con deepseek.py`

```python
import requests
from bs4 import BeautifulSoup
import os
import re
from urllib.parse import urljoin, urlparse, quote
import time
import random

# ----------------------------
# CONFIG
# ----------------------------
SEARCH_QUERY = "ardillas"  # Your search term
OUTPUT_DIR = "google_images"
RESULTS_PER_PAGE = 20

# Headers to mimic real browser
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.9',
    'Accept-Encoding': 'gzip, deflate, br',
    'DNT': '1',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
}

# ----------------------------
# Google Images URL Builder
# ----------------------------
def build_google_images_url(query, start=0):
    """Build Google Images search URL"""
    base_url = "https://www.google.com/search"
    params = {
        'q': query,
        'tbm': 'isch',  # Image search
        'hl': 'en',
        'ijn': '0',
        'start': start,
        'client': 'firefox-b-d'
    }
    return f"{base_url}?{'&'.join(f'{k}={quote(str(v))}' for k, v in params.items())}"

# ----------------------------
# Create output directory
# ----------------------------
os.makedirs(OUTPUT_DIR, exist_ok=True)

# ----------------------------
# Session with cookies
# ----------------------------
session = requests.Session()
session.headers.update(HEADERS)

# ----------------------------
# Download HTML from Google Images
# ----------------------------
def download_google_images(query, num_images=20):
    all_image_urls = set()
    start = 0
    
    while len(all_image_urls) < num_images:
        url = build_google_images_url(query, start)
        print(f"Descargando página desde: {url}")
        
        try:
            # Random delay to avoid detection
            time.sleep(random.uniform(2, 5))
            
            response = session.get(url, timeout=15)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Method 1: Extract from img tags
            for img in soup.find_all('img'):
                src = img.get('src') or img.get('data-src')
                if src and src.startswith('http'):
                    # Filter out Google's own images and icons
                    if 'google.com' not in src or 'logo' not in src.lower():
                        all_image_urls.add(src)
                        print(f"Found image: {src}")
            
            # Method 2: Extract from JSON data (Google stores image URLs in script tags)
            script_tags = soup.find_all('script')
            for script in script_tags:
                script_content = script.string
                if script_content:
                    # Look for URLs in the script content
                    url_patterns = [
                        r'\"(https://[^\"]*\.(?:jpg|jpeg|png|gif|webp)[^\"]*)\"',
                        r'\"(http://[^\"]*\.(?:jpg|jpeg|png|gif|webp)[^\"]*)\"',
                    ]
                    for pattern in url_patterns:
                        matches = re.findall(pattern, script_content, re.IGNORECASE)
                        for match in matches:
                            if 'google' not in match or 'logo' not in match.lower():
                                all_image_urls.add(match)
            
            # Method 3: Look for base64 encoded images in data attributes
            for img in soup.find_all('img', {'src': True}):
                src = img['src']
                if src.startswith('data:image/'):
                    all_image_urls.add(src)
            
            print(f"Total images found so far: {len(all_image_urls)}")
            
            # Check if we should continue to next page
            if len(all_image_urls) >= num_images:
                break
                
            start += RESULTS_PER_PAGE
            
            # Safety limit
            if start > 100:  # Don't go too deep
                break
                
        except requests.exceptions.RequestException as e:
            print(f"Error downloading page: {e}")
            break
        except Exception as e:
            print(f"Unexpected error: {e}")
            break
    
    return list(all_image_urls)[:num_images]

# ----------------------------
# Download images
# ----------------------------
def download_images(image_urls):
    print(f"\nDescargando {len(image_urls)} imágenes...")
    
    success_count = 0
    for i, img_url in enumerate(image_urls):
        try:
            # Create filename
            if img_url.startswith('data:image/'):
                # Handle base64 images
                extension = re.findall(r'data:image/(\w+);', img_url)
                ext = extension[0] if extension else 'png'
                filename = f"image_{i}_base64.{ext}"
            else:
                parsed_url = urlparse(img_url)
                filename = os.path.basename(parsed_url.path)
                if not filename or '.' not in filename:
                    ext = 'jpg'  # default extension
                    filename = f"image_{i}.{ext}"
            
            # Clean filename
            filename = re.sub(r'[^\w\.-]', '_', filename)
            filepath = os.path.join(OUTPUT_DIR, filename)
            
            # Avoid overwriting
            counter = 1
            original_filepath = filepath
            while os.path.exists(filepath):
                name, ext = os.path.splitext(original_filepath)
                filepath = f"{name}_{counter}{ext}"
                counter += 1
            
            # Download image
            if img_url.startswith('data:image/'):
                # Handle base64 images
                import base64
                base64_data = img_url.split(',')[1]
                image_data = base64.b64decode(base64_data)
                with open(filepath, "wb") as f:
                    f.write(image_data)
            else:
                img_response = session.get(img_url, timeout=10, stream=True)
                img_response.raise_for_status()
                
                # Check if it's actually an image
                content_type = img_response.headers.get('content-type', '')
                if content_type and not content_type.startswith('image/'):
                    print(f"✘ No es una imagen: {img_url}")
                    continue
                
                with open(filepath, "wb") as f:
                    for chunk in img_response.iter_content(chunk_size=8192):
                        f.write(chunk)
            
            file_size = os.path.getsize(filepath)
            print(f"✔ [{i+1}/{len(image_urls)}] Guardada: {filename} ({file_size} bytes)")
            success_count += 1
            
            # Random delay between downloads
            time.sleep(random.uniform(1, 3))
            
        except Exception as e:
            print(f"✘ Error con imagen {i+1}: {e}")
    
    return success_count

# ----------------------------
# Main execution
# ----------------------------
if __name__ == "__main__":
    print("🔍 Buscando imágenes en Google...")
    print("⚠️  ADVERTENCIA: Esto puede violar los términos de servicio de Google")
    
    # Get image URLs
    image_urls = download_google_images(SEARCH_QUERY, num_images=20)
    
    if image_urls:
        print(f"\n🎯 Encontradas {len(image_urls)} URLs de imágenes")
        
        # Download images
        success_count = download_images(image_urls)
        
        print(f"\n✅ Terminado! {success_count}/{len(image_urls)} imágenes descargadas en '{OUTPUT_DIR}/'")
    else:
        print("❌ No se encontraron imágenes")
```

### parametro personalizado
<small>Creado: 2025-11-17 16:08</small>

#### Explicación

Este código es una herramienta que permite a los usuarios buscar y descargar imágenes de Google Images. Aquí te explico cómo funciona:

1. **Configuración inicial**: El usuario introduce un término de búsqueda mediante la consola (`input`). Se define también el número de resultados por página (`RESULTS_PER_PAGE`) y se crea una carpeta llamada `google_images` donde se almacenarán las imágenes descargadas.

2. **Construcción de URL para búsquedas**: El código construye URLs para realizar búsquedas de imágenes en Google, utilizando parámetros como el término de búsqueda (`q`) y la página inicial desde la que debe comenzar a buscar (`start`).

3. **Descarga de HTML**: Se utiliza una sesión de `requests` con cabeceras personalizadas para emular un navegador real, lo cual ayuda a evitar ser bloqueado por Google durante las búsquedas.

4. **Extracción y descarga de imágenes**: El código analiza el HTML de las páginas de resultados de búsqueda para extraer URLs de imágenes. Utiliza BeautifulSoup para parsear el contenido y expresiones regulares (`re.findall`) para buscar patrones específicos en el texto. Después, intenta descargar cada imagen encontrada y guardarla localmente en la carpeta `google_images`.

5. **Manejo de errores**: Implementa un manejo básico de errores que imprime mensajes informativos sobre problemas durante la descarga o procesamiento.

Este script es útil para estudiantes que quieren aprender cómo realizar scraping (extracción automatizada de datos web) y cómo descargar contenido desde internet usando Python. Sin embargo, es importante mencionar que este tipo de actividad puede violar los términos de servicio de Google Images, por lo que se recomienda utilizar esta herramienta con precaución y conocer las implicaciones legales.

`006-parametro personalizado.py`

```python
import requests
from bs4 import BeautifulSoup
import os
import re
from urllib.parse import urljoin, urlparse, quote
import time
import random

# ----------------------------
# CONFIG
# ----------------------------
SEARCH_QUERY = input("Introduce el termino que quieres buscar: ")  # Your search term
OUTPUT_DIR = "google_images"
RESULTS_PER_PAGE = 20

# Headers to mimic real browser
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.9',
    'Accept-Encoding': 'gzip, deflate, br',
    'DNT': '1',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
}

# ----------------------------
# Google Images URL Builder
# ----------------------------
def build_google_images_url(query, start=0):
    """Build Google Images search URL"""
    base_url = "https://www.google.com/search"
    params = {
        'q': query,
        'tbm': 'isch',  # Image search
        'hl': 'en',
        'ijn': '0',
        'start': start,
        'client': 'firefox-b-d'
    }
    return f"{base_url}?{'&'.join(f'{k}={quote(str(v))}' for k, v in params.items())}"

# ----------------------------
# Create output directory
# ----------------------------
os.makedirs(OUTPUT_DIR, exist_ok=True)

# ----------------------------
# Session with cookies
# ----------------------------
session = requests.Session()
session.headers.update(HEADERS)

# ----------------------------
# Download HTML from Google Images
# ----------------------------
def download_google_images(query, num_images=20):
    all_image_urls = set()
    start = 0
    
    while len(all_image_urls) < num_images:
        url = build_google_images_url(query, start)
        print(f"Descargando página desde: {url}")
        
        try:
            # Random delay to avoid detection
            time.sleep(random.uniform(2, 5))
            
            response = session.get(url, timeout=15)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Method 1: Extract from img tags
            for img in soup.find_all('img'):
                src = img.get('src') or img.get('data-src')
                if src and src.startswith('http'):
                    # Filter out Google's own images and icons
                    if 'google.com' not in src or 'logo' not in src.lower():
                        all_image_urls.add(src)
                        print(f"Found image: {src}")
            
            # Method 2: Extract from JSON data (Google stores image URLs in script tags)
            script_tags = soup.find_all('script')
            for script in script_tags:
                script_content = script.string
                if script_content:
                    # Look for URLs in the script content
                    url_patterns = [
                        r'\"(https://[^\"]*\.(?:jpg|jpeg|png|gif|webp)[^\"]*)\"',
                        r'\"(http://[^\"]*\.(?:jpg|jpeg|png|gif|webp)[^\"]*)\"',
                    ]
                    for pattern in url_patterns:
                        matches = re.findall(pattern, script_content, re.IGNORECASE)
                        for match in matches:
                            if 'google' not in match or 'logo' not in match.lower():
                                all_image_urls.add(match)
            
            # Method 3: Look for base64 encoded images in data attributes
            for img in soup.find_all('img', {'src': True}):
                src = img['src']
                if src.startswith('data:image/'):
                    all_image_urls.add(src)
            
            print(f"Total images found so far: {len(all_image_urls)}")
            
            # Check if we should continue to next page
            if len(all_image_urls) >= num_images:
                break
                
            start += RESULTS_PER_PAGE
            
            # Safety limit
            if start > 100:  # Don't go too deep
                break
                
        except requests.exceptions.RequestException as e:
            print(f"Error downloading page: {e}")
            break
        except Exception as e:
            print(f"Unexpected error: {e}")
            break
    
    return list(all_image_urls)[:num_images]

# ----------------------------
# Download images
# ----------------------------
def download_images(image_urls):
    print(f"\nDescargando {len(image_urls)} imágenes...")
    
    success_count = 0
    for i, img_url in enumerate(image_urls):
        try:
            # Create filename
            if img_url.startswith('data:image/'):
                # Handle base64 images
                extension = re.findall(r'data:image/(\w+);', img_url)
                ext = extension[0] if extension else 'png'
                filename = f"image_{i}_base64.{ext}"
            else:
                parsed_url = urlparse(img_url)
                filename = os.path.basename(parsed_url.path)
                if not filename or '.' not in filename:
                    ext = 'jpg'  # default extension
                    filename = f"image_{i}.{ext}"
            
            # Clean filename
            filename = re.sub(r'[^\w\.-]', '_', filename)
            filepath = os.path.join(OUTPUT_DIR, filename)
            
            # Avoid overwriting
            counter = 1
            original_filepath = filepath
            while os.path.exists(filepath):
                name, ext = os.path.splitext(original_filepath)
                filepath = f"{name}_{counter}{ext}"
                counter += 1
            
            # Download image
            if img_url.startswith('data:image/'):
                # Handle base64 images
                import base64
                base64_data = img_url.split(',')[1]
                image_data = base64.b64decode(base64_data)
                with open(filepath, "wb") as f:
                    f.write(image_data)
            else:
                img_response = session.get(img_url, timeout=10, stream=True)
                img_response.raise_for_status()
                
                # Check if it's actually an image
                content_type = img_response.headers.get('content-type', '')
                if content_type and not content_type.startswith('image/'):
                    print(f"✘ No es una imagen: {img_url}")
                    continue
                
                with open(filepath, "wb") as f:
                    for chunk in img_response.iter_content(chunk_size=8192):
                        f.write(chunk)
            
            file_size = os.path.getsize(filepath)
            print(f"✔ [{i+1}/{len(image_urls)}] Guardada: {filename} ({file_size} bytes)")
            success_count += 1
            
            # Random delay between downloads
            time.sleep(random.uniform(1, 3))
            
        except Exception as e:
            print(f"✘ Error con imagen {i+1}: {e}")
    
    return success_count

# ----------------------------
# Main execution
# ----------------------------
if __name__ == "__main__":
    print("🔍 Buscando imágenes en Google...")
    print("⚠️  ADVERTENCIA: Esto puede violar los términos de servicio de Google")
    
    # Get image URLs
    image_urls = download_google_images(SEARCH_QUERY, num_images=20)
    
    if image_urls:
        print(f"\n🎯 Encontradas {len(image_urls)} URLs de imágenes")
        
        # Download images
        success_count = download_images(image_urls)
        
        print(f"\n✅ Terminado! {success_count}/{len(image_urls)} imágenes descargadas en '{OUTPUT_DIR}/'")
    else:
        print("❌ No se encontraron imágenes")
```

### Actividades propuestas

El código que has proporcionado es una versión mejorada de un script para descargar imágenes de Google Images utilizando Python. El último archivo (`006-parametro personalizado.py`) permite al usuario introducir el término de búsqueda que desea utilizar, lo cual hace más flexible y práctico el script.

Aquí hay algunos puntos clave sobre cómo funciona este código:

1. **Configuración Inicial**:
   - Se solicita al usuario que ingrese un término de búsqueda.
   - Se establecen las cabeceras HTTP para simular una solicitud desde un navegador real.
   - Se crean las carpetas necesarias para almacenar las imágenes descargadas.

2. **Función `build_google_images_url`**:
   - Construye la URL de Google Images basada en el término de búsqueda y la página inicial deseada.

3. **Descarga de Imágenes**:
   - Se realiza una solicitud a Google Images para obtener HTML.
   - El script extrae URLs de imágenes desde los elementos `img`, los scripts JSON, y datos base64 incrustados en la página.
   - Se eliminan las imágenes que son propiedad de Google (para evitar el robo).

4. **Descarga de Archivos**:
   - Para cada URL de imagen encontrada, se descargará el archivo real.
   - Los nombres de los archivos se limpian y aseguran que no exista un archivo con ese nombre ya en la carpeta de salida.

5. **Protección Anti-Bots**:
   - Se implementan retrasos aleatorios entre las solicitudes para evitar ser detectado como una solicitud automática.
   - Hay excepciones incorporadas para manejar errores comunes durante el proceso de descarga.

### Ejecución del Script

Cuando ejecutes este script, se te pedirá que introduzcas un término de búsqueda. Por ejemplo:

```bash
python 006-parametro personalizado.py
```

Luego, en la consola, verás algo como esto:

```
Introduce el termino que quieres buscar: gato
🔍 Buscando imágenes en Google...
⚠️  ADVERTENCIA: Esto puede violar los términos de servicio de Google
Descargando página desde: https://www.google.com/search?q=gato&tbm=isch&ijn=0...
Found image: http://example.com/cat1.jpg
Found image: http://example.com/cat2.jpg
...
🎯 Encontradas 20 URLs de imágenes

Descargando imagen 1/20 desde http://example.com/cat1.jpg
✔ [1/20] Guardada: cat1.jpg (5678 bytes)
Descargando imagen 2/20 desde http://example.com/cat2.jpg
...
✅ Terminado! 20/20 imágenes descargadas en 'google_images/'
```

### Consideraciones Legales

Es importante recordar que descargar imágenes de Google Images sin permiso puede violar los términos de servicio del sitio web. Se recomienda utilizar este script solo para fines educativos o personal, y siempre respetar los derechos de autor.

Si necesitas usar las imágenes en un proyecto público o comercial, es mejor buscar fuentes legales como sitios con licencias Creative Commons o plataformas dedicadas a la distribución de imágenes libres.


<a id="primer-contacto-con-php"></a>
## Primer contacto con PHP


<a id="proyecto-ollama-menus-saludables"></a>
## proyecto ollama menus saludables


<a id="proyecto-ollama-curriculums"></a>
## Proyecto ollama curriculums



<a id="actividad-libre-de-final-de-evaluacion-la-milla-extra"></a>
# Actividad libre de final de evaluación - La milla extra

<a id="la-milla-extra-primera-evaluacion"></a>
## La Milla Extra - Primera evaluación

### Introducción a los ejercicios

El conjunto de ejercicios en esta carpeta está diseñado para reforzar tus habilidades en la gestión y manipulación de datos utilizando el lenguaje Markdown. Aunque no se trata directamente de programación en un sentido tradicional, este ejercicio te ayudará a comprender cómo estructurar información de manera clara y profesional, una competencia vital cuando trabajas con documentación técnica o sitios web basados en Markdown. Este tipo de práctica es especialmente útil para mejorar tus habilidades en formateo de texto, creación de listas y el uso de encabezados adecuadamente, lo que contribuirá a tu capacidad para presentar información de manera efectiva en diferentes plataformas digitales.

### Actividades propuestas

Basándome en la información proporcionada y asumiendo que los ejercicios están orientados a estudiantes del ciclo formativo DAM (Desarrollo de Aplicaciones Multiplataforma) y tienen un contenido relacionado con el desarrollo web, aquí tienes una lista de actividades adecuadas para estos estudiantes:

1. **Introducción al HTML5 y CSS3**
   - Los alumnos deben crear una página web simple utilizando etiquetas HTML5 básicas y agregar estilos mediante CSS3.
   - Objetivo: Familiarizarse con la estructura básica del código HTML y aprender a aplicar estilos usando CSS.

2. **Estructuración de Páginas Web**
   - Los estudiantes deben diseñar una página web multilingüe utilizando etiquetas semánticas en HTML5.
   - Objetivo: Aprender a utilizar las nuevas etiquetas HTML5 para mejorar la accesibilidad y estructura del contenido.

3. **Uso de Flexbox para Diseño Responsivo**
   - Los alumnos deben crear un diseño responsivo usando flexbox CSS, asegurando que el sitio se vea bien en diferentes tamaños de pantalla.
   - Objetivo: Entender cómo usar Flexbox para lograr diseños adaptativos y accesibles.

4. **Manipulación de DOM con JavaScript**
   - Los estudiantes deben implementar funcionalidades interactivas básicas utilizando manipulación del DOM y eventos en JavaScript.
   - Objetivo: Aprender a interactuar con la estructura HTML desde scripts JS para hacer páginas más dinámicas.

5. **Uso de AJAX para Interacción Asíncrona**
   - Los alumnos deben implementar un sistema sencillo que cargue datos de forma asíncrona usando AJAX.
   - Objetivo: Familiarizarse con la técnica AJAX y aprender cómo intercambiar datos entre cliente y servidor sin recargar la página.

6. **Integración con APIs Externas**
   - Los estudiantes deben integrar una API externa en su proyecto web para proporcionar información dinámica.
   - Objetivo: Aprender a consumir y procesar respuestas de APIs en un entorno web.

7. **Validación de Formularios HTML5 con JavaScript**
   - Los alumnos deben implementar validaciones personalizadas en formularios utilizando atributos de HTML5 y funciones JavaScript.
   - Objetivo: Mejorar la interactividad del usuario al validar datos directamente en el formulario antes de enviarlos.

8. **Optimización de Carga de Páginas**
   - Los estudiantes deben implementar técnicas básicas para mejorar el rendimiento del sitio web, como minificar CSS y JavaScript.
   - Objetivo: Aprender a optimizar la carga de páginas web para una mejor experiencia del usuario.

Estas actividades están diseñadas para complementar los conocimientos ya adquiridos por los estudiantes en su ciclo formativo DAM, centrándose en habilidades esenciales como HTML5, CSS3, JavaScript y buenas prácticas web.



<a id="carpeta-sin-titulo"></a>
# Carpeta sin título
