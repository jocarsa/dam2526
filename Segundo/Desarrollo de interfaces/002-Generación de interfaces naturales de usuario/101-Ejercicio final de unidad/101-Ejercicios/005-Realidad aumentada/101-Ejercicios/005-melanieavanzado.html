<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MediaPipe FaceMesh · AR Makeup + Face PNG Overlay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; background:#111; color:#eee; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .wrap { position:relative; display:grid; place-items:center; min-height:100vh; }
    video, canvas { max-width: min(96vw, 960px); width:100%; height:auto; border-radius:12px; }
    video { display:none; } /* video is painted onto the canvas */
    .hud {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 16px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background: rgba(0,0,0,.55); color:#fff; padding:10px 12px; border-radius: 12px; backdrop-filter: blur(6px);
      font-size: 14px;
    }
    .hud label { display:flex; align-items:center; gap:8px; }
    .hud input[type="color"] { width: 28px; height: 28px; border: none; padding: 0; background: transparent; }
    .badge { position: fixed; top: 12px; left: 12px; background: rgba(0,0,0,.55); padding:6px 10px; border-radius:999px; font-size:12px; }
    .file { padding:4px 8px; background:#222; border-radius:8px; }
    select, input[type="range"] { accent-color:#ff2a88; }
  </style>

  <!-- MediaPipe legacy UMD JS (globals) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="badge">FaceMesh · AR Makeup + Face PNG</div>
    <video id="input_video" autoplay playsinline muted></video>
    <canvas id="output_canvas" width="640" height="480"></canvas>

    <div class="hud">
      <label>
        Effect:
        <select id="effect">
          <option value="lips">Lipstick</option>
          <option value="eyeliner">Eyeliner</option>
          <option value="facepng" selected>Face PNG overlay</option>
        </select>
      </label>

      <!-- Shared -->
      <label>
        Smooth: <input id="smooth" type="range" min="0" max="1" step="0.1" value="0.5" />
      </label>
      <label>
        Mirror: <input id="mirror" type="checkbox" checked />
      </label>

      <!-- Lips -->
      <label id="colorWrap" style="display:none">
        Color: <input id="color" type="color" value="#ff2a88" />
      </label>
      <label id="opacityWrap" style="display:none">
        Opacity: <input id="opacity" type="range" min="0" max="1" step="0.02" value="0.45" />
      </label>

      <!-- Eyeliner -->
      <label id="thicknessWrap" style="display:none">
        Thickness: <input id="thickness" type="range" min="1" max="16" step="1" value="6" />
      </label>

      <!-- Face PNG -->
      <label id="fileWrap" class="file">
        PNG: <input id="pngfile" type="file" accept="image/png" />
      </label>
      <label id="blendWrap">
        Blend:
        <select id="blend">
          <option>source-over</option>
          <option>multiply</option>
          <option>screen</option>
          <option>overlay</option>
          <option>soft-light</option>
          <option>hard-light</option>
          <option>color-dodge</option>
          <option>color-burn</option>
          <option>lighten</option>
          <option>darken</option>
        </select>
      </label>
      <label id="pngAlphaWrap">
        Alpha: <input id="pngAlpha" type="range" min="0" max="1" step="0.02" value="0.9" />
      </label>
      <label id="scaleWrap">
        Scale: <input id="scale" type="range" min="0.5" max="2" step="0.01" value="1.2" />
      </label>
      <label id="rotWrap">
        Rotate°: <input id="rot" type="range" min="-40" max="40" step="1" value="0" />
      </label>
      <label id="offxWrap">
        Off X: <input id="offx" type="range" min="-200" max="200" step="1" value="0" />
      </label>
      <label id="offyWrap">
        Off Y: <input id="offy" type="range" min="-200" max="200" step="1" value="10" />
      </label>
    </div>
  </div>

  <script>
    // ---- DOM ----
    const video  = document.getElementById('input_video');
    const canvas = document.getElementById('output_canvas');
    const ctx    = canvas.getContext('2d');

    const ui = {
      effect:   document.getElementById('effect'),
      color:    document.getElementById('color'),
      opacity:  document.getElementById('opacity'),
      thick:    document.getElementById('thickness'),
      smooth:   document.getElementById('smooth'),
      mirror:   document.getElementById('mirror'),

      // face png
      file:     document.getElementById('pngfile'),
      blend:    document.getElementById('blend'),
      pngAlpha: document.getElementById('pngAlpha'),
      scale:    document.getElementById('scale'),
      rot:      document.getElementById('rot'),
      offx:     document.getElementById('offx'),
      offy:     document.getElementById('offy'),

      // wrappers
      colorWrap:     document.getElementById('colorWrap'),
      opacityWrap:   document.getElementById('opacityWrap'),
      thicknessWrap: document.getElementById('thicknessWrap'),
      fileWrap:      document.getElementById('fileWrap'),
      blendWrap:     document.getElementById('blendWrap'),
      pngAlphaWrap:  document.getElementById('pngAlphaWrap'),
      scaleWrap:     document.getElementById('scaleWrap'),
      rotWrap:       document.getElementById('rotWrap'),
      offxWrap:      document.getElementById('offxWrap'),
      offyWrap:      document.getElementById('offyWrap'),
    };

    // Toggle UI per effect
    function updateUI(){
      const lips     = ui.effect.value === 'lips';
      const eyeliner = ui.effect.value === 'eyeliner';
      const facepng  = ui.effect.value === 'facepng';

      ui.colorWrap.style.display     = lips ? '' : 'none';
      ui.opacityWrap.style.display   = lips ? '' : 'none';
      ui.thicknessWrap.style.display = eyeliner ? '' : 'none';

      [ui.fileWrap, ui.blendWrap, ui.pngAlphaWrap, ui.scaleWrap,
       ui.rotWrap, ui.offxWrap, ui.offyWrap].forEach(el=>{
         el.style.display = facepng ? '' : 'none';
       });
    }
    ui.effect.addEventListener('change', updateUI);
    updateUI();

    // ---- Option helpers ----
    function hexToRgba(hex, a=1){
      const h = hex.replace('#','');
      const n = parseInt(h,16);
      const r = h.length===3 ? ((n>>8)&0xF)*17 : (n>>16)&255;
      const g = h.length===3 ? ((n>>4)&0xF)*17 : (n>>8)&255;
      const b = h.length===3 ? (n&0xF)*17     :  n&255;
      return `rgba(${r},${g},${b},${a})`;
    }

    // ---- Smoothing (simple lerp per landmark) ----
    let prevLandmarks = null;
    const lerp = (a,b,t)=>a+(b-a)*t;
    function smoothLandmarks(curr, t){
      if (!prevLandmarks || prevLandmarks.length !== curr.length) {
        prevLandmarks = curr.map(p=>({...p}));
        return curr;
      }
      const sm = curr.map((p,i)=>({
        x: lerp(prevLandmarks[i].x, p.x, t),
        y: lerp(prevLandmarks[i].y, p.y, t),
        z: lerp(prevLandmarks[i].z, p.z, t),
      }));
      prevLandmarks = sm.map(p=>({...p}));
      return sm;
    }

    // ---- Landmark index sets ----
    // Lips (outer & inner)
    const LIPS_OUTER = [61,146,91,181,84,17,314,405,321,375,291];
    const LIPS_INNER = [78,95,88,178,87,14,317,402,318,324,308];
    // Eyeliner (upper eyelids)
    const RIGHT_EYE_UPPER = [33,7,163,144,145,153,154,155,133];
    const LEFT_EYE_UPPER  = [263,249,390,373,374,380,381,382,362];
    // Face oval (ordered polygon)
    const FACE_OVAL = [10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109];

    // ---- Drawing helpers ----
    function drawVideoFrame(img, mirror){
      ctx.save();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (mirror) {
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
      }
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    function buildPathFromIndices(landmarks, indices){
      ctx.beginPath();
      indices.forEach((idx,i)=>{
        const p = landmarks[idx];
        const x = p.x * canvas.width;
        const y = p.y * canvas.height;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.closePath();
    }

    function fillLipsOuterMinusInner(landmarks, colorRGBA){
      ctx.save();
      ctx.fillStyle = colorRGBA;
      ctx.beginPath();
      LIPS_OUTER.forEach((idx,i)=>{
        const p = landmarks[idx], x=p.x*canvas.width, y=p.y*canvas.height;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.closePath();
      LIPS_INNER.forEach((idx,i)=>{
        const p = landmarks[idx], x=p.x*canvas.width, y=p.y*canvas.height;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.closePath();
      try { ctx.fill('evenodd'); }
      catch(e){
        ctx.fill();
        ctx.globalCompositeOperation = 'destination-out';
        buildPathFromIndices(landmarks, LIPS_INNER);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = colorRGBA;
        buildPathFromIndices(landmarks, LIPS_OUTER);
        ctx.fill();
      }
      ctx.restore();
    }

    function strokeIndices(landmarks, indices, thickness, color){
      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap  = 'round';
      ctx.lineWidth = thickness;
      ctx.strokeStyle = color;
      ctx.beginPath();
      indices.forEach((idx,i)=>{
        const p = landmarks[idx], x=p.x*canvas.width, y=p.y*canvas.height;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
      ctx.restore();
    }

    // ---- Face PNG state ----
    let faceImg = null;
    ui.file.addEventListener('change', (e)=>{
      const file = e.target.files?.[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = ()=>{ faceImg = img; URL.revokeObjectURL(url); };
      img.src = url;
    });

    // Helper: draw PNG overlay aligned to face
    function drawFacePNG(landmarks){
      if (!faceImg) return;

      // Key points
      const L = landmarks[33];   // left eye outer
      const R = landmarks[263];  // right eye outer
      const N = landmarks[1];    // nose tip
      const M = landmarks[13];   // mouth center

      // Convert to pixels
      const toPx = p => ({ x: p.x*canvas.width, y: p.y*canvas.height });
      const pL = toPx(L), pR = toPx(R), pN = toPx(N), pM = toPx(M);

      // Pose: angle by eye line
      const eyeDx = pR.x - pL.x;
      const eyeDy = pR.y - pL.y;
      const angle = Math.atan2(eyeDy, eyeDx);

      // Base scale: distance between eyes, expand to cover face height
      const eyeDist = Math.hypot(eyeDx, eyeDy);
      // Estimate face height (chin ~152, forehead ~10)
      const chin = toPx(landmarks[152]);
      const forehead = toPx(landmarks[10]);
      const faceH = Math.hypot(chin.x-forehead.x, chin.y-forehead.y);

      const userScale = parseFloat(ui.scale.value || '1');
      const imgW = faceImg.width, imgH = faceImg.height;

      // We want the PNG height ~ faceH * factor (covers forehead to chin)
      const targetH = faceH * 1.05 * userScale;
      const scale = targetH / imgH;
      const drawW = imgW * scale;
      const drawH = imgH * scale;

      // Anchor: mid between eyes pushed slightly toward nose/mouth
      const midEyes = { x: (pL.x+pR.x)/2, y:(pL.y+pR.y)/2 };
      const anchor  = {
        x: (midEyes.x*0.5 + pN.x*0.3 + pM.x*0.2),
        y: (midEyes.y*0.5 + pN.y*0.35 + pM.y*0.15),
      };

      // Offsets and rotation from UI
      const offx = parseFloat(ui.offx.value||'0');
      const offy = parseFloat(ui.offy.value||'0');
      const rot  = (parseFloat(ui.rot.value||'0') * Math.PI) / 180;

      // Clip to face oval for realism
      ctx.save();
      buildPathFromIndices(landmarks, FACE_OVAL);
      ctx.clip();

      // Blend + alpha
      ctx.globalCompositeOperation = ui.blend.value || 'source-over';
      ctx.globalAlpha = parseFloat(ui.pngAlpha.value||'0.9');

      // Apply transform so that image center aligns to anchor
      ctx.translate(anchor.x, anchor.y);
      ctx.rotate(angle + rot);

      // Slight 2.5D parallax by yaw approximation using z around eyes
      // (optional, subtle skew)
      const zL = L.z, zR = R.z;
      const yawSkew = Math.max(-0.2, Math.min(0.2, (zL - zR))); // clamp
      ctx.transform(1, 0, yawSkew, 1, 0, 0);

      // Draw centered
      ctx.drawImage(faceImg, -drawW/2 + offx, -drawH*0.45 + offy, drawW, drawH);

      // Restore
      ctx.restore();

      // Reset blend/alpha
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
    }

    // ---- FaceMesh constructor (robust across UMD variants) ----
    const FaceMeshCtor = (window.FaceMesh && window.FaceMesh.FaceMesh) || window.FaceMesh;
    if (!FaceMeshCtor) {
      console.error('FaceMesh constructor not found on window.FaceMesh');
    }

    const faceMesh = new FaceMeshCtor({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.5
    });

    // ---- Results handler ----
    faceMesh.onResults((results)=>{
      // Draw camera frame to canvas (mirrored if selected)
      drawVideoFrame(results.image, ui.mirror.checked);

      const faces = results.multiFaceLandmarks;
      if (!faces || !faces.length) return;

      const t = parseFloat(ui.smooth.value || '0.5');
      const lm = smoothLandmarks(faces[0], t);

      if (ui.effect.value === 'lips') {
        const rgba = hexToRgba(ui.color.value, parseFloat(ui.opacity.value || '0.45'));
        fillLipsOuterMinusInner(lm, rgba);
      } else if (ui.effect.value === 'eyeliner') {
        const thick = parseFloat(ui.thick.value || '6');
        const col   = ui.color.value || '#ffffff';
        ctx.save();
        ctx.globalAlpha = 0.95;
        strokeIndices(lm, RIGHT_EYE_UPPER, thick, col);
        strokeIndices(lm, LEFT_EYE_UPPER,  thick, col);
        ctx.restore();
      } else if (ui.effect.value === 'facepng') {
        drawFacePNG(lm);
      }
    });

    // ---- Camera (global UMD) ----
    const camera = new Camera(video, {
      onFrame: async () => { await faceMesh.send({ image: video }); },
      width:  640,
      height: 480
    });
    camera.start().catch(err=>{
      console.error(err);
      alert('Camera error. Use https or localhost and allow camera permissions.');
    });
  </script>
</body>
</html>

