<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Bounce AI â€“ Dual Radial Visualizer</title>
    <style>
        body{
            margin:0;
            height:100vh;
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            background:#111;
            color:#eee;
            font-family:sans-serif;
            gap:1rem;
        }
        .row{
            display:flex;
            gap:2rem;
            align-items:center;
            justify-content:center;
        }
        canvas{
            background:#111;
            border-radius:50%;
        }
        button{
            padding:0.5rem 1rem;
            border-radius:999px;
            border:none;
            cursor:pointer;
            font-size:1rem;
        }
        .labels{
            display:flex;
            justify-content:space-between;
            width:100%;
            max-width:900px;
            font-size:0.9rem;
            opacity:0.8;
        }
        .labels span{
            flex:1;
            text-align:center;
        }
        .text-row{
            max-width:900px;
            width:100%;
            display:flex;
            flex-direction:column;
            gap:0.35rem;
            font-size:0.9rem;
        }
        .bubble{
            background:#222;
            padding:0.5rem 0.75rem;
            border-radius:0.5rem;
            min-height:1.4rem;
            word-break:break-word;
        }
        .bubble span.label{
            opacity:0.6;
            font-size:0.8rem;
            display:block;
            margin-bottom:0.2rem;
            text-transform:uppercase;
            letter-spacing:0.06em;
        }
        .labels,.text-row{
          display:none;
        }
        #startBtn{
          opacity:0.1;
        }
    </style>
</head>
<body>
    <button id="startBtn">Start bounce AI (mic + speech)</button>

    <div class="row">
        <canvas id="humanCanvas" width="400" height="400"></canvas>
        <canvas id="aiCanvas" width="400" height="400"></canvas>
    </div>

    <div class="labels">
        <span>ðŸ‘¤ Humano (micrÃ³fono)</span>
        <span>ðŸ¤– IA entrenada (speech synthesis)</span>
    </div>

    <div class="text-row">
        <div class="bubble">
            <span class="label">TÃº dices</span>
            <span id="humanText"></span>
        </div>
        <div class="bubble">
            <span class="label">La IA responde</span>
            <span id="aiText"></span>
        </div>
    </div>

    <script>
        // -------------------- CONFIG VISUAL --------------------
        const numRings       = 24;
        const ringWidth      = 6;
        const innerRadius    = 30;
        const maxOpacity     = 0.9;
        const minOpacity     = 0.15;
        const minSpanFactor  = 0.3;
        const maxSpanFactor  = 2.0;
        const audioAngleBoost = 0.02;
        const baseBgAlpha    = 0.18;

        // -------------------- CANVASES --------------------
        const humanCanvas = document.getElementById("humanCanvas");
        const aiCanvas    = document.getElementById("aiCanvas");
        const hctx = humanCanvas.getContext("2d");
        const actx = aiCanvas.getContext("2d");
        const HW = humanCanvas.width;
        const HH = humanCanvas.height;
        const AW = aiCanvas.width;
        const AH = aiCanvas.height;

        class Ring {
            constructor(i, innerRadiusLocal, ringWidthLocal) {
                this.type = Math.floor(Math.random() * 4);
                this.r = innerRadiusLocal + i * ringWidthLocal * 1.3;
                this.baseSpan = Math.random() * Math.PI * 1.5 + Math.PI * 0.3;
                this.phase = Math.random() * Math.PI * 2;
                this.speed = (Math.random() - 0.5) * 0.01;
                this.noisePhase = Math.random() * Math.PI * 2;
                this.noiseSpeed = 0.01 + Math.random() * 0.02;
            }
        }

        const humanRings = [];
        const aiRings    = [];
        for (let i = 0; i < numRings; i++) {
            humanRings.push(new Ring(i, innerRadius, ringWidth));
            aiRings.push(new Ring(i, innerRadius, ringWidth));
        }

        // -------------------- AUDIO â€“ HUMAN (MIC) --------------------
        let audioCtx = null;
        let analyserHuman = null;
        let dataArrayHuman = null;

        async function initHumanAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            const source = audioCtx.createMediaStreamSource(stream);

            analyserHuman = audioCtx.createAnalyser();
            analyserHuman.fftSize = 1024;
            const bufferLength = analyserHuman.frequencyBinCount;
            dataArrayHuman = new Uint8Array(bufferLength);

            source.connect(analyserHuman);
        }

        function getBandEnergyForRing(ringIndex) {
            if (!analyserHuman || !dataArrayHuman) return 0;
            analyserHuman.getByteFrequencyData(dataArrayHuman);
            const len = dataArrayHuman.length;

            const bandSize = Math.floor(len / numRings) || 1;
            const start = ringIndex * bandSize;
            const end = Math.min(start + bandSize, len);

            let sum = 0;
            for (let i = start; i < end; i++) sum += dataArrayHuman[i];
            const avg = sum / (end - start || 1);
            return avg / 255;
        }

        // -------------------- FAKE AI ENVELOPE --------------------
        let aiSpeaking = false;
        let aiLevel = 0;
        let aiPhase = 0;

        function updateAiEnvelope() {
            const target = aiSpeaking ? 0.7 : 0.0;
            const speed  = aiSpeaking ? 0.05 : 0.03;
            aiLevel += (target - aiLevel) * speed;
            aiPhase += 0.03;
        }

        function getAiEnergyForRing(ringIndex) {
            const ring = aiRings[ringIndex];
            ring.noisePhase += ring.noiseSpeed * 0.5;
            const n = 0.5 + 0.5 * Math.sin(aiPhase + ringIndex * 0.7 + ring.noisePhase);
            const energy = aiLevel * (0.4 + 0.6 * n);
            return energy;
        }

        // -------------------- TEXT + SPEECH --------------------
        const humanTextEl = document.getElementById("humanText");
        const aiTextEl    = document.getElementById("aiText");

        let recognition = null;
        let listening = false;

        function initRecognition() {
            const SpeechRec =
                window.SpeechRecognition ||
                window.webkitSpeechRecognition;

            if (!SpeechRec) {
                alert("webkitSpeechRecognition no estÃ¡ disponible en este navegador.");
                return;
            }

            recognition = new SpeechRec();
            recognition.lang = "es-ES";
            recognition.continuous = false;
            recognition.interimResults = false;

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript.trim();
                humanTextEl.textContent = transcript;
                sendToAI(transcript);
            };

            recognition.onerror = (e) => {
                console.error("Recognition error:", e);
            };

            recognition.onend = () => {
                if (listening) {
                    try {
                        recognition.start();
                    } catch (e) {
                        console.warn("Restart recognition error:", e);
                    }
                }
            };
        }

        async function sendToAI(text) {
            try {
                const res = await fetch("/chat", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ message: text })
                });

                const data = await res.json();
                const reply = (data.reply || "").trim();
                aiTextEl.textContent = reply;

                if (reply) {
                    speakAI(reply);
                }
            } catch (e) {
                console.error("Error calling /chat:", e);
            }
        }

        function speakAI(text) {
            if (!("speechSynthesis" in window)) {
                alert("Speech Synthesis no estÃ¡ disponible en este navegador.");
                return;
            }

            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = "es-ES";

            utter.onstart = () => {
                aiSpeaking = true;
            };

            utter.onend = () => {
                aiSpeaking = false;
            };

            window.speechSynthesis.cancel();
            window.speechSynthesis.speak(utter);
        }

        // -------------------- ANIMATION --------------------
        function drawVisualizer(ctx, rings, W, H, energyFn) {
            ctx.fillStyle = `rgba(0,0,0,${baseBgAlpha})`;
            ctx.fillRect(0, 0, W, H);

            ctx.save();
            ctx.translate(W / 2, H / 2);

            for (let i = 0; i < rings.length; i++) {
                const ring = rings[i];
                const energy = energyFn(i);

                const spanFactor = minSpanFactor + (maxSpanFactor - minSpanFactor) * energy;
                const span = ring.baseSpan * spanFactor;

                ring.phase += ring.speed + energy * audioAngleBoost;

                const a1 = ring.phase;
                const a2 = ring.phase + span;

                const lw = ringWidth + energy * 4;
                const opacity = minOpacity + (maxOpacity - minOpacity) * energy;

                switch (ring.type) {
                    case 0:
                        ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                        ctx.lineWidth = lw;
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a1, a2, false);
                        ctx.stroke();
                        ctx.closePath();
                        break;
                    case 1:
                        ctx.fillStyle = `rgba(255,255,255,${opacity * 0.7})`;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, ring.r, a1, a2, false);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 2:
                        ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                        ctx.lineWidth = lw;
                        const step = 0.08;
                        for (let a = a1; a < a2; a += step) {
                            ctx.beginPath();
                            ctx.arc(0, 0, ring.r, a, a + step * 0.5, false);
                            ctx.stroke();
                            ctx.closePath();
                        }
                        ctx.lineWidth = lw + 6;
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a1, a1 + 0.03, false);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a2 - 0.03, a2, false);
                        ctx.stroke();
                        ctx.closePath();
                        break;
                    case 3:
                        ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                        ctx.lineWidth = 1 + energy * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a1, a2, false);
                        ctx.stroke();
                        ctx.closePath();

                        const x1 = Math.cos(a1) * ring.r;
                        const y1 = Math.sin(a1) * ring.r;
                        const x2 = Math.cos(a2) * ring.r;
                        const y2 = Math.sin(a2) * ring.r;

                        const puntoR = 3 + energy * 4;
                        ctx.beginPath();
                        ctx.arc(x1, y1, puntoR, 0, Math.PI * 2, true);
                        ctx.fillStyle = `rgba(255,255,255,${opacity})`;
                        ctx.fill();
                        ctx.closePath();

                        ctx.beginPath();
                        ctx.arc(x2, y2, puntoR, 0, Math.PI * 2, true);
                        ctx.fill();
                        ctx.closePath();
                        break;
                }
            }
            ctx.restore();
        }

        function animate() {
            updateAiEnvelope();
            drawVisualizer(hctx, humanRings, HW, HH, getBandEnergyForRing);
            drawVisualizer(actx, aiRings, AW, AH, getAiEnergyForRing);
            requestAnimationFrame(animate);
        }

        // -------------------- START BUTTON --------------------
        document.getElementById("startBtn").addEventListener("click", async () => {
            try {
                await initHumanAudio();
                initRecognition();
                listening = true;
                if (recognition) recognition.start();

                document.getElementById("startBtn").style.display = "none";
                document.querySelector(".labels").style.display = "flex";
                document.querySelector(".text-row").style.display = "flex";

                animate();
            } catch (e) {
                console.error(e);
                alert("Error inicializando audio o reconocimiento.");
            }
        });
    </script>
</body>
</html>

