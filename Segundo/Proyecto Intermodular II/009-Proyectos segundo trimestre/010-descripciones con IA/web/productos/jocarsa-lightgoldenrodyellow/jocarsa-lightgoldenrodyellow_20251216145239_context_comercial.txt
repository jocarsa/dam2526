# Reporte de proyecto

## Estructura del proyecto

```
/var/www/html/jocarsa-lightgoldenrodyellow
├── .gitignore
├── README.md
├── anterior2
│ ├── anterior
│ │ ├── config.json
│ │ └── lightgoldenrodyellow.py
│ ├── app.py
│ ├── config.json
│ ├── reports
│ ├── requirements.txt
│ ├── static
│ │ ├── css
│ │ │ └── styles.css
│ │ └── js
│ │ └── app.js
│ └── templates
│ ├── base.html
│ └── index.html
├── lightgoldenrodyellow.png
└── lightgoldenrodyellow.py
```

## Código (intercalado)

# jocarsa-lightgoldenrodyellow
**README.md**
```markdown
# Generador de Prompt (Flask)

Versión web del app de Tkinter con una interfaz moderna (Bootstrap 5), render de Markdown (marked.js) y resaltado de código (highlight.js).

## Requisitos
- Python 3.10+
- pip

## Instalación
```bash
cd prompt_generator_webapp
python -m venv .venv
source .venv/bin/activate # Windows: .venv\Scripts\activate
pip install -r requirements.txt
```

## Uso
```bash
python app.py
# abre http://127.0.0.1:5000
```

> **Nota:** Al ejecutarlo en local, el selector de carpetas funciona como un mini-explorador de rutas del sistema desde el navegador. 
Las operaciones de análisis (`os.walk`, SQLite y MySQL) se ejecutan en el servidor local (Flask), por lo que deben apuntar a rutas válidas de tu máquina.

## Características
- **Parámetros del prompt**: Contexto, Objetivo, Restricciones, Formato.
- **Explorador de carpetas** integrado para elegir el proyecto.
- **Generación de estructura y reporte intercalado** del código (mismas reglas que el Tkinter).
- **Análisis de base de datos** SQLite o MySQL (opcional PyMySQL).
- **Vista Markdown y WYSIWYG** con resaltado.
- **Guardar reportes** con nombre `<carpeta>_YYYYmmddHHMMSS.txt`.
- **Guardar prompts de subcarpetas `jocarsa-*`** en carpeta `prompts/`.
- **Persistencia** en `config.json`.

## Configuración
Pulsa "Guardar configuración" para actualizar `config.json`.

```
**lightgoldenrodyellow.py**
```python
#!/usr/bin/env python3
import os
import sys
import argparse
from datetime import datetime

# =========================
# Configuración mínima
# =========================
EXTENSIONES_PERMITIDAS = (
 ".html", ".css", ".js", ".php", ".py", ".java", ".sql",
 ".c", ".cpp", ".cu", ".h", ".json", ".xml", ".md"
)
CARPETAS_EXCLUIDAS = {
 ".git", "node_modules", "vendor", "venv", "__pycache__",
 "modelo_entrenado", ".venv","dist"
}

LANG_MAP = {
 ".html": "html", ".css": "css", ".js": "js", ".php": "php",
 ".py": "python", ".java": "java", ".sql": "sql", ".c": "c",
 ".cpp": "cpp", ".cu": "cuda", ".h": "c", ".json": "json",
 ".xml": "xml", ".md": "markdown",
}

# =========================
# Utilidades
# =========================
def construir_mapa_directorios(ruta_raiz: str) -> str:
 """Devuelve un árbol de directorios estilo 'tree', excluyendo carpetas no deseadas."""
 lineas = []
 raiz_abs = os.path.abspath(ruta_raiz)
 lineas.append(raiz_abs)

 def interno(dir_path: str, prefijo: str = ""):
 try:
 entradas = sorted(os.listdir(dir_path))
 except Exception:
 return
 # Filtra carpetas excluidas
 entradas_visibles = []
 for e in entradas:
 full = os.path.join(dir_path, e)
 if os.path.isdir(full) and e in CARPETAS_EXCLUIDAS:
 continue
 entradas_visibles.append(e)

 for i, entrada in enumerate(entradas_visibles):
 ruta_completa = os.path.join(dir_path, entrada)
 conector = "└── " if i == len(entradas_visibles) - 1 else "├── "
 lineas.append(prefijo + conector + entrada)
 if os.path.isdir(ruta_completa):
 extension = " " if i == len(entradas_visibles) - 1 else "│ "
 interno(ruta_completa, prefijo + extension)

 interno(ruta_raiz)
 return "\n".join(lineas)

def generar_reporte_intercalado(ruta_raiz: str, nivel: int = 1) -> str:
 """
 Recorre la carpeta y, para cada archivo con extensión permitida,
 inserta su contenido en un bloque de código Markdown.
 """
 encabezado = "#" * nivel
 nombre_carpeta = os.path.basename(ruta_raiz) or ruta_raiz
 lineas = [f"{encabezado} {nombre_carpeta}"]

 try:
 entradas = sorted(os.listdir(ruta_raiz))
 except Exception as e:
 lineas.append(f"Error listando la carpeta: {e}")
 return "\n".join(lineas)

 # Archivos de este nivel
 for entrada in entradas:
 ruta_completa = os.path.join(ruta_raiz, entrada)
 if os.path.isfile(ruta_completa) and entrada.lower().endswith(EXTENSIONES_PERMITIDAS):
 ext = os.path.splitext(entrada)[1].lower()
 lang = LANG_MAP.get(ext, "")
 lineas.append(f"**{entrada}**")
 try:
 with open(ruta_completa, "r", encoding="utf-8", errors="ignore") as f:
 contenido = f.read()
 except Exception as e:
 contenido = f"Error al leer el archivo: {e}"
 lineas.append(f"```{lang}")
 lineas.append(contenido)
 lineas.append("```")

 # Subcarpetas (excluyendo las no deseadas)
 for entrada in entradas:
 ruta_completa = os.path.join(ruta_raiz, entrada)
 if os.path.isdir(ruta_completa) and entrada not in CARPETAS_EXCLUIDAS:
 lineas.append(generar_reporte_intercalado(ruta_completa, nivel + 1))

 return "\n".join(lineas)

def generar_reporte(ruta_origen: str) -> str:
 """
 Genera el contenido completo del reporte en Markdown:
 - Árbol de directorios
 - Código intercalado
 """
 arbol = construir_mapa_directorios(ruta_origen)
 intercalado = generar_reporte_intercalado(ruta_origen)

 partes = []
 partes.append("# Reporte de proyecto\n")
 partes.append("## Estructura del proyecto\n")
 partes.append("```\n" + arbol + "\n```\n")
 partes.append("## Código (intercalado)\n")
 partes.append(intercalado)
 return "\n".join(partes)

# =========================
# CLI
# =========================
def main():
 parser = argparse.ArgumentParser(
 description="Genera un reporte Markdown de una carpeta de código (árbol + contenidos)."
 )
 parser.add_argument("source_root", help="Carpeta origen a inspeccionar")
 parser.add_argument("dest_folder", help="Carpeta destino donde guardar el reporte")
 args = parser.parse_args()

 source_root = os.path.abspath(args.source_root)
 dest_folder = os.path.abspath(args.dest_folder)

 if not os.path.isdir(source_root):
 print(f"[ERROR] La carpeta origen no existe o no es un directorio: {source_root}", file=sys.stderr)
 sys.exit(1)

 os.makedirs(dest_folder, exist_ok=True)

 base_name = os.path.basename(source_root.rstrip(os.sep)) or "reporte"
 timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
 out_name = f"{base_name}_{timestamp}.md"
 out_path = os.path.join(dest_folder, out_name)

 try:
 contenido = generar_reporte(source_root)
 with open(out_path, "w", encoding="utf-8") as f:
 f.write(contenido)
 except KeyboardInterrupt:
 print("\n[INTERRUPT] Proceso cancelado por el usuario.", file=sys.stderr)
 sys.exit(130)
 except Exception as e:
 print(f"[ERROR] No se pudo generar o guardar el reporte: {e}", file=sys.stderr)
 sys.exit(2)

 print(f"[OK] Reporte generado: {out_path}")

if __name__ == "__main__":
 main()

```
## anterior2
**app.py**
```python
import os
import re
import json
from datetime import datetime
from flask import Flask, request, jsonify, render_template, send_from_directory
import sqlite3

# Optional MySQL
try:
 import pymysql
except Exception:
 pymysql = None

app = Flask(__name__, template_folder="templates", static_folder="static")

# =========================
# Configuración / Constantes
# =========================
CONFIG_FILE = "config.json"

EXTENSIONES_PERMITIDAS_DEF = [
 ".html", ".css", ".js", ".php", ".py", ".java", ".sql",
 ".c", ".cpp", ".cu", ".h", ".json", ".xml", ".md"
]
CARPETAS_EXCLUIDAS_DEF = [
 ".git", "node_modules", "vendor", "venv", "__pycache__",
 "modelo_entrenado", ".venv", "__pycache__"
]

EXTENSIONES_PERMITIDAS = tuple(EXTENSIONES_PERMITIDAS_DEF)
CARPETAS_EXCLUIDAS = set(CARPETAS_EXCLUIDAS_DEF)

# =========================
# Persistencia de config
# =========================
def cargar_config():
 cfg = {}
 if os.path.exists(CONFIG_FILE):
 try:
 with open(CONFIG_FILE, "r", encoding="utf-8") as f:
 cfg = json.load(f)
 except Exception:
 cfg = {}
 cfg.setdefault("ultima_carpeta_codigo", "")
 cfg.setdefault("ultima_carpeta_guardar", "")
 cfg.setdefault("ultima_carpeta_sqlite", "")
 cfg.setdefault("sqlite_file", "")
 cfg.setdefault("mysql", {"server": "", "user": "", "password": "", "database": ""})
 cfg.setdefault("extensiones_permitidas", EXTENSIONES_PERMITIDAS_DEF)
 cfg.setdefault("carpetas_excluidas", CARPETAS_EXCLUIDAS_DEF)
 cfg.setdefault("mostrar_bienvenida", True)
 return cfg

def guardar_config(new_values: dict):
 cfg = cargar_config()
 cfg.update(new_values)
 with open(CONFIG_FILE, "w", encoding="utf-8") as f:
 json.dump(cfg, f, indent=4, ensure_ascii=False)
 _aplicar_config_a_variables(cfg)
 return cfg

def _aplicar_config_a_variables(cfg):
 global EXTENSIONES_PERMITIDAS, CARPETAS_EXCLUIDAS
 exts = cfg.get("extensiones_permitidas", EXTENSIONES_PERMITIDAS_DEF)
 exts_norm = []
 for e in exts:
 e = e.strip()
 if not e:
 continue
 if not e.startswith("."):
 e = "." + e
 exts_norm.append(e.lower())
 EXTENSIONES_PERMITIDAS = tuple(sorted(set(exts_norm)))
 excl = cfg.get("carpetas_excluidas", CARPETAS_EXCLUIDAS_DEF)
 CARPETAS_EXCLUIDAS = set([c.strip() for c in excl if c.strip()])

cfg = cargar_config()
_aplicar_config_a_variables(cfg)

# =========================
# Núcleo de análisis
# =========================
def construir_mapa_directorios(ruta_raiz):
 lineas = []
 raiz_abs = os.path.abspath(ruta_raiz)
 lineas.append(raiz_abs)

 def interno(dir_path, prefijo=""):
 try:
 entradas = sorted(os.listdir(dir_path))
 except Exception:
 return
 entradas = [
 e for e in entradas
 if not (os.path.isdir(os.path.join(dir_path, e)) and e in CARPETAS_EXCLUIDAS)
 ]
 for i, entrada in enumerate(entradas):
 ruta_completa = os.path.join(dir_path, entrada)
 conector = "└── " if i == len(entradas) - 1 else "├── "
 lineas.append(prefijo + conector + entrada)
 if os.path.isdir(ruta_completa):
 extension = " " if i == len(entradas) - 1 else "│ "
 interno(ruta_completa, prefijo + extension)
 interno(ruta_raiz)
 return "\n".join(lineas)

def generar_reporte_intercalado(ruta_raiz, nivel=1):
 lang_map = {
 ".html": "html", ".css": "css", ".js": "js", ".php": "php",
 ".py": "python", ".java": "java", ".sql": "sql", ".c": "c",
 ".cpp": "cpp", ".cu": "cuda", ".h": "c", ".json": "json",
 ".xml": "xml", ".md": "markdown",
 }
 lineas = []
 nombre_carpeta = os.path.basename(ruta_raiz) if os.path.basename(ruta_raiz) else ruta_raiz
 encabezado = "#" * nivel
 lineas.append(f"{encabezado} {nombre_carpeta}")

 try:
 entradas = sorted(os.listdir(ruta_raiz))
 except Exception as e:
 lineas.append(f"Error listando la carpeta: {e}")
 return "\n".join(lineas)

 for entrada in entradas:
 ruta_completa = os.path.join(ruta_raiz, entrada)
 if os.path.isfile(ruta_completa) and entrada.lower().endswith(EXTENSIONES_PERMITIDAS):
 extension = os.path.splitext(entrada)[1].lower()
 lenguaje = lang_map.get(extension, "")
 lineas.append(f"**{entrada}**")
 try:
 with open(ruta_completa, "r", encoding="utf-8", errors="ignore") as f:
 contenido = f.read()
 except Exception as e:
 contenido = f"Error al leer el archivo: {e}"
 lineas.append(f"```{lenguaje}")
 lineas.append(contenido)
 lineas.append("```")

 for entrada in entradas:
 ruta_completa = os.path.join(ruta_raiz, entrada)
 if os.path.isdir(ruta_completa) and entrada not in CARPETAS_EXCLUIDAS:
 lineas.append(generar_reporte_intercalado(ruta_completa, nivel + 1))

 return "\n".join(lineas)

def analizar_sqlite(db_path):
 detalles = [f"SQLite: {db_path}"]
 try:
 conn = sqlite3.connect(db_path)
 cur = conn.cursor()
 cur.execute("SELECT name FROM sqlite_master WHERE type='table';")
 tablas = [t[0] for t in cur.fetchall()]
 for t in tablas:
 detalles.append(f" Tabla: {t}")
 cur.execute(f"PRAGMA table_info({t});")
 for col in cur.fetchall():
 detalles.append(f" Columna: {col[1]} ({col[2]})")
 conn.close()
 except Exception:
 return None
 return "\n".join(detalles)

def analizar_mysql(servidor, usuario, contrasena, bd):
 if pymysql is None:
 return None
 detalles = [f"MySQL en {servidor} - {bd}"]
 try:
 conn = pymysql.connect(host=servidor, user=usuario, password=contrasena, database=bd)
 cur = conn.cursor()
 cur.exec