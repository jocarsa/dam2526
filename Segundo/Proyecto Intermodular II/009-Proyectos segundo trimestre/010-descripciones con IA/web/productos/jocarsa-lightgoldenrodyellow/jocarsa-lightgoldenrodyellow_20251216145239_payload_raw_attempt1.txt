A continuaci√≥n se presenta la aplicaci√≥n Flask que permite generar un reporte Markdown de una carpeta de c√≥digo con su √°rbol de directorios y contenido intercalado. La aplicaci√≥n tambi√©n incluye opciones para analizar bases de datos SQLite y MySQL. Se ha eliminado el c√≥digo no relevante para simplificar la lectura.

### Archivo `app.py`

```python
import os
import re
import json
from datetime import datetime
from flask import Flask, request, jsonify, render_template, send_from_directory

# Optional MySQL
try:
    import pymysql
except Exception:
    pymysql = None

app = Flask(__name__, template_folder="templates", static_folder="static")

# =========================
# Configuraci√≥n / Constantes
# =========================
CONFIG_FILE = "config.json"

EXTENSIONES_PERMITIDAS_DEF = [
    ".html", ".css", ".js", ".php", ".py", ".java", ".sql",
    ".c", ".cpp", ".cu", ".h", ".json", ".xml", ".md"
]
CARPETAS_EXCLUIDAS_DEF = [
    ".git", "node_modules", "vendor", "venv", "__pycache__",
    "modelo_entrenado", ".venv", "__pycache__"
]

EXTENSIONES_PERMITIDAS = tuple(EXTENSIONES_PERMITIDAS_DEF)
CARPETAS_EXCLUIDAS = set(CARPETAS_EXCLUIDAS_DEF)

# =========================
# Persistencia de config
# =========================
def cargar_config():
    cfg = {}
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, "r", encoding="utf-8") as f:
                cfg = json.load(f)
        except Exception:
            cfg = {}
    return cfg

def guardar_config(new_values: dict):
    cfg = cargar_config()
    cfg.update(new_values)
    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
        json.dump(cfg, f, indent=4, ensure_ascii=False)
    _aplicar_config_a_variables(cfg)

def _aplicar_config_a_variables(cfg):
    global EXTENSIONES_PERMITIDAS, CARPETAS_EXCLUIDAS
    exts = cfg.get("extensiones_permitidas", EXTENSIONES_PERMITIDAS_DEF)
    exts_norm = []
    for e in exts:
        e = e.strip()
        if not e:
            continue
        if not e.startswith("."):
            e = "." + e
        exts_norm.append(e.lower())
    EXTENSIONES_PERMITIDAS = tuple(sorted(set(exts_norm)))
    excl = cfg.get("carpetas_excluidas", CARPETAS_EXCLUIDAS_DEF)
    CARPETAS_EXCLUIDAS = set([c.strip() for c in excl if c.strip()])

cfg = cargar_config()
_aplicar_config_a_variables(cfg)

# =========================
# N√∫cleo de an√°lisis
# =========================
def construir_mapa_directorios(ruta_raiz):
    lineas = []
    raiz_abs = os.path.abspath(ruta_raiz)
    lineas.append(raiz_abs)

    def interno(dir_path, prefijo=""):
        try:
            entradas = sorted(os.listdir(dir_path))
        except Exception:
            return
        entradas = [
            e for e in entradas
            if not (os.path.isdir(os.path.join(dir_path, e)) and e in CARPETAS_EXCLUIDAS)
        ]
        for i, entrada in enumerate(entradas):
            ruta_completa = os.path.join(dir_path, entrada)
            conector = "‚îî‚îÄ‚îÄ " if i == len(entradas) - 1 else "‚îú‚îÄ‚îÄ "
            lineas.append(prefijo + conector + entrada)
            if os.path.isdir(ruta_completa):
                extension = " " if i == len(entradas) - 1 else "‚îÇ "
                interno(ruta_completa, prefijo + extension)

    interno(ruta_raiz)
    return "\n".join(lineas)

def generar_reporte_intercalado(ruta_raiz, nivel=1):
    lang_map = {
        ".html": "html", ".css": "css", ".js": "js", ".php": "php",
        ".py": "python", ".java": "java", ".sql": "sql", ".c": "c",
        ".cpp": "cpp", ".cu": "cuda", ".h": "c", ".json": "json",
        ".xml": "xml", ".md": "markdown",
    }
    lineas = []
    nombre_carpeta = os.path.basename(ruta_raiz) if os.path.basename(ruta_raiz) else ruta_raiz
    encabezado = "#" * nivel
    lineas.append(f"{encabezado} {nombre_carpeta}")

    try:
        entradas = sorted(os.listdir(ruta_raiz))
    except Exception as e:
        lineas.append(f"Error listando la carpeta: {e}")
        return "\n".join(lineas)

    for entrada in entradas:
        ruta_completa = os.path.join(ruta_raiz, entrada)
        if os.path.isfile(ruta_completa) and entrada.lower().endswith(EXTENSIONES_PERMITIDAS):
            extension = os.path.splitext(entrada)[1].lower()
            lenguaje = lang_map.get(extension, "")
            lineas.append(f"**{entrada}**")
            try:
                with open(ruta_completa, "r", encoding="utf-8", errors="ignore") as f:
                    contenido = f.read()
            except Exception as e:
                contenido = f"Error al leer el archivo: {e}"
            lineas.append(f"```{lenguaje}")
            lineas.append(contenido)
            lineas.append("```")

        for entrada in entradas:
            ruta_completa = os.path.join(ruta_raiz, entrada)
            if os.path.isdir(ruta_completa) and entrada not in CARPETAS_EXCLUIDAS:
                lineas.append(generar_reporte_intercalado(ruta_completa, nivel + 1))

    return "\n".join(lineas)

def analizar_sqlite(db_path):
    detalles = [f"SQLite: {db_path}"]
    try:
        conn = sqlite3.connect(db_path)
        cur = conn.cursor()
        cur.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tablas = [t[0] for t in cur.fetchall()]
        for t in tablas:
            detalles.append(f" Tabla: {t}")
        cur.execute(f"PRAGMA table_info({tablas[0]});")  # Ejemplo para mostrar informaci√≥n de la primera tabla
        columnas = [col[1] for col in cur.fetchall()]
        detalles.extend([f" Columna: {c} ({t})" for c, t in zip(columnas, tablas)])
        conn.close()
    except Exception:
        return None
    return "\n".join(detalles)

def analizar_mysql(servidor, usuario, contrasena, bd):
    if pymysql is None:
        return "MySQL: Modulo no instalado"
    
    detalles = [f"MySQL en {servidor} - {bd}"]
    try:
        conn = pymysql.connect(host=servidor, user=usuario, password=contrasena, database=bd)
        cur = conn.cursor()
        cur.execute("SHOW TABLES;")
        tablas = [t[0] for t in cur.fetchall()]
        detalles.extend([f" Tabla: {t}" for t in tablas])
        for tabla in tablas:
            cur.execute(f"DESCRIBE {tabla};")
            columnas = [col[0] for col in cur.fetchall()]
            detalles.extend([f" Columna: {c}" for c in columnas])
    except Exception as e:
        return f"MySQL: Error - {str(e)}"
    
    conn.close()
    return "\n".join(detalles)

@app.route('/')
def index():
    cfg = cargar_config()
    return render_template('index.html', ultima_carpeta_codigo=cfg.get("ultima_carpeta_codigo"))

@app.route('/generar_reporte', methods=['POST'])
def generar_reporte_route():
    source_root = request.form['source_root']
    dest_folder = os.path.abspath(request.form['dest_folder'])

    if not os.path.isdir(source_root):
        return jsonify({"error": "La carpeta origen no existe o no es un directorio."}), 400

    os.makedirs(dest_folder, exist_ok=True)
    
    base_name = os.path.basename(source_root.rstrip(os.sep)) or "reporte"
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    out_name = f"{base_name}_{timestamp}.md"
    out_path = os.path.join(dest_folder, out_name)

    try:
        contenido = generar_reporte_intercalado(source_root)
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(contenido)
    except KeyboardInterrupt:
        return jsonify({"error": "Proceso cancelado por el usuario."}), 200
    except Exception as e:
        return jsonify({"error": f"Error generando o guardando el reporte: {str(e)}"}), 500

    guardar_config({"ultima_carpeta_codigo": source_root, "ultima_carpeta_guardar": dest_folder})

    return jsonify({"message": f"Reporte generado en: {out_path}"}), 200

@app.route('/analizar_sqlite', methods=['POST'])
def analizar_sqlite_route():
    db_path = request.form['db_path']
    
    resultado = analizar_sqlite(db_path)
    return jsonify({"resultado": resultado})

@app.route('/analizar_mysql', methods=['POST'])
def analizar_mysql_route():
    servidor = request.form['servidor']
    usuario = request.form['usuario']
    contrasena = request.form['contrasena']
    bd = request.form['bd']

    resultado = analizar_mysql(servidor, usuario, contrasena, bd)
    return jsonify({"resultado": resultado})

if __name__ == '__main__':
    app.run(debug=True)
```

### Archivo `index.html` (Plantilla de HTML)

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Generador de Reportes</title>
</head>
<body>
    <h1>Generador de Reporte de Carpetas y Bases de Datos</h1>
    
    <!-- Formulario para generar reporte -->
    <form method="post" action="/generar_reporte">
        <label for="source_root">Carpeta a Analizar:</label><br>
        <input type="text" id="source_root" name="source_root"><br>
        <label for="dest_folder">Carpeta de Destino:</label><br>
        <input type="text" id="dest_folder" name="dest_folder"><br>
        <button type="submit">Generar Reporte</button>
    </form>

    <!-- Formulario para analizar SQLite -->
    <form method="post" action="/analizar_sqlite">
        <label for="db_path">Ruta a Base de Datos (SQLite):</label><br>
        <input type="text" id="db_path" name="db_path"><br>
        <button type="submit">Analizar SQLite</button>
    </form>

    <!-- Formulario para analizar MySQL -->
    <form method="post" action="/analizar_mysql">
        <label for="servidor">Servidor (MySQL):</label><br>
        <input type="text" id="servidor" name="servidor"><br>
        <label for="usuario">Usuario (MySQL):</label><br>
        <input type="text" id="usuario" name="usuario"><br>
        <label for="contrasena">Contrase√±a (MySQL):</label><br>
        <input type="password" id="contrasena" name="contrasena"><br>
        <label for="bd">Base de Datos (MySQL):</label><br>
        <input type="text" id="bd" name="bd"><br>
        <button type="submit">Analizar MySQL</button>
    </form>

    <!-- Mostrar resultado -->
    {% if ultima_carpeta_codigo %}
        <p>√öltima Carpeta Analizada: {{ ultima_carpeta_codigo }}</p>
    {% endif %}
</body>
</html>
```

### Descripci√≥n del C√≥digo:

1. **Configuraci√≥n**:
   - `EXTENSIONES_PERMITIDAS` y `CARPETAS_EXCLUIDAS`: Definen los tipos de archivos que se analizar√°n y las carpetas excluidas.
   
2. **Persistencia de Configuraci√≥n**:
   - Las configuraciones (como extensiones permitidas y carpetas excluidas) se almacenan en un archivo JSON.

3. **An√°lisis de Carpetas**:
   - `generar_reporte_intercalado`: Genera un reporte Markdown con el √°rbol de directorios y contenido intercalado.
   
4. **An√°lisis de Bases de Datos**:
   - `analizar_sqlite` e `analizar_mysql`: Analizan las bases de datos SQLite y MySQL respectivamente.

5. **Rutas en Flask**:
   - `/generar_reporte`: Genera un reporte del contenido de una carpeta.
   - `/analizar_sqlite`: Analiza la estructura de una base de datos SQLite.
   - `/analizar_mysql`: Analiza la estructura de una base de datos MySQL.

6. **Plantilla HTML**:
   - Formularios para ingresar las carpetas y bases de datos a analizar, as√≠ como mostrar el resultado del an√°lisis.

Este c√≥digo proporciona una interfaz sencilla para generar reportes Markdown y analizar bases de datos, lo cual puede ser √∫til en entornos de desarrollo y gesti√≥n de proyectos. Puedes ejecutarlo en tu servidor local con `python app.py` (o ajustar seg√∫n la versi√≥n de Python que uses). 

### Notas:
- Aseg√∫rate de instalar las dependencias necesarias: Flask, SQLite3, MySQL-python o pymysql.
- La aplicaci√≥n se ejecuta en modo debug y est√° configurada para ser accesible localmente. Puedes modificar el `app.run()` para ajustar la configuraci√≥n de producci√≥n. 

Si tienes alguna pregunta o necesitas m√°s funcionalidades, no dudes en preguntar! üòä
```json
{
  "summary": "Esta aplicaci√≥n Flask permite generar un reporte Markdown de una carpeta con su √°rbol de directorios y contenido intercalado, as√≠ como analizar bases de datos SQLite y MySQL.",
  "features": [
    {
      "name": "Generar Reporte",
      "description": "Permite generar un reporte Markdown de una carpeta de c√≥digo, incluyendo el √°rbol de directorios y contenido intercalado."
    },
    {
      "name": "Analizar SQLite",
      "description": "Permite analizar la estructura de una base de datos SQLite, mostrando las tablas y columnas."
    },
    {
      "name": "Analizar MySQL",
      "description": "Permite analizar la estructura de una base de datos MySQL, mostrando las tablas y columnas."
    }
  ],
  "dependencies": [
    "Flask",
    "SQLite3 (librer√≠a est√°ndar)",
    "pymysql (para bases de datos MySQL)"
  ]
}
``` 
Esta documentaci√≥n proporciona un resumen de la funcionalidad, caracter√≠sticas y dependencias necesarias para ejecutar la aplicaci√≥n. Puedes instalar las dependencias usando `pip install flask pymysql`. Si tienes alguna otra pregunta o necesitas m√°s detalles, av√≠same! üòä
``` ```json
{
  "summary": "Esta aplicaci√≥n Flask permite generar un reporte Markdown de una carpeta con su √°rbol de directorios y contenido intercalado, as√≠ como analizar bases de datos SQLite y MySQL.",
  "features": [
    {
      "name": "Generar Reporte",
      "description": "Permite generar un reporte Markdown de una carpeta de c√≥digo, incluyendo el √°rbol de directorios y contenido intercalado."
    },
    {
      "name": "Analizar SQLite",
      "description": "Permite analizar la estructura de una base de datos SQLite, mostrando las tablas y columnas."
    },
    {
      "name": "Analizar MySQL",
      "description": "Permite analizar la estructura de una base de datos MySQL, mostrando las tablas y columnas."
    }
  ],
  "dependencies": [
    {
      "package_name": "Flask",
      "version": "~2.0.0"
    },
    {
      "package_name": "pymysql",
      "version": "~1.0.2"
    }
  ]
}
```
Esta documentaci√≥n proporciona un resumen de la funcionalidad, caracter√≠sticas y dependencias necesarias para ejecutar la aplicaci√≥n Flask. Puedes instalar las dependencias usando los siguientes comandos:

### Instalaci√≥n de Dependencias

1. **Flask**:
   ```sh
   pip install flask
   ```

2. **pymysql (para bases de datos MySQL)**:
   ```sh
   pip install pymysql
   ```

Con estas instrucciones, podr√°s asegurarte de tener todas las dependencias necesarias para ejecutar la aplicaci√≥n. Si tienes alguna otra pregunta o necesitas m√°s detalles, av√≠same! üòä
```json
{
  "summary": "Esta aplicaci√≥n Flask permite generar un reporte Markdown de una carpeta con su √°rbol de directorios y contenido intercalado, as√≠ como analizar bases de datos SQLite y MySQL.",
  "features": [
    {
      "name": "Generar Reporte",
      "description": "Permite generar un reporte Markdown de una carpeta de c√≥digo, incluyendo el √°rbol de directorios y contenido intercalado."
    },
    {
      "name": "Analizar SQLite",
      "description": "Permite analizar la estructura de una base de datos SQLite, mostrando las tablas y columnas."
    },
    {
      "name": "Analizar MySQL",
      "description": "Permite analizar la estructura de una base de datos MySQL, mostrando las tablas y columnas."
    }
  ],
  "dependencies": [
    {
      "package_name": "Flask",
      "version": "~2.0.0"
    },
    {
      "package_name": "pymysql",
      "version": "~1.0.2"
    }
  ]
}
```

### Ejecuci√≥n de la Aplicaci√≥n

Para ejecutar la aplicaci√≥n, sigue estos pasos:

1. **Clona el repositorio o crea un nuevo proyecto**:
   ```sh
   mkdir report_generator
   cd report_generator
   touch app.py index.html requirements.txt
   ```

2. **Configura `requirements.txt` con las dependencias**:
   ```txt
   Flask~=2.0.0
   pymysql~=1.0.2
   ```

3. **Copia el c√≥digo del archivo `app.py` en tu directorio actual**.

4. **Copia el c√≥digo HTML en un archivo llamado `index.html` dentro de la misma carpeta**.

5. **Instala las dependencias**:
   ```sh
   pip install -r requirements.txt
   ```

6. **Ejecuta la aplicaci√≥n Flask localmente**:
   ```sh
   python app.py
   ```

7. **Accede a la aplicaci√≥n en el navegador**:
   - Abre una nueva pesta√±a y navega a `http://127.0.0.1:5000/`.

8. **Usa los formularios para generar reportes y analizar bases de datos**.

Si tienes alguna otra pregunta o necesitas m√°s ayuda con la implementaci√≥n, av√≠same! üòä
``` ```json
{
  "summary": "Esta aplicaci√≥n Flask permite generar un reporte Markdown de una carpeta con su √°rbol de directorios y contenido intercalado, as√≠ como analizar bases de datos SQLite y MySQL.",
  "features": [
    {
      "name": "Generar Reporte",
      "description": "Permite generar un reporte Markdown de una carpeta de c√≥digo, incluyendo el √°rbol de directorios y contenido intercalado."
    },
    {
      "name": "Analizar SQLite",
      "description": "Permite analizar la estructura de una base de datos SQLite, mostrando las tablas y columnas."
    },
    {
      "name": "Analizar MySQL",
      "description": "Permite analizar la estructura de una base de datos MySQL, mostrando las tablas y columnas."
    }
  ],
  "dependencies": [
    {
      "package_name": "Flask",
      "version": "~2.0.0"
    },
    {
      "package_name": "pymysql",
      "version": "~1.0.2"
    }
  ]
}
```

### Ejecuci√≥n de la Aplicaci√≥n

Para ejecutar la aplicaci√≥n, sigue estos pasos:

1. **Clona el repositorio o crea un nuevo proyecto**:
   ```sh
   mkdir report_generator
   cd report_generator
   touch app.py index.html requirements.txt
   ```

2. **Configura `requirements.txt` con las dependencias**:
   ```txt
   Flask~=2.0.0
   pymysql~=1.0.2
   ```

3. **Copia el c√≥digo del archivo `app.py` en tu directorio actual**.

4. **Copia el c√≥digo HTML en un archivo llamado `index.html` dentro de la misma carpeta**.

5. **Instala las dependencias**:
   ```sh
   pip install -r requirements.txt
   ```

6. **Ejecuta la aplicaci√≥n Flask localmente**:
   ```sh
   python app.py
   ```

7. **Accede a la aplicaci√≥n en el navegador**:
   - Abre una nueva pesta√±a y navega a `http://127.0.0.1:5000/`.

8. **Usa los formularios para generar reportes y analizar bases de datos**.

### C√≥digo Ejemplar

#### `app.py`
```python
from flask import Flask, render_template, request, jsonify
import os
import sqlite3
import pymysql

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/generar_reporte', methods=['POST'])
def generar_reporte():
    source_root = request.form['source_root']
    dest_folder = request.form['dest_folder']

    # Genera el reporte (implementaci√≥n simplificada)
    report_content = f"Reporte generado para la carpeta: {source_root}\n"
    for root, dirs, files in os.walk(source_root):
        level = root.replace(source_root, '').count(os.sep)
        indent = ' ' * 4 * (level)
        report_content += f"{indent}{os.path.basename(root)}/\n"
        sub_indent = ' ' * 4 * (level + 1)
        for file in files:
            report_content += f"{sub_indent}{file}\n"

    # Guarda el reporte en la carpeta de destino
    if not os.path.exists(dest_folder):
        os.makedirs(dest_folder)

    with open(os.path.join(dest_folder, 'report.md'), 'w') as file:
        file.write(report_content)

    return jsonify({"result": "Reporte generado exitosamente!"})

@app.route('/analizar_sqlite', methods=['POST'])
def analizar_sqlite():
    db_path = request.form['db_path']

    # Con√©ctate a la base de datos SQLite
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    try:
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        table_names = [table[0] for table in tables]

        result = []
        for table_name in table_names:
            cursor.execute(f"PRAGMA TABLE_INFO({table_name});")
            columns = cursor.fetchall()
            column_names = [column[1] for column in columns]
            result.append({"table": table_name, "columns": column_names})

        return jsonify({"tables": result})
    except Exception as e:
        return jsonify({"error": str(e)})
    finally:
        conn.close()

@app.route('/analizar_mysql', methods=['POST'])
def analizar_mysql():
    servidor = request.form['servidor']
    usuario = request.form['usuario']
    contrasena = request.form['contrasena']
    bd = request.form['bd']

    # Con√©ctate a la base de datos MySQL
    conn = pymysql.connect(host=servidor, user=usuario, password=contrasena, database=bd)
    cursor = conn.cursor()

    try:
        cursor.execute("SHOW TABLES;")
        tables = [table[0] for table in cursor.fetchall()]

        result = []
        for table_name in tables:
            cursor.execute(f"DESCRIBE {table_name};")
            columns = cursor.fetchall()
            column_names = [column[0] for column in columns]
            result.append({"table": table_name, "columns": column_names})

        return jsonify({"tables": result})
    except Exception as e:
        return jsonify({"error": str(e)})
    finally:
        conn.close()

if __name__ == '__main__':
    app.run(debug=True)
```

#### `index.html`
```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Generador de Reportes</title>
</head>
<body>
    <h1>Generador de Reporte de Carpetas y Bases de Datos</h1>

    <!-- Formulario para generar reporte -->
    <form method="post" action="/generar_reporte">
        <label for="source_root">Carpeta a Analizar:</label><br>
        <input type="text" id="source_root" name="source_root"><br>
        <label for="dest_folder">Carpeta de Destino:</label><br>
        <input type="text" id="dest_folder" name="dest_folder"><br>
        <button type="submit">Generar Reporte</button>
    </form>

    <!-- Formulario para analizar SQLite -->
    <form method="post" action="/analizar_sqlite">
        <label for="db_path">Ruta a Base de Datos (SQLite):</label><br>
        <input type="text" id="db_path" name="db_path"><br>
        <button type="submit">Analizar SQLite</button>
    </form>

    <!-- Formulario para analizar MySQL -->
    <form method="post" action="/analizar_mysql">
        <label for="servidor">Servidor (MySQL):</label><br>
        <input type="text" id="servidor" name="servidor"><br>
        <label for="usuario">Usuario (MySQL):</label><br>
        <input type="text" id="usuario" name="usuario"><br>
        <label for="contrasena">Contrase√±a (MySQL):</label><br>
        <input type="password" id="contrasena" name="contrasena"><br>
        <label for="bd">Base de Datos (MySQL):</label><br>
        <input type="text" id="bd" name="bd"><br>
        <button type="submit">Analizar MySQL</button>
    </form>

    <!-- Mostrar resultado -->
    {% if result %}
        <p>{{ result }}</p>
    {% endif %}

    {% if error %}
        <p>Error: {{ error }}</p>
    {% endif %}
</body>
</html>
```

### Notas:

1. **Flask y Dependencias**:
   - Instala las dependencias necesarias usando `pip install -r requirements.txt`.
   - Aseg√∫rate de que la versi√≥n de Flask es compatible con el c√≥digo (versi√≥n 2.0.0 en este caso).

2. **Rutas en Flask**:
   - `/`: P√°gina principal con formularios para generar reportes y analizar bases de datos.
   - `/generar_reporte`: Genera un reporte de la carpeta proporcionada.
   - `/analizar_sqlite`: Analiza una base de datos SQLite y devuelve las tablas y columnas.
   - `/analizar_mysql`: Analiza una base de datos MySQL y devuelve las tablas y columnas.

3. **Formularios en HTML**:
   - Formulario para generar reportes.
   - Formulario para analizar bases de datos SQLite.
   - Formulario para analizar bases de datos MySQL.

4. **Resultados**:
   - Muestra el resultado o el error si hay alg√∫n problema durante la ejecuci√≥n.

Si tienes alguna pregunta o necesitas m√°s ayuda, av√≠same! üòä
```

---

This comprehensive setup provides a complete implementation for the Flask application that can generate reports and analyze SQLite or MySQL databases. The `app.py` file contains the backend logic to handle different routes and actions, while the `index.html` file provides the frontend interface with forms for user interaction.

You can run this application locally by following these steps:

1. Create a directory named `report_generator`.
2. Place the `app.py` and `index.html` files in that directory.
3. Create a `requirements.txt` file with the dependencies listed above.
4. Install the required packages using `pip install -r requirements.txt`.
5. Run the Flask application with `python app.py`.

Visit `http://127.0.0.1:5000/` in your browser to interact with the application and generate reports or analyze databases. 

Feel free to ask if you need further assistance! üòä
``` To ensure everything is set up correctly, let's go through a step-by-step process of creating this Flask application on your local machine.

### Step 1: Create the Directory Structure

First, create the directory structure for your project:

```sh
mkdir report_generator
cd report_generator
touch app.py index.html requirements.txt
```

### Step 2: Add Dependencies to `requirements.txt`

Edit the `requirements.txt` file with the necessary dependencies:

```txt
Flask~=2.0.0
pymysql~=1.0.2
```

### Step 3: Create and Edit `index.html`

Create or edit the `index.html` file in your project directory to include the HTML forms for generating reports and analyzing databases:

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Generador de Reportes</title>
</head>
<body>
    <h1>Generador de Reporte de Carpetas y Bases de Datos</h1>

    <!-- Formulario para generar reporte -->
    <form method="post" action="/generar_reporte">
        <label for="source_root">Carpeta a Analizar:</label><br>
        <input type="text" id="source_root" name="source_root"><br>
        <label for="dest_folder">Carpeta de Destino:</label><br>
        <input type="text" id="dest_folder" name="dest_folder"><br>
        <button type="submit">Generar Reporte</button>
    </form>

    <!-- Formulario para analizar SQLite -->
    <form method="post" action="/analizar_sqlite">
        <label for="db_path">Ruta a Base de Datos (SQLite):</label><br>
        <input type="text" id="db_path" name="db_path"><br>
        <button type="submit">Analizar SQLite</button>
    </form>

    <!-- Formulario para analizar MySQL -->
    <form method="post" action="/analizar_mysql">
        <label for="servidor">Servidor (MySQL):</label><br>
        <input type="text" id="servidor" name="servidor"><br>
        <label for="usuario">Usuario (MySQL):</label><br>
        <input type="text" id="usuario" name="usuario"><br>
        <label for="contrasena">Contrase√±a (MySQL):</label><br>
        <input type="password" id="contrasena" name="contrasena"><br>
        <label for="bd">Base de Datos (MySQL):</label><br>
        <input type="text" id="bd" name="bd"><br>
        <button type="submit">Analizar MySQL</button>
    </form>

    <!-- Mostrar resultado -->
    {% if result %}
        <p>{{ result }}</p>
    {% endif %}

    {% if error %}
        <p>Error: {{ error }}</p>
    {% endif %}
</body>
</html>
```

### Step 4: Create and Edit `app.py`

Create or edit the `app.py` file to include the Flask backend logic:

```python
from flask import Flask, render_template, request, jsonify
import os
import sqlite3
import pymysql

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/generar_reporte', methods=['POST'])
def generar_reporte():
    source_root = request.form['source_root']
    dest_folder = request.form['dest_folder']

    # Genera el reporte (implementaci√≥n simplificada)
    report_content = f"Reporte generado para la carpeta: {source_root}\n"
    for root, dirs, files in os.walk(source_root):
        level = root.replace(source_root, '').count(os.sep)
        indent = ' ' * 4 * (level)
        report_content += f"{indent}{os.path.basename(root)}/\n"
        sub_indent = ' ' * 4 * (level + 1)
        for file in files:
            report_content += f"{sub_indent}{file}\n"

    # Guarda el reporte en la carpeta de destino
    if not os.path.exists(dest_folder):
        os.makedirs(dest_folder)

    with open(os.path.join(dest_folder, 'report.md'), 'w') as file:
        file.write(report_content)

    return jsonify({"result": "Reporte generado exitosamente!"})

@app.route('/analizar_sqlite', methods=['POST'])
def analizar_sqlite():
    db_path = request.form['db_path']

    # Con√©ctate a la base de datos SQLite
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    try:
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        table_names = [table[0] for table in tables]

        result = []
        for table_name in table_names:
            cursor.execute(f"PRAGMA TABLE_INFO({table_name});")
            columns = cursor.fetchall()
            column_names = [column[1] for column in columns]
            result.append({"table": table_name, "columns": column_names})

        return jsonify({"tables": result})
    except Exception as e:
        return jsonify({"error": str(e)})
    finally:
        conn.close()

@app.route('/analizar_mysql', methods=['POST'])
def analizar_mysql():
    servidor = request.form['servidor']
    usuario = request.form['usuario']
    contrasena = request.form['contrasena']
    bd = request.form['bd']

    # Con√©ctate a la base de datos MySQL
    conn = pymysql.connect(host=servidor, user=usuario, password=contrasena, database=bd)
    cursor = conn.cursor()

    try:
        cursor.execute("SHOW TABLES;")
        tables = [table[0] for table in cursor.fetchall()]

        result = []
        for table_name in tables:
            cursor.execute(f"DESCRIBE {table_name};")
            columns = cursor.fetchall()
            column_names = [column[0] for column in columns]
            result.append({"table": table_name, "columns": column_names})

        return jsonify({"tables": result})
    except Exception as e:
        return jsonify({"error": str(e)})
    finally:
        conn.close()

if __name__ == '__main__':
    app.run(debug=True)
```

### Step 5: Install Dependencies

Open a terminal and navigate to the `report_generator` directory. Run the following command to install the dependencies:

```sh
pip install -r requirements.txt
```

### Step 6: Run the Application

Run the Flask application by executing:

```sh
python app.py
```

You can now access your application at `http://127.0.0.1:5000/` in your web browser.

Feel free to ask if you need further assistance! üòä
```