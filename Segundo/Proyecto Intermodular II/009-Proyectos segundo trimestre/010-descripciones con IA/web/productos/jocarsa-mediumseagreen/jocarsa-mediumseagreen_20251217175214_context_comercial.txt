TITLE: T칤tulo
H1: P치gina web

# Reporte de proyecto
## Estructura del proyecto
## C칩digo (intercalado)
# jocarsa-mediumseagreen
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
- Lee 'playlists_videos.json' (categor칤a "25/26").
- Intenta player_client: android -> mweb -> tv -> web (con cookies si existen).
- Convierte .vtt a TEXTO S칍LIDO (un 칰nico p치rrafo), sin timestamps/etiquetas/roll-up.
- Crea .log cuando no hay 'es-orig'. (Opcional) Fallback a es/es-ES/es-419 si ALLOW_ES_FALLBACK=1.
# =======================
# CONFIG
# =======================
# =======================
# ---------- Limpieza VTT ----------
# ---------- Utilidades yt-dlp ----------
# Escaneo por si el extractor cambia el nombre
# cuando pides lenguajes, separa write-auto-subs y write-subs (por si hay manuales)
# ---------- Main ----------
# estricto por defecto
# fallback opcional (manual+auto)
# 1) Intentar es-orig
# 2) Fallback opcional a es/es-ES/es-419
# determinar cu치l lleg칩
# 3) Convertir VTT -> TXT s칩lido
# localizar el VTT que baj칩
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
- temarios/DAM1/*.md y temarios/DAM2/*.md
* L칤nea SIN tab = Unidad (topic label: "Unidad")
* L칤nea CON un tab = Subunidad (topic label: "Unidad: Subunidad")
- transcripts_25_26/*.txt
* Ignora cabecera hasta una l칤nea de ----- (guiones), usa el resto como cuerpo.
- Divide el listado de topics en lotes (TOPIC_BATCH).
- Para cada lote, env칤a prompt al modelo (MODEL) con el cuerpo del v칤deo.
- El modelo devuelve JSON con matches (topic, score 0..1). Se fusiona y se filtra por THRESHOLD.
- video_topic_matches.json con:
- Ollama corriendo en http://localhost:11434 (ollama serve)
- Modelo Instruct: ej. ollama pull llama3.1:8b-instruct-q4_0
- pip install requests tqdm
# -------------------- Config --------------------
# --------------- Parsers ----------------
- Unidad -> "Unidad"
- Subunidad -> "Unidad: Subunidad"
# Dedup conservando orden
# separar cabecera/cuerpo
# recortar para no saturar el contexto
# intentar sacar ID de cabecera
# --------------- Core matching ---------------
# reintentos m칤nimos
# limpiar posibles backticks accidentales
# extraer el primer bloque JSON v치lido que encontremos
# (por si el modelo devuelve algo raro, aunque hemos forzado JSON-only)
# sanitizar
# aceptamos cualquier score; el filtrado por THRESHOLD ser치 m치s tarde
# filtrar por THRESHOLD y ordenar
# dedup en listas by_topic
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
- Para v칤deos: se incluye `type:"video"` (retrocompatible si faltara).
- Para mensajes: NO hay `url`; se incluye `message` con el contenido del .txt.
# Rango de cursos igual que en index.php
# tolerante: ignora archivos que no cumplan patr칩n
# fuera de rangos definidos
# Construyo el t칤tulo estilo v칤deo: "YYYY MM DD HH MM SS <label>"
# 1) Expandir playlists de YouTube (igual que antes)
# 2) A침adir mensajes/*.txt como playlist "游띋 Mensajes" por curso
# si ya existe, a침adimos; si no, creamos
# Mezclamos y ordenamos por fecha (derivable del t칤tulo)
# No hace falta ordenar aqu칤 estrictamente; el frontend ordena por date,
# pero dejamos consistente por comodidad.
# 3) Guardar salida
# 4) Resumen
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
- Lee 'playlists_videos.json' (categor칤a "25/26").
- Prueba player_client=mweb -> tv -> web -> android (android al final por PO token).
- Prioriza subt칤tulos en espa침ol (es, es-ES, es-419, es.*).
- Si no hay espa침ol: toma el primer auto-caption disponible (p.ej. 'en').
- Como rescate final: --all-subs y luego filtra el mejor candidato.
- Convierte .vtt a texto s칩lido (un p치rrafo) sin timestamps, etiquetas, ni roll-up.
- Registra en .log los idiomas disponibles si no se consigue nada.
# =======================
# CONFIG
# =======================
# Ponemos android al final para evitar el problema del PO token si no lo usas
# Candidatos de idioma (prefijos y exactos) para espa침ol:
# Prioridad para elegir el VTT si hay varios
# variantes es.* despu칠s
# Fallback si no hay espa침ol: coger el primer idioma disponible de automatic_captions
# Si hay que caer a un auto-captions no espa침ol, prioriza en este orden
# =======================
# UTILIDADES GENERALES
# =======================
# =======================
# YT-DLP HELPERS
# =======================
# Cualquier archivo que empiece por el nombre base y tenga .es*.vtt
# yt-dlp nombra subs como "<base>.<lang>.vtt"
# "<base>.<lang>.vtt" -> extrae <lang>
# =======================
# DESCARGA PRINCIPAL (con fallback)
# =======================
# 1) prioridad preferida
# 2) si no, la primera clave disponible
# Si no hay .es*.vtt, quiz치 el idioma fue otro (fallback): busca cualquier .<lang>.vtt solicitado
# 1췈 intenta espa침ol
# 2췈 si no hay espa침ol, cualquier vtt priorizado
# === Flujo principal por clientes ===
# 1) Idiomas espa침oles exactos
# 2) Fallback: primer auto disponible (p.ej. 'en'), si est치 activado
# 3) Rescate --all-subs y luego elegir
# Segundo intento de rescate global si nada funcion칩
# =======================
# MAIN
# =======================
# 1) Descargar subt칤tulos (espa침ol o fallback)
# Para diagn칩stico: listar subs disponibles por cada client
# 2) Convertir VTT -> TEXTO S칍LIDO
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
- Lee .txt y extrae cuerpo (ignora cabecera hasta la l칤nea de guiones).
- Chunking por caracteres (con cortes suaves por oraciones).
- MAP: genera "notas" para cada chunk (en espa침ol).
- REDUCE: sintetiza un 칰nico .md did치ctico.
- Ollama ejecut치ndose en http://localhost:11434
- Un modelo Instruct disponible (p.ej., 'llama3.1:8b-instruct-q4_0')
# ============== CONFIG ==============
# ====================================
# corte por oraciones
# detectar l칤nea de guiones del header
# compactar espacios
# Opcionales que puedes ajustar:
# Estructura t칤pica: {'message': {'role':'assistant','content':'...'}, ...}
# MAP
# seguimos con los dem치s
# REDUCE
# Asegurar encabezado principal (por si el modelo no lo pone)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
- Lee .txt y extrae cuerpo (ignora cabecera hasta la l칤nea de guiones).
- Chunking por caracteres (con cortes suaves por oraciones).
- MAP: genera "notas" para cada chunk (en espa침ol) usando la API remota.
- REDUCE: sintetiza un 칰nico .md did치ctico usando la API remota.
- API remota disponible (ejemplo: https://covalently-untasked-daphne.ngrok-free.dev/api.php)
- Clave de API v치lida.
# ============== CONFIG ==============
# ====================================
# MAP
# REDUCE
# jocarsa-mediumseagreen
#temariosAcc .clickable.active{background:#effaf4;border-radius:6px}
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# EDITA ESTA LISTA con uno o varios IDs de v칤deo
# MANUALES (no generadas)
# AUTO-GENERADAS
# Idiomas a los que YouTube dice que podr칤a traducir
## data
### transcripts
## mensajes
## resumenes
## scripts
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
- Lee 'playlists_videos.json' (categor칤a "25/26").
- Intenta player_client: android -> mweb -> tv -> web (con cookies si existen).
- Convierte .vtt a TEXTO S칍LIDO (un 칰nico p치rrafo), sin timestamps/etiquetas/roll-up.
- Crea .log cuando no hay 'es-orig'. (Opcional) Fallback a es/es-ES/es-419 si ALLOW_ES_FALLBACK=1.
# =======================
# CONFIG
# =======================
# =======================
# ---------- Limpieza VTT ----------
# ---------- Utilidades yt-dlp ----------
# Escaneo por si el extractor cambia el nombre
# cuando pides lenguajes, separa write-auto-subs y write-subs (por si hay manuales)
# ---------- Main ----------
# estricto por defecto
# fallback opcional (manual+auto)
# 1) Intentar es-orig
# 2) Fallback opcional a es/es-ES/es-419
# determinar cu치l lleg칩
# 3) Convertir VTT -> TXT s칩lido
# localizar el VTT que baj칩
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
- Ollama en ejecuci칩n (http://localhost:11434)
- Modelo embeddings: nomic-embed-text (ollama pull nomic-embed-text)
- pip install requests tqdm
# Opciones
# Ollama devuelve {"embeddings": [[...], ...]}
- ("Unidad", "Unidad")
- ("Unidad: Subunidad", "Unidad: Subunidad")
# Quitar duplicados conservando orden
# Embeddings de topics
# Para cada v칤deo, computa similitud m치xima a cada topic
# embed doc (o chunks)
# mejor score contra cualquiera de los chunks
# Limpia duplicados en by_topic
# ordena por aparici칩n + 칰nico
### transcripts_25_26
## temarios
### DAM1
### DAM2
## transcripts_25_26
## transcripts_25_26_markdown
# 2025-09-11-14-03-07
## Objetivos de aprendizaje
## Temario (칤ndice)
## Conceptos clave
- Lenguajes de marcas: son herramientas para crear contenido estructurado y sem치ntico.
- HTML (Hypertext Markup Language): es el lenguaje de marcas m치s conocido, utilizado para crear p치ginas web.
- XML (Extensible Markup Language): es un lenguaje de marcas utilizado para crear documentos.
- Markdown: es un lenguaje de marcas ligero y f치cil de leer, utilizado para crear contenido en l칤nea.
## Explicaci칩n
- **HTML**: Es el lenguaje de marcas m치s conocido y ampliamente utilizado para crear p치ginas web. Permite a los desarrolladores agregar elementos como im치