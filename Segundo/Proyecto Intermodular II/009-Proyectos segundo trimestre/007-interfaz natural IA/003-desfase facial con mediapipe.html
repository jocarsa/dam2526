<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Bounce AI ‚Äì Single Radial Visualizer + Head Tracking</title>
    <style>
        :root{
            --grid-color: rgba(0,255,128,0.08);
        }

        body{
            margin:0;
            height:100vh;
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            background:
                radial-gradient(circle at 20% 20%, rgba(0,255,160,0.18), transparent 55%),
                radial-gradient(circle at 80% 80%, rgba(0,200,255,0.14), transparent 55%),
                linear-gradient(135deg, #00320f, #001109);
            color:#f5fff5;
            font-family:sans-serif;
            gap:1.5rem;
            overflow:hidden;
        }

        /* subtle tech grid overlay */
        body::before{
            content:"";
            position:fixed;
            inset:0;
            background-image:
                linear-gradient(transparent 95%, rgba(0,0,0,0.4) 100%),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px),
                linear-gradient(0deg, var(--grid-color) 1px, transparent 1px);
            background-size:
                100% 4px,
                40px 40px,
                40px 40px;
            pointer-events:none;
            mix-blend-mode:screen;
            opacity:0.5;
            z-index:-1;
        }

        #startBtn{
            padding:0.6rem 1.4rem;
            border-radius:999px;
            border:none;
            cursor:pointer;
            font-size:1rem;
            background:#e0ffe0;
            color:#064406;
            box-shadow:0 0 25px rgba(0,0,0,0.5);
            opacity:0.95;
        }

        .row{
            display:flex;
            align-items:center;
            justify-content:center;
            position:relative;
            padding:1.8rem 2.4rem;
            border-radius:1.6rem;
            background:radial-gradient(circle at 50% 0%, rgba(0,255,160,0.12), rgba(0,0,0,0.85));
            box-shadow:
                0 0 40px rgba(0,0,0,0.9),
                0 0 60px rgba(0,255,128,0.12);
        }

        canvas{
            background:#0b3d0b;
            border-radius:50%;
            box-shadow:
                0 0 40px rgba(0,0,0,0.7),
                0 0 35px rgba(0,255,160,0.18);
        }

        .labels{
            display:flex;
            justify-content:space-between;
            width:100%;
            max-width:900px;
            font-size:0.9rem;
            opacity:0.8;
        }
        .labels span{
            flex:1;
            text-align:center;
        }
        .text-row{
            max-width:900px;
            width:100%;
            display:flex;
            flex-direction:column;
            gap:0.35rem;
            font-size:0.9rem;
        }
        .bubble{
            background:rgba(0,0,0,0.35);
            padding:0.5rem 0.75rem;
            border-radius:0.5rem;
            min-height:1.4rem;
            word-break:break-word;
            border:1px solid rgba(0,255,160,0.15);
        }
        .bubble span.label{
            opacity:0.7;
            font-size:0.8rem;
            display:block;
            margin-bottom:0.2rem;
            text-transform:uppercase;
            letter-spacing:0.06em;
        }
        .labels,.text-row{
          display:none;
        }

        #video{
            display:none;
        }

        /* depth slider UI */
        #depthUI{
            position:fixed;
            top:10px;
            left:10px;
            z-index:10;
            background:rgba(0,0,0,0.65);
            border:1px solid rgba(0,255,160,0.25);
            border-radius:8px;
            padding:6px 10px;
            font-size:12px;
            display:flex;
            align-items:center;
            gap:6px;
            box-shadow:0 0 12px rgba(0,0,0,0.7);
        }
        #depthRange{
            width:130px;
        }
    </style>
</head>
<body>
    <div id="depthUI">
        <span>Depth:</span>
        <input id="depthRange" type="range" min="0" max="3" step="0.05" value="1">
        <span id="depthValue">1.00</span>
    </div>

    <button id="startBtn">Start bounce AI (mic + speech + head)</button>

    <div class="row">
        <canvas id="visualCanvas" width="400" height="400"></canvas>
    </div>

    <div class="labels">
        <span>üë§ Humano (micr√≥fono)</span>
        <span>ü§ñ ‚ÄúIA‚Äù (speech synthesis)</span>
    </div>

    <div class="text-row">
        <div class="bubble">
            <span class="label">T√∫ dices</span>
            <span id="humanText"></span>
        </div>
        <div class="bubble">
            <span class="label">La ‚ÄúIA‚Äù repite</span>
            <span id="aiText"></span>
        </div>
    </div>

    <video id="video" autoplay playsinline></video>

    <!-- MediaPipe Tasks Vision (FaceLandmarker) -->
    <script type="module">
        import {
          FaceLandmarker,
          FilesetResolver
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js";

        // -------------------- CONFIG VISUAL --------------------
        const numRings       = 24;
        const ringWidth      = 6;
        const innerRadius    = 30;
        const maxOpacity     = 0.9;
        const minOpacity     = 0.15;
        const minSpanFactor  = 0.3;
        const maxSpanFactor  = 2.0;
        const audioAngleBoost = 0.02;
        const baseBgAlpha    = 0.18;

        const baseParallaxOffset = 35; // base offset
        let offsetMultiplier = 1.0;    // slider multiplies this

        const depthRange = document.getElementById("depthRange");
        const depthValue = document.getElementById("depthValue");
        depthRange.addEventListener("input", e => {
            offsetMultiplier = parseFloat(e.target.value);
            depthValue.textContent = offsetMultiplier.toFixed(2);
        });

        // -------------------- CANVAS --------------------
        const visualCanvas = document.getElementById("visualCanvas");
        const vctx = visualCanvas.getContext("2d");
        const VW = visualCanvas.width;
        const VH = visualCanvas.height;

        // -------------------- RING CLASS --------------------
        class Ring {
            constructor(i, innerRadiusLocal, ringWidthLocal) {
                this.type = Math.floor(Math.random() * 4);
                this.r = innerRadiusLocal + i * ringWidthLocal * 1.3;
                this.baseSpan = Math.random() * Math.PI * 1.5 + Math.PI * 0.3;
                this.phase = Math.random() * Math.PI * 2;
                this.speed = (Math.random() - 0.5) * 0.01;

                this.noisePhase = Math.random() * Math.PI * 2;
                this.noiseSpeed = 0.01 + Math.random() * 0.02;
            }
        }

        const rings = [];
        for (let i = 0; i < numRings; i++) {
            rings.push(new Ring(i, innerRadius, ringWidth));
        }

        // -------------------- AUDIO ‚Äì HUMAN (MIC) --------------------
        let audioCtx = null;
        let analyserHuman = null;
        let dataArrayHuman = null;

        async function initHumanAudio() {
            if (audioCtx) return;

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            const source = audioCtx.createMediaStreamSource(stream);

            analyserHuman = audioCtx.createAnalyser();
            analyserHuman.fftSize = 1024;
            const bufferLength = analyserHuman.frequencyBinCount;
            dataArrayHuman = new Uint8Array(bufferLength);

            source.connect(analyserHuman);
        }

        function getHumanEnergyForRing(ringIndex) {
            if (!analyserHuman || !dataArrayHuman) return 0;

            analyserHuman.getByteFrequencyData(dataArrayHuman);
            const len = dataArrayHuman.length;

            const bandSize = Math.floor(len / numRings) || 1;
            const start = ringIndex * bandSize;
            const end = Math.min(start + bandSize, len);

            let sum = 0;
            for (let i = start; i < end; i++) {
                sum += dataArrayHuman[i];
            }

            const avg = sum / (end - start || 1);
            return avg / 255;
        }

        // -------------------- "IA" AUDIO ENVELOPE (FAKE ANALYSER) --------------------
        let aiSpeaking = false;
        let aiLevel = 0;
        let aiPhase = 0;

        function updateAiEnvelope() {
            const target = aiSpeaking ? 0.7 : 0.0;
            const speed  = aiSpeaking ? 0.05 : 0.03;

            aiLevel += (target - aiLevel) * speed;
            aiPhase += 0.03;
        }

        function getAiEnergyForRing(ringIndex) {
            const ring = rings[ringIndex];
            ring.noisePhase += ring.noiseSpeed * 0.5;

            const n = 0.5 + 0.5 * Math.sin(aiPhase + ringIndex * 0.7 + ring.noisePhase);
            const energy = aiLevel * (0.4 + 0.6 * n);

            return energy;
        }

        function getCombinedEnergyForRing(ringIndex) {
            const eh = getHumanEnergyForRing(ringIndex);
            const ea = getAiEnergyForRing(ringIndex);
            return Math.min(1, eh + ea);
        }

        // -------------------- SPEECH: RECOGNITION + SYNTHESIS --------------------
        const humanTextEl = document.getElementById("humanText");
        const aiTextEl    = document.getElementById("aiText");

        let recognition = null;
        let listening = false;

        function initRecognition() {
            const SpeechRec =
                window.SpeechRecognition ||
                window.webkitSpeechRecognition;

            if (!SpeechRec) {
                alert("webkitSpeechRecognition no est√° disponible en este navegador.");
                return;
            }

            recognition = new SpeechRec();
            recognition.lang = "es-ES";
            recognition.continuous = false;
            recognition.interimResults = false;

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript.trim();
                humanTextEl.textContent = transcript;
                speakAI(transcript);
            };

            recognition.onerror = (e) => {
                console.error("Recognition error:", e);
            };

            recognition.onend = () => {
                if (listening) {
                    try {
                        recognition.start();
                    } catch (e) {
                        console.warn("Restart recognition error:", e);
                    }
                }
            };
        }

        function speakAI(text) {
            if (!("speechSynthesis" in window)) {
                alert("Speech Synthesis no est√° disponible en este navegador.");
                return;
            }

            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = "es-ES";

            utter.onstart = () => {
                aiSpeaking = true;
                aiTextEl.textContent = text;
            };

            utter.onend = () => {
                aiSpeaking = false;
            };

            window.speechSynthesis.cancel();
            window.speechSynthesis.speak(utter);
        }

        // -------------------- HEAD TRACKING (FACELANDMARKER) --------------------
        const videoElement = document.getElementById("video");
        let faceLandmarker   = null;
        let runningFace      = false;
        let lastVideoTime    = -1;

        let headTargetX = 0; // [-1,1]
        let headTargetY = 0;
        let headX = 0;
        let headY = 0;

        async function initCameraForHead() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480 },
                audio: false
            });
            videoElement.srcObject = stream;
            return new Promise(resolve => {
                videoElement.onloadedmetadata = () => resolve();
            });
        }

        async function initFaceLandmarker() {
            const filesetResolver = await FilesetResolver.forVisionTasks(
              "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );

            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
              baseOptions: {
                modelAssetPath:
                  "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task"
              },
              runningMode: "VIDEO",
              numFaces: 1
            });
        }

        function getHeadCenter(landmarks) {
            if (!landmarks || !landmarks.length) return null;

            let sumX = 0;
            let sumY = 0;
            const n = landmarks.length;
            for (let i = 0; i < n; i++) {
                sumX += landmarks[i].x;
                sumY += landmarks[i].y;
            }
            const cx = sumX / n;  // [0,1]
            const cy = sumY / n;  // [0,1]
            return { x: cx, y: cy };
        }

        function processFaceResults(results) {
            if (!results.faceLandmarks || !results.faceLandmarks.length) return;

            const landmarks = results.faceLandmarks[0];
            const center = getHeadCenter(landmarks);
            if (!center) return;

            const nx = center.x * 2 - 1;   // -1 = izq, +1 = der
            const ny = center.y * 2 - 1;   // -1 = arriba, +1 = abajo

            // X ya no invertido -> cabeza izquierda -> offset negativo -> ojo a la izquierda
            headTargetX = nx;
            // Y tal y como ten√≠amos (cabeza arriba -> ojo arriba)
            headTargetY = -ny;
        }

        async function processVideoFrame() {
            if (!runningFace) return;
            const videoTime = videoElement.currentTime;
            if (videoTime === lastVideoTime) {
                requestAnimationFrame(processVideoFrame);
                return;
            }
            lastVideoTime = videoTime;

            const nowMs = performance.now();
            const results = faceLandmarker.detectForVideo(videoElement, nowMs);
            if (results) {
                processFaceResults(results);
            }

            requestAnimationFrame(processVideoFrame);
        }

        async function initHeadTracking() {
            await initCameraForHead();
            await initFaceLandmarker();
            runningFace = true;
            processVideoFrame();
        }

        // -------------------- ANIMATION DRAW --------------------
        function drawVisualizer(ctx, rings, W, H, energyFn) {
            const smoothing = 0.15;
            headX += (headTargetX - headX) * smoothing;
            headY += (headTargetY - headY) * smoothing;

            ctx.fillStyle = `rgba(0,50,0,${baseBgAlpha})`;
            ctx.fillRect(0, 0, W, H);

            for (let i = 0; i < rings.length; i++) {
                const ring = rings[i];

                const energy = energyFn(i);

                const spanFactor = minSpanFactor + (maxSpanFactor - minSpanFactor) * energy;
                const span = ring.baseSpan * spanFactor;

                ring.phase += ring.speed + energy * audioAngleBoost;

                const a1 = ring.phase;
                const a2 = ring.phase + span;

                const lw = ringWidth + energy * 4;
                const opacity = minOpacity + (maxOpacity - minOpacity) * energy;

                const strokeColor = `rgba(230,255,230,${opacity})`;
                const fillColor   = `rgba(230,255,230,${opacity * 0.7})`;

                const depthFactor = 1 - (i / (rings.length - 1));
                const maxParallaxOffset = baseParallaxOffset * offsetMultiplier;
                const offsetX = headX * maxParallaxOffset * depthFactor;
                const offsetY = headY * maxParallaxOffset * depthFactor;

                ctx.save();
                ctx.translate(W / 2 + offsetX, H / 2 + offsetY);

                switch (ring.type) {
                    case 0:
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = lw;
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a1, a2, false);
                        ctx.stroke();
                        ctx.closePath();
                        break;

                    case 1:
                        ctx.fillStyle = fillColor;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, ring.r, a1, a2, false);
                        ctx.closePath();
                        ctx.fill();
                        break;

                    case 2:
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = lw;
                        const step = 0.08;
                        for (let a = a1; a < a2; a += step) {
                            ctx.beginPath();
                            ctx.arc(0, 0, ring.r, a, a + step * 0.5, false);
                            ctx.stroke();
                            ctx.closePath();
                        }

                        ctx.lineWidth = lw + 6;
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a1, a1 + 0.03, false);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a2 - 0.03, a2, false);
                        ctx.stroke();
                        ctx.closePath();
                        break;

                    case 3:
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 1 + energy * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a1, a2, false);
                        ctx.stroke();
                        ctx.closePath();

                        const x1 = Math.cos(a1) * ring.r;
                        const y1 = Math.sin(a1) * ring.r;
                        const x2 = Math.cos(a2) * ring.r;
                        const y2 = Math.sin(a2) * ring.r;

                        const puntoR = 3 + energy * 4;
                        ctx.beginPath();
                        ctx.arc(x1, y1, puntoR, 0, Math.PI * 2, true);
                        ctx.fillStyle = strokeColor;
                        ctx.fill();
                        ctx.closePath();

                        ctx.beginPath();
                        ctx.arc(x2, y2, puntoR, 0, Math.PI * 2, true);
                        ctx.fill();
                        ctx.closePath();
                        break;
                }

                ctx.restore();
            }
        }

        function animate() {
            updateAiEnvelope();
            drawVisualizer(vctx, rings, VW, VH, getCombinedEnergyForRing);
            requestAnimationFrame(animate);
        }

        // -------------------- START BUTTON --------------------
        document.getElementById("startBtn").addEventListener("click", async () => {
            try {
                await initHumanAudio();
                await initHeadTracking();
                initRecognition();
                listening = true;
                if (recognition) {
                    recognition.start();
                }
                document.getElementById("startBtn").style.display = "none";
                animate();
            } catch (e) {
                console.error(e);
                alert("Error inicializando audio, v√≠deo o reconocimiento.");
            }
        });
    </script>
</body>
</html>

