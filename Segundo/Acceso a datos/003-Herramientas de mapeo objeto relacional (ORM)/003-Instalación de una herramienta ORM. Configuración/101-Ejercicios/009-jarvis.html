<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Radial Audio Waveform</title>
    <style>
        body{
            margin:0;
            height:100vh;
            display:flex;
            align-items:center;
            justify-content:center;
            background:#111;
            color:#eee;
            font-family:sans-serif;
            flex-direction:column;
            gap:1rem;
        }
        canvas{
            background:#111;
            border-radius:50%;
        }
        button{
            padding:0.5rem 1rem;
            border-radius:999px;
            border:none;
            cursor:pointer;
            font-size:1rem;
        }
    </style>
</head>
<body>
    <canvas id="lienzo" width="400" height="400"></canvas>
    <button id="startBtn">Start microphone</button>

    <script>
        const canvas = document.getElementById("lienzo");
        const ctx = canvas.getContext("2d");
        const W = canvas.width;
        const H = canvas.height;

        // ------------ CONFIG -------------
        const numRings       = 24;
        const ringWidth      = 6;
        const innerRadius    = 30;
        const maxOpacity     = 0.9;
        const minOpacity     = 0.15;
        const minSpanFactor  = 0.3;  // span base * this when no sound
        const maxSpanFactor  = 2.0;  // span base * this with loud sound
        const audioAngleBoost = 0.02; // how much audio pushes angle
        const baseBgAlpha    = 0.18;  // trail

        // ------------ RINGS -------------
        class Ring {
            constructor(i) {
                this.type = Math.floor(Math.random() * 4); // 0..3 como en tu ejemplo
                this.r = innerRadius + i * ringWidth * 1.3;
                this.baseSpan = Math.random() * Math.PI * 1.5 + Math.PI * 0.3;
                this.phase = Math.random() * Math.PI * 2;
                this.speed = (Math.random() - 0.5) * 0.01; // velocidad base permanente
            }
        }

        const rings = [];
        for (let i = 0; i < numRings; i++) {
            rings.push(new Ring(i));
        }

        // ------------ AUDIO -------------
        let audioCtx = null;
        let analyser = null;
        let dataArray = null;

        async function initAudio() {
            if (audioCtx) return; // ya inicializado

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            const source = audioCtx.createMediaStreamSource(stream);

            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 1024;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            source.connect(analyser);
        }

        document.getElementById("startBtn").addEventListener("click", async () => {
            try {
                await initAudio();
                document.getElementById("startBtn").style.display = "none";
                animate();
            } catch (e) {
                console.error(e);
                alert("Error accessing microphone.");
            }
        });

        // ------------ ANIMACIÓN -------------
        function getBandEnergyForRing(ringIndex) {
            if (!analyser || !dataArray) return 0;

            analyser.getByteFrequencyData(dataArray);
            const len = dataArray.length;

            // Mapeamos cada anillo a una "banda" aproximada
            const bandSize = Math.floor(len / numRings) || 1;
            const start = ringIndex * bandSize;
            const end = Math.min(start + bandSize, len);

            let sum = 0;
            for (let i = start; i < end; i++) {
                sum += dataArray[i];
            }

            const avg = sum / (end - start || 1);
            return avg / 255; // 0..1
        }

        function animate() {
            // fondo con un poco de alpha para crear "trail"
            ctx.fillStyle = `rgba(0,0,0,${baseBgAlpha})`;
            ctx.fillRect(0, 0, W, H);

            ctx.save();
            ctx.translate(W / 2, H / 2);

            for (let i = 0; i < numRings; i++) {
                const ring = rings[i];

                // energía del anillo (0..1)
                const energy = getBandEnergyForRing(i);

                // spans: siempre hay un span base, modulado por audio
                const spanFactor = minSpanFactor + (maxSpanFactor - minSpanFactor) * energy;
                const span = ring.baseSpan * spanFactor;

                // movimiento: velocidad base + un poquito según audio
                ring.phase += ring.speed + energy * audioAngleBoost;

                const a1 = ring.phase;
                const a2 = ring.phase + span;

                // grosor y opacidad modulados por audio (pero nunca 0)
                const lw = ringWidth + energy * 4;
                ctx.lineWidth = lw;
                const opacity = minOpacity + (maxOpacity - minOpacity) * energy;

                switch (ring.type) {
                    case 0: // arco simple
                        ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a1, a2, false);
                        ctx.stroke();
                        ctx.closePath();
                        break;

                    case 1: // área tipo "quesito"
                        ctx.fillStyle = `rgba(255,255,255,${opacity * 0.7})`;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, ring.r, a1, a2, false);
                        ctx.closePath();
                        ctx.fill();
                        break;

                    case 2: // muchos trocitos + puntas marcadas
                        ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                        const step = 0.08;
                        for (let a = a1; a < a2; a += step) {
                            ctx.beginPath();
                            ctx.arc(0, 0, ring.r, a, a + step * 0.5, false);
                            ctx.stroke();
                            ctx.closePath();
                        }

                        // remarcar puntas
                        ctx.lineWidth = lw + 6;
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a1, a1 + 0.03, false);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a2 - 0.03, a2, false);
                        ctx.stroke();
                        ctx.closePath();
                        break;

                    case 3: // arco fino + puntos en extremos
                        ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                        ctx.lineWidth = 1 + energy * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, ring.r, a1, a2, false);
                        ctx.stroke();
                        ctx.closePath();

                        const x1 = Math.cos(a1) * ring.r;
                        const y1 = Math.sin(a1) * ring.r;
                        const x2 = Math.cos(a2) * ring.r;
                        const y2 = Math.sin(a2) * ring.r;

                        const puntoR = 3 + energy * 4;
                        ctx.beginPath();
                        ctx.arc(x1, y1, puntoR, 0, Math.PI * 2, true);
                        ctx.fillStyle = `rgba(255,255,255,${opacity})`;
                        ctx.fill();
                        ctx.closePath();

                        ctx.beginPath();
                        ctx.arc(x2, y2, puntoR, 0, Math.PI * 2, true);
                        ctx.fill();
                        ctx.closePath();
                        break;
                }
            }

            ctx.restore();
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>

