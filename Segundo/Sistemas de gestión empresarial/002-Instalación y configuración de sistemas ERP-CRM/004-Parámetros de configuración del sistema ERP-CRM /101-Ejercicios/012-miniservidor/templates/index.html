<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Node Editor Â· Flask</title>
  <link rel="stylesheet" href="https://jocarsa.github.io/cssreset/cssreset.css">
  <style>
    :root { --nodo-w: 180px; --nodo-h: 120px; --port: 16px; }
    body{display:grid;grid-template-columns:260px 1fr 340px;grid-template-rows:auto 1fr;gap:10px;
         min-height:100vh;padding:10px;box-sizing:border-box;background:linear-gradient(135deg,#f7f8fb,#eef1f7);color:#1e2a3a;}
    header{grid-column:1/-1;display:flex;align-items:center;gap:10px;background:#fff;border:1px solid #e7e9f3;border-radius:10px;padding:10px 12px;box-shadow:0 6px 24px rgba(0,0,0,.06);}
    #tools,#console{
      background:#fff;border:1px solid #e7e9f3;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.07);
      padding:10px;display:flex;flex-direction:column;gap:10px;min-height:0;
    }
    #tools h3,#console h3{margin:0 0 6px 0;font:600 14px/1.2 system-ui;color:#31415a}
    #console pre{flex:1;background:#0f172a;color:#e5e7eb;border-radius:8px;padding:10px;overflow:auto;margin:0;font:12px/1.4 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
    .tool-card{border:1px solid #e1e6f3;border-radius:10px;padding:8px;background:linear-gradient(180deg,#fff,#fafbff);box-shadow:0 2px 10px rgba(62,96,181,.12);}
    .tool-card .btn-add{margin-top:8px;display:inline-block;padding:6px 10px;border-radius:8px;border:1px solid #b7c2e6;cursor:pointer;background:#fff;}
    .tool-desc{font-size:12px;color:#5b6b85;margin-top:2px}
    .muted{opacity:.7}

    #centro{
      position:relative; overflow:hidden; border-radius:14px;
      box-shadow:0 10px 40px rgba(0,0,0,0.18); background:#f6f6f9;
      user-select:none; touch-action:none; border:1px solid #e5e7f0; min-height:70vh;
    }
    #mundo{
      position:absolute; left:0; top:0; width:4000px; height:3000px;
      background-image: radial-gradient(circle at 1px 1px, rgba(0,0,0,0.06) 1px, transparent 1px);
      background-size: 40px 40px;
      transform-origin: 0 0;
    }
    #edges{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }

    /* Node aesthetics */
    article{
      position:absolute; left:0; top:0; width:var(--nodo-w); height:var(--nodo-h);
      border-radius:14px; background:linear-gradient(180deg, rgba(255,255,255,.9), rgba(250,251,255,.7));
      border:1px solid #dfe4ef; box-shadow: 0 12px 30px rgba(30,60,120,0.18), inset 0 1px 0 rgba(255,255,255,.6);
      cursor:grab; user-select:none; font:600 14px/1.2 ui-sans-serif, system-ui, -apple-system, "Segoe UI"; color:#2b3a55;
    }
    article .body{display:flex;flex-direction:column;gap:6px;align-items:stretch;justify-content:center;height:100%;padding:10px 10px 10px 16px}
    article .titlebar{position:absolute; left:0; top:0; right:0; height:34px; border-radius:14px 14px 10px 10px;
      background:linear-gradient(90deg,#6aa3ff,#9c7bff); box-shadow:inset 0 -1px 0 rgba(255,255,255,.35); opacity:.95;}
    article .title{position:absolute; top:8px; left:12px; font:600 12px/1 ui-sans-serif; color:white; text-shadow:0 1px 2px rgba(0,0,0,.25);}
    article.dragging{ cursor:grabbing; opacity:.95; }

    .port{
      position:absolute; width:var(--port); height:var(--port); border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #fff, #cfe0ff);
      border:1px solid #9db5ff; box-shadow: 0 0 0 2px #ffffffaa, 0 6px 14px rgba(90,120,200,.35);
      display:grid; place-items:center;
    }
    .port::after{content:""; width:6px; height:6px; border-radius:50%; background:#4a7dff; box-shadow:0 0 10px #6aa3ff;}
    .port.in  { left: calc(-.5 * var(--port)); top: 50%; transform: translateY(-50%); }
    .port.out { right: calc(-.5 * var(--port)); top: 50%; transform: translateY(-50%); }
    .port.highlight { border-color:#53e3a6; box-shadow:0 0 0 2px #eafff5, 0 0 24px rgba(83,227,166,.7); }
    .port.block { pointer-events:none; filter:grayscale(1) opacity(.6); }

    .edge-path{ fill:none; stroke:#6a86ff; stroke-width:3; filter: drop-shadow(0 2px 2px rgba(0,0,0,.15)); }
    .edge-path.bg{ stroke:#cdd8ff; stroke-width:7; opacity:.75; }
    .edge-path.preview{ stroke-dasharray:8 8; opacity:.85; }
    .edge-path.glow{ stroke:#6a86ff; stroke-width:8; filter: blur(8px); opacity:.45; }

    .btn{padding:6px 10px;border-radius:8px;border:1px solid #b7c2e6;background:#fff;cursor:pointer}
    #play{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border-radius:10px;border:1px solid #98a6d6;background:#eef2ff;cursor:pointer}
    #play:active{transform:translateY(1px)}
    #hint{position:absolute; right:10px; bottom:10px; background:rgba(255,255,255,.9); padding:.4rem .6rem; border:1px solid #dfe4ef; border-radius:8px; font:12px system-ui; box-shadow:0 8px 20px rgba(0,0,0,.08);}
    .form-row{display:flex;flex-direction:column;gap:4px}
    .form-row label{font:500 11px/1 system-ui;color:#556176}
    .form-row input{padding:6px 8px;border:1px solid #cfd7ea;border-radius:8px;background:#fff;font:12px system-ui}
    .status-ok{color:#16a34a}
    .status-bad{color:#dc2626}
  </style>
</head>
<body>
  <header>
    <button id="play">â–¶ Ejecutar grafo</button>
    <div class="muted">Pan: Ctrl + arrastrar Â· Zoom: Ctrl + rueda</div>
    <div class="muted">BASE_DIR: <code>{{ base_dir }}</code></div>
  </header>

  <section id="tools">
    <h3>Tools</h3>
    <div id="tools-list"><div class="muted">Cargando toolsâ€¦</div></div>
  </section>

  <main id="centro" aria-label="zona de trabajo">
    <div id="mundo">
      <svg id="edges" viewBox="0 0 4000 3000" preserveAspectRatio="none"></svg>
      <!-- nodos se insertan aquÃ­ -->
    </div>
    <div id="hint">Arrastra salida â†’ entrada para conectar</div>
  </main>

  <aside id="console">
    <h3>Consola</h3>
    <pre id="log">Listo.</pre>
  </aside>

  <script>
    // ======= Setup =======
    const centro = document.getElementById("centro");
    const mundo  = document.getElementById("mundo");
    const edgesSvg = document.getElementById("edges");
    const toolsList = document.getElementById("tools-list");
    const playBtn = document.getElementById("play");
    const logEl = document.getElementById("log");

    const nodos  = [];           // {id, x, y, el, type, config}
    const conexiones = [];       // {from, to, pathBg, path, glow}
    let nodoCounter = 1;
    let scale = 1, translateX = 0, translateY = 0;

    function aplicarTransform(){ mundo.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function screenToWorld(x, y){
      const rect = centro.getBoundingClientRect();
      return { x: (x - rect.left - translateX) / scale, y: (y - rect.top  - translateY) / scale };
    }
    aplicarTransform();

    function log(msg){
      const at = new Date().toLocaleTimeString();
      logEl.textContent = `[${at}] ${msg}\n` + logEl.textContent;
    }

    // ======= Tools UI =======
    let TOOLS = [];
    fetch("/api/tools").then(r=>r.json()).then(d=>{
      TOOLS = d.tools || [];
      if(!TOOLS.length){ toolsList.innerHTML = '<div class="muted">No hay tools</div>'; return; }
      toolsList.innerHTML = "";
      TOOLS.forEach(t=>{
        const card = document.createElement("div");
        card.className = "tool-card";
        card.innerHTML = `<div><strong>${t.label}</strong></div><div class="tool-desc">${t.description}</div>`;
        const btn = document.createElement("button");
        btn.className = "btn-add";
        btn.textContent = "AÃ±adir como nodo";
        btn.addEventListener("click", ()=> crearNodoTool(t));
        card.appendChild(btn);
        toolsList.appendChild(card);
      });
    });

    // ======= Node creation =======
    function crearNodoBase(x, y, title){
      const el = document.createElement("article");
      el.style.left = x + "px";
      el.style.top  = y + "px";
      el.innerHTML = `
        <div class="titlebar"></div>
        <div class="title">${title}</div>
        <div class="body"></div>
        <div class="port in"  title="Entrada"></div>
        <div class="port out" title="Salida"></div>
      `;
      mundo.appendChild(el);
      return el;
    }

    function crearNodoTool(tool){
      // Center of view in world coords
      const rect = centro.getBoundingClientRect();
      const screenX = rect.width/2, screenY = rect.height/2;
      const worldX = (screenX - translateX) / scale - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--nodo-w'))/2;
      const worldY = (screenY - translateY) / scale - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--nodo-h'))/2;

      const el = crearNodoBase(Math.round(worldX), Math.round(worldY), tool.label);
      const body = el.querySelector(".body");

      // Build config UI (for list_files -> path input)
      body.innerHTML = "";
      Object.entries(tool.config || {}).forEach(([key, cfg])=>{
        const row = document.createElement("div");
        row.className = "form-row";
        const id = `cfg_${nodoCounter}_${key}`;
        row.innerHTML = `
          <label for="${id}">${cfg.label || key}</label>
          <input id="${id}" type="text" value="${cfg.default ?? ''}" placeholder="${cfg.placeholder ?? ''}">
        `;
        body.appendChild(row);
      });

      const nodo = {
        id: `n${nodoCounter++}`,
        x: worldX, y: worldY,
        el, type: tool.type,
        config: {} // will be read from inputs on execute
      };
      el.dataset.index = (nodos.length).toString();
      nodos.push(nodo);

      // Wire: ports & drag
      const portIn  = el.querySelector('.port.in');
      const portOut = el.querySelector('.port.out');

      // Drag node (disabled when ctrl or when mousing ports)
      el.addEventListener("mousedown", (e)=>{
        if(e.ctrlKey) return;
        if(e.target.classList.contains('port')) return;
        iniciarDragNodo(e, el);
      });

      // Start connection from OUT
      portOut.addEventListener("mousedown", (e)=>{ e.stopPropagation(); iniciarConexionDesdeSalida(e, el, portOut); });
      // Finish at IN
      portIn.addEventListener("mouseup", (e)=>{ e.stopPropagation(); if(conexionEnCurso) finalizarConexionEnEntrada(el, portIn); });

      return nodo;
    }

    // ======= Drag nodes =======
    let dragging = null, startMouseX=0, startMouseY=0, startLeft=0, startTop=0;

    function iniciarDragNodo(e, el){
      e.preventDefault();
      dragging = el;
      el.classList.add("dragging");
      startMouseX = e.clientX; startMouseY = e.clientY;
      startLeft = parseFloat(el.style.left)||0; startTop = parseFloat(el.style.top)||0;
      document.addEventListener("mousemove", moverDragNodo);
      document.addEventListener("mouseup", terminarDragNodo);
    }
    function moverDragNodo(e){
      if(!dragging) return;
      const nx = startLeft + (e.clientX - startMouseX) / scale;
      const ny = startTop  + (e.clientY - startMouseY) / scale;
      posicionarEnMundo(dragging, nx, ny);
      const idx = parseInt(dragging.dataset.index,10);
      actualizarConexionesDeNodo(idx);
    }
    function terminarDragNodo(){
      if(!dragging) return;
      const idx = parseInt(dragging.dataset.index,10);
      const nodo = nodos[idx];
      nodo.x = parseFloat(dragging.style.left)||0;
      nodo.y = parseFloat(dragging.style.top)||0;
      dragging.classList.remove("dragging");
      document.removeEventListener("mousemove", moverDragNodo);
      document.removeEventListener("mouseup", terminarDragNodo);
      dragging = null;
    }
    function posicionarEnMundo(el, x, y){
      const w = parseFloat(getComputedStyle(el).width);
      const h = parseFloat(getComputedStyle(el).height);
      const maxX = mundo.clientWidth  - w;
      const maxY = mundo.clientHeight - h;
      el.style.left = Math.max(0, Math.min(x, maxX)) + "px";
      el.style.top  = Math.max(0, Math.min(y, maxY)) + "px";
    }

    // ======= Pan (Ctrl+drag) / Zoom (Ctrl+wheel) =======
    let panning=false, panStartX=0, panStartY=0, startTX=0, startTY=0;
    centro.addEventListener("mousedown",(e)=>{
      if(e.ctrlKey && e.button===0){
        panning=true; panStartX=e.clientX; panStartY=e.clientY; startTX=translateX; startTY=translateY; e.preventDefault();
      }
    });
    document.addEventListener("mousemove",(e)=>{
      if(!panning) return;
      translateX = startTX + (e.clientX - panStartX);
      translateY = startTY + (e.clientY - panStartY);
      aplicarTransform();
    });
    document.addEventListener("mouseup",()=>{ panning=false; });
    centro.addEventListener("wheel",(e)=>{
      if(!e.ctrlKey) return;
      e.preventDefault();
      const rect = centro.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const worldX = (mouseX - translateX) / scale;
      const worldY = (mouseY - translateY) / scale;
      const zoomIntensity = 0.0015;
      const newScale = clamp(scale * (1 - e.deltaY * zoomIntensity), 0.2, 3.5);
      translateX = mouseX - worldX * newScale;
      translateY = mouseY - worldY * newScale;
      scale = newScale;
      aplicarTransform();
    }, {passive:false});

    // ======= Connections (SVG) =======
    let conexionEnCurso = null; // {fromIdx, paths}
    function getPortCenterWorld(portEl){
      const r = portEl.getBoundingClientRect();
      return screenToWorld(r.left + r.width/2, r.top + r.height/2);
    }
    function crearPathsSVG(claseExtra=""){
      const pbg = document.createElementNS("http://www.w3.org/2000/svg","path");
      const p   = document.createElementNS("http://www.w3.org/2000/svg","path");
      const g   = document.createElementNS("http://www.w3.org/2000/svg","path");
      pbg.setAttribute("class", `edge-path bg ${claseExtra}`);
      p.setAttribute("class", `edge-path ${claseExtra}`);
      g.setAttribute("class", `edge-path glow ${claseExtra}`);
      edgesSvg.appendChild(g); edgesSvg.appendChild(pbg); edgesSvg.appendChild(p);
      return {pathBg:pbg, path:p, glow:g};
    }
    function makePathD(x1,y1,x2,y2){
      const dx = Math.max(40, Math.abs(x2-x1)*0.5);
      return `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`;
    }
    function drawPaths(paths, x1,y1,x2,y2){
      const d = makePathD(x1,y1,x2,y2);
      paths.pathBg.setAttribute("d", d);
      paths.path.setAttribute("d", d);
      paths.glow.setAttribute("d", d);
    }
    function iniciarConexionDesdeSalida(e, nodoEl, portOut){
      const fromIdx = parseInt(nodoEl.dataset.index,10);
      const a = getPortCenterWorld(portOut);
      const paths = crearPathsSVG("preview");
      conexionEnCurso = { fromIdx, paths };
      document.querySelectorAll('.port.in').forEach(p=>p.classList.add('highlight'));
      const move = (ev)=>{ const w = screenToWorld(ev.clientX, ev.clientY); drawPaths(paths, a.x, a.y, w.x, w.y); };
      const up = ()=>{ cancelarPreview(); document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };
      document.addEventListener('mousemove', move); document.addEventListener('mouseup', up);
    }
    function finalizarConexionEnEntrada(targetNodoEl, portIn){
      if(!conexionEnCurso) return;
      const toIdx = parseInt(targetNodoEl.dataset.index,10);
      if(conexionEnCurso.fromIdx === toIdx){ cancelarPreview(); return; }
      const fromEl = nodos[conexionEnCurso.fromIdx].el;
      const portOut = fromEl.querySelector('.port.out');
      const a = getPortCenterWorld(portOut);
      const b = getPortCenterWorld(portIn);
      const paths = crearPathsSVG();
      drawPaths(paths, a.x, a.y, b.x, b.y);
      conexiones.push({ from: conexionEnCurso.fromIdx, to: toIdx, ...paths });
      cancelarPreview();
    }
    function cancelarPreview(){
      if(!conexionEnCurso) return;
      document.querySelectorAll('.port.in').forEach(p=>p.classList.remove('highlight'));
      const {paths} = conexionEnCurso;
      [paths.path, paths.pathBg, paths.glow].forEach(el=> el.remove());
      conexionEnCurso = null;
    }
    function actualizarConexionesDeNodo(idx){
      conexiones.forEach(con=>{
        if(con.from===idx || con.to===idx){
          const fromEl = nodos[con.from].el.querySelector('.port.out');
          const toEl   = nodos[con.to].el.querySelector('.port.in');
          const a = getPortCenterWorld(fromEl);
          const b = getPortCenterWorld(toEl);
          drawPaths(con, a.x, a.y, b.x, b.y);
        }
      });
    }

    // ======= Execute Graph (Play) =======
    playBtn.addEventListener("click", async ()=>{
      // Read current config from node inputs
      nodos.forEach(n=>{
        n.config = {};
        if(n.type === "list_files"){
          // read first input as 'path'
          const input = n.el.querySelector("input");
          n.config.path = input ? input.value.trim() : "";
        }
      });

      // Build payload
      const nodesPayload = nodos.map((n,i)=>({ id:n.id, type:n.type, config:n.config }));
      const edgesPayload = conexiones.map(c=>({ from: nodos[c.from].id, to: nodos[c.to].id }));

      log("Ejecutando grafoâ€¦");
      const res = await fetch("/api/execute", {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({ nodes: nodesPayload, edges: edgesPayload })
      }).then(r=>r.json()).catch(err=>({error:String(err)}));

      if(res.error){ log("ERROR: "+res.error); return; }
      const results = res.results || {};
      Object.entries(results).forEach(([nid, r])=>{
        const node = nodos.find(n=>n.id===nid);
        if(!node) return;
        if(r.ok){
          log(`âœ” ${node.type} (${nid}) OK`);
          // For list_files, show result in node body (small preview)
          if(node.type === "list_files"){
            const body = node.el.querySelector(".body");
            const out = document.createElement("div");
            out.style.font = "12px ui-monospace";
            out.style.maxHeight = "56px";
            out.style.overflow = "auto";
            const names = (r.data.files||[]).slice(0,6).map(f => (f.is_dir ? "ðŸ“ " : "ðŸ“„ ") + f.name);
            out.textContent = names.join("\n") + ((r.data.files||[]).length>6 ? "\nâ€¦" : "");
            body.appendChild(out);
          }
        } else {
          log(`âœ– ${node.type} (${nid}) ERROR: ${r.error}`);
        }
      });
    });
  </script>
</body>
</html>

