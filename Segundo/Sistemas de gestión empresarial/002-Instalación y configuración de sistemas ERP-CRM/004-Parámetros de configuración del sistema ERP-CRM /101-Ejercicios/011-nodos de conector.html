<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Nodos con puertos, conexiones, pan & zoom</title>
  <link rel="stylesheet" href="https://jocarsa.github.io/cssreset/cssreset.css">
  <style>
    :root { --nodo-w: 140px; --nodo-h: 100px; --port: 16px; }

    body{display:flex;min-height:100vh;gap:10px;padding:10px;box-sizing:border-box;background:linear-gradient(135deg,#f7f8fb,#eef1f7);}
    #izquierda,#derecha{flex:1;display:flex;align-items:flex-start;justify-content:center;}
    #centro{
      flex:6; position:relative; overflow:hidden; border-radius:14px;
      box-shadow:0 10px 40px rgba(0,0,0,0.18); background:#f6f6f9;
      user-select:none; touch-action:none; border:1px solid #e5e7f0;
    }

    /* Mundo pan/zoom + rejilla */
    #mundo{
      position:absolute; left:0; top:0; width:4000px; height:3000px;
      background-image:
        radial-gradient(circle at 1px 1px, rgba(0,0,0,0.06) 1px, transparent 1px),
        linear-gradient(transparent,transparent);
      background-size: 40px 40px, 100% 100%;
      transform-origin: 0 0;
    }

    /* SVG de conexiones ocupando todo el mundo */
    #edges {
      position:absolute; left:0; top:0; width:100%; height:100%;
      pointer-events:none; /* las líneas no bloquean el ratón */
    }

    #derecha button{
      font-size:24px;line-height:1;padding:.25em .6em;border-radius:999px;
      border:1px solid #aeb6c7;background:#ffffffa6;backdrop-filter: blur(4px);
      cursor:pointer; box-shadow:0 6px 18px rgba(79,114,205,.25);
      transition: transform .08s ease;
    }
    #derecha button:active{ transform: scale(.96); }

    /* Nodo */
    article{
      position:absolute; left:0; top:0; width:var(--nodo-w); height:var(--nodo-h);
      border-radius:14px; background:linear-gradient(180deg, rgba(255,255,255,.9), rgba(250,251,255,.7));
      border:1px solid #dfe4ef; box-shadow:
        0 12px 30px rgba(30,60,120,0.18),
        inset 0 1px 0 rgba(255,255,255,.6);
      cursor:grab; user-select:none; display:flex; align-items:center; justify-content:center;
      font:600 14px/1.2 ui-sans-serif, system-ui, -apple-system, "Segoe UI";
      color:#2b3a55;
    }
    article::before{
      content:""; position:absolute; left:0; top:0; right:0; height:34px;
      border-radius:14px 14px 10px 10px;
      background:linear-gradient(90deg,#6aa3ff,#9c7bff);
      box-shadow:inset 0 -1px 0 rgba(255,255,255,.35);
      opacity:.9;
    }
    article span.title{
      position:absolute; top:8px; left:12px; font:600 12px/1 ui-sans-serif; color:white; text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    article.dragging{ cursor:grabbing; opacity:.95; }

    /* Puertos */
    .port{
      position:absolute; width:var(--port); height:var(--port); border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #fff, #cfe0ff);
      border:1px solid #9db5ff; box-shadow: 0 0 0 2px #ffffffaa, 0 6px 14px rgba(90,120,200,.35);
      display:grid; place-items:center;
    }
    .port::after{
      content:""; width:6px; height:6px; border-radius:50%; background:#4a7dff; box-shadow:0 0 10px #6aa3ff;
    }
    .port.in  { left: calc(-.5 * var(--port)); top: 50%; transform: translateY(-50%); }
    .port.out { right: calc(-.5 * var(--port)); top: 50%; transform: translateY(-50%); }
    .port.highlight { border-color:#53e3a6; box-shadow:0 0 0 2px #eafff5, 0 0 24px rgba(83,227,166,.7); }
    .port.block { pointer-events:none; filter:grayscale(1) opacity(.6); }

    /* Tooltip de ayuda */
    #hint{
      position:absolute; right:10px; bottom:10px; background:rgba(255,255,255,.9);
      padding:.4rem .6rem; border:1px solid #dfe4ef; border-radius:8px;
      font:12px system-ui; box-shadow:0 8px 20px rgba(0,0,0,.08);
    }

    /* Estética de aristas */
    .edge-path{
      fill:none; stroke:#6a86ff; stroke-width:3;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,.15));
    }
    .edge-path.bg{ stroke:#cdd8ff; stroke-width:7; opacity:.75; }
    .edge-path.preview{ stroke-dasharray:8 8; opacity:.85; }
    .edge-glow{ filter: blur(8px); opacity:.45; }
  </style>
</head>
<body>
  <div id="izquierda"></div>

  <div id="centro" aria-label="zona de trabajo">
    <div id="mundo">
      <svg id="edges" viewBox="0 0 4000 3000" preserveAspectRatio="none"></svg>
      <!-- nodos se insertan aquí -->
    </div>
    <div id="hint">Ctrl + rueda: zoom · Ctrl + arrastrar: pan · Arrastra salida → entrada para conectar</div>
  </div>

  <div id="derecha">
    <button id="anyadir" title="Añadir nodo">+</button>
  </div>

  <script>
    // ===== Modelo =====
    class Nodo {
      constructor(x, y, el){ this.x = x; this.y = y; this.el = el; }
    }
    const centro = document.getElementById("centro");
    const mundo  = document.getElementById("mundo");
    const edgesSvg = document.getElementById("edges");
    const boton  = document.getElementById("anyadir");
    const nodos  = [];
    const conexiones = []; // {from: idxA, to: idxB, pathBg, path, glow}

    // ===== Estado de vista (pan/zoom global) =====
    let scale = 1;
    let translateX = 0, translateY = 0;
    function aplicarTransform(){
      mundo.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }
    aplicarTransform();

    // ==== Utilidades coords
    function screenToWorld(x, y){
      const rect = centro.getBoundingClientRect();
      return { x: (x - rect.left - translateX) / scale,
               y: (y - rect.top  - translateY) / scale };
    }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    // ===== Crear nodos =====
    let nodoCounter = 1;
    function crearNodo(x, y){
      const el = document.createElement("article");
      el.style.left = x + "px";
      el.style.top  = y + "px";
      el.innerHTML = `<span class="title">Nodo ${nodoCounter++}</span>`;
      el.tabIndex = 0;

      // Puertos
      const portIn  = document.createElement('div');
      portIn.className = 'port in';
      const portOut = document.createElement('div');
      portOut.className = 'port out';
      el.appendChild(portIn);
      el.appendChild(portOut);

      // Arrastre de nodo (Ctrl anula: pan global)
      el.addEventListener("mousedown", (e) => {
        if(e.ctrlKey) return; // pan global gestiona #centro
        if(e.target.classList.contains('port')) return; // si se pincha puerto, no mover nodo
        iniciarDragNodo(e, el);
      });

      // Iniciar conexión desde salida
      portOut.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        iniciarConexionDesdeSalida(e, el, portOut);
      });

      // Recibir conexión en entrada
      portIn.addEventListener('mouseup', (e)=>{
        e.stopPropagation();
        if(conexionEnCurso) finalizarConexionEnEntrada(el, portIn);
      });

      mundo.appendChild(el);

      const nodo = new Nodo(x, y, el);
      el.dataset.index = nodos.length.toString();
      nodos.push(nodo);
      return nodo;
    }

    // ===== Drag de nodos (respeta el zoom) =====
    let dragging = null;
    let startMouseX = 0, startMouseY = 0;
    let startLeft = 0, startTop = 0;

    function iniciarDragNodo(e, el){
      e.preventDefault();
      dragging = el;
      dragging.classList.add("dragging");
      startMouseX = e.clientX;
      startMouseY = e.clientY;
      startLeft = parseFloat(dragging.style.left) || 0;
      startTop  = parseFloat(dragging.style.top)  || 0;

      document.addEventListener("mousemove", moverDragNodo);
      document.addEventListener("mouseup", terminarDragNodo);
    }

    function moverDragNodo(e){
      if(!dragging) return;
      const dxWorld = (e.clientX - startMouseX) / scale;
      const dyWorld = (e.clientY - startMouseY) / scale;
      const nx = startLeft + dxWorld;
      const ny = startTop  + dyWorld;
      posicionarEnMundo(dragging, nx, ny);
      // actualizar conexiones relacionadas
      const idx = parseInt(dragging.dataset.index, 10);
      actualizarConexionesDeNodo(idx);
    }

    function terminarDragNodo(){
      if(!dragging) return;
      dragging.classList.remove("dragging");
      const idx = parseInt(dragging.dataset.index, 10);
      const nodo = nodos[idx];
      nodo.x = parseFloat(dragging.style.left) || 0;
      nodo.y = parseFloat(dragging.style.top)  || 0;
      document.removeEventListener("mousemove", moverDragNodo);
      document.removeEventListener("mouseup", terminarDragNodo);
      dragging = null;
    }

    function posicionarEnMundo(el, x, y){
      const w = parseFloat(getComputedStyle(el).width);
      const h = parseFloat(getComputedStyle(el).height);
      const maxX = mundo.clientWidth  - w;
      const maxY = mundo.clientHeight - h;
      const nx = Math.max(0, Math.min(x, maxX));
      const ny = Math.max(0, Math.min(y, maxY));
      el.style.left = nx + "px";
      el.style.top  = ny + "px";
    }

    // ===== Pan global Ctrl + arrastrar =====
    let panning = false;
    let panStartX = 0, panStartY = 0;
    let startTX = 0, startTY = 0;

    centro.addEventListener("mousedown", (e) => {
      if(e.ctrlKey && e.button === 0){
        panning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        startTX = translateX;
        startTY = translateY;
        e.preventDefault();
      }
    });
    document.addEventListener("mousemove", (e) => {
      if(!panning) return;
      const dx = e.clientX - panStartX;
      const dy = e.clientY - panStartY;
      translateX = startTX + dx;
      translateY = startTY + dy;
      aplicarTransform();
    });
    document.addEventListener("mouseup", () => { panning = false; });

    // ===== Zoom Ctrl + rueda (centrado en cursor) =====
    centro.addEventListener("wheel", (e) => {
      if(!e.ctrlKey) return;
      e.preventDefault();

      const rect = centro.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const worldX = (mouseX - translateX) / scale;
      const worldY = (mouseY - translateY) / scale;

      const zoomIntensity = 0.0015;
      const newScale = clamp(scale * (1 - e.deltaY * zoomIntensity), 0.2, 3.5);

      translateX = mouseX - worldX * newScale;
      translateY = mouseY - worldY * newScale;
      scale = newScale;

      aplicarTransform();
    }, { passive:false });

    // ===== Conexiones =====
    let conexionEnCurso = null; // {fromIdx, pathBg, path, glow}
    function getPortCenterWorld(portEl){
      // Tomamos el centro del rectángulo en pantalla y lo convertimos a mundo
      const r = portEl.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top  + r.height/2;
      return screenToWorld(cx, cy);
    }

    function crearPathsSVG(claseExtra=""){
      const pathBg = document.createElementNS("http://www.w3.org/2000/svg","path");
      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      const glow = document.createElementNS("http://www.w3.org/2000/svg","path");
      pathBg.setAttribute("class", `edge-path bg ${claseExtra}`);
      path.setAttribute("class", `edge-path ${claseExtra}`);
      glow.setAttribute("class", `edge-path edge-glow ${claseExtra}`);
      glow.setAttribute("stroke", "#6a86ff");
      glow.setAttribute("stroke-width", "8");
      edgesSvg.appendChild(glow);
      edgesSvg.appendChild(pathBg);
      edgesSvg.appendChild(path);
      return { pathBg, path, glow };
    }

    function makePathD(x1,y1,x2,y2){
      const dx = Math.max(40, Math.abs(x2-x1)*0.5);
      const c1x = x1 + dx, c1y = y1;
      const c2x = x2 - dx, c2y = y2;
      return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
    }

    function drawPaths(paths, x1,y1,x2,y2){
      const d = makePathD(x1,y1,x2,y2);
      paths.pathBg.setAttribute("d", d);
      paths.path.setAttribute("d", d);
      paths.glow.setAttribute("d", d);
    }

    function iniciarConexionDesdeSalida(e, nodoEl, portOut){
      const fromIdx = parseInt(nodoEl.dataset.index,10);
      const {x:x1,y:y1} = getPortCenterWorld(portOut);
      const paths = crearPathsSVG("preview");
      conexionEnCurso = { fromIdx, paths };

      // Resaltar entradas
      document.querySelectorAll('.port.in').forEach(p=>p.classList.add('highlight'));

      const move = (ev)=>{
        const world = screenToWorld(ev.clientX, ev.clientY);
        drawPaths(paths, x1, y1, world.x, world.y);
      };
      const up = ()=>{
        // cancelar si no terminó en entrada
        cancelarPreview();
        document.removeEventListener('mousemove', move);
        document.removeEventListener('mouseup', up);
      };

      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', up);
    }

    function finalizarConexionEnEntrada(targetNodoEl, portIn){
      if(!conexionEnCurso) return;
      const toIdx = parseInt(targetNodoEl.dataset.index,10);
      if(conexionEnCurso.fromIdx === toIdx){ cancelarPreview(); return; } // no autoconectar

      // Crear conexión definitiva
      const fromIdx = conexionEnCurso.fromIdx;
      const fromNodoEl = nodos[fromIdx].el;
      const portOut = fromNodoEl.querySelector('.port.out');

      const {x:x1,y:y1} = getPortCenterWorld(portOut);
      const {x:x2,y:y2} = getPortCenterWorld(portIn);

      const paths = crearPathsSVG();
      drawPaths(paths, x1,y1,x2,y2);

      conexiones.push({ from: fromIdx, to: toIdx, ...paths });

      cancelarPreview();
    }

    function cancelarPreview(){
      if(!conexionEnCurso) return;
      const { paths } = conexionEnCurso;
      // quitar resaltado de entradas
      document.querySelectorAll('.port.in').forEach(p=>p.classList.remove('highlight'));
      // borrar paths preview
      [paths.path, paths.pathBg, paths.glow].forEach(el=> el.remove());
      conexionEnCurso = null;
    }

    function actualizarConexionesDeNodo(idx){
      conexiones.forEach(con=>{
        if(con.from === idx || con.to === idx){
          const fromEl = nodos[con.from].el.querySelector('.port.out');
          const toEl   = nodos[con.to].el.querySelector('.port.in');
          const a = getPortCenterWorld(fromEl);
          const b = getPortCenterWorld(toEl);
          drawPaths(con, a.x, a.y, b.x, b.y);
        }
      });
    }

    // ===== Botón añadir =====
    boton.addEventListener("click", () => {
      const rect = centro.getBoundingClientRect();
      const screenX = rect.width/2, screenY = rect.height/2;
      const worldX = (screenX - translateX) / scale - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--nodo-w'))/2;
      const worldY = (screenY - translateY) / scale - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--nodo-h'))/2;
      crearNodo(Math.round(worldX), Math.round(worldY));
    });

    // ===== Nodos demo
    crearNodo(120, 120);
    crearNodo(420, 260);
    crearNodo(760, 180);
  </script>
</body>
</html>

