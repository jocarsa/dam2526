<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OSM Buildings → Send to PHP → Save as SVG</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <style>
    html, body { height: 100%; margin: 0; }
    #app { height: 100%; display: flex; flex-direction: column; }
    #toolbar {
      padding: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: #0b1220;
      color: #e7eefc;
    }
    #toolbar input {
      width: 120px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #2b3550;
      background: #111a2f;
      color: #e7eefc;
    }
    #toolbar button {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #2b3550;
      background: #17244a;
      color: #e7eefc;
      cursor: pointer;
    }
    #toolbar button:hover { filter: brightness(1.1); }
    #status { margin-left: auto; opacity: .9; font-size: 12px; }
    #map { flex: 1; }
    .hint { font-size: 12px; opacity: .85; }
  </style>
</head>
<body>
<div id="app">
  <div id="toolbar">
    <button id="btnLocate">Geolocate</button>

    <span class="hint">BBox (lat1,lon1,lat2,lon2):</span>
    <input id="lat1" placeholder="lat1" value="39.4700">
    <input id="lon1" placeholder="lon1" value="-0.3790">
    <input id="lat2" placeholder="lat2" value="39.4755">
    <input id="lon2" placeholder="lon2" value="-0.3715">

    <button id="btnLoad">Load buildings</button>
    <button id="btnSend">Send polygons → PHP (SVG)</button>

    <span id="status">Idle</span>
  </div>

  <div id="map"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* ---------------------------
   Basic map
---------------------------- */
const map = L.map('map').setView([39.4712, -0.3768], 16);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap'
}).addTo(map);

const buildingsLayer = L.geoJSON(null, {
  style: { weight: 1, opacity: 0.9, fillOpacity: 0.25 }
}).addTo(map);

let lastPolygonsGeoJSON = null;

const statusEl = document.getElementById('status');
function setStatus(msg){ statusEl.textContent = msg; }

/* ---------------------------
   Overpass helpers
---------------------------- */
const OVERPASS_ENDPOINTS = [
  "https://overpass-api.de/api/interpreter",
  "https://overpass.kumi.systems/api/interpreter",
  "https://overpass.nchc.org.tw/api/interpreter"
];

// Simple retry with backoff and endpoint fallback
async function fetchWithFallback(urls, fetchOptions, retriesPerEndpoint = 2) {
  let lastErr = null;

  for (const url of urls) {
    for (let attempt = 0; attempt <= retriesPerEndpoint; attempt++) {
      try {
        const res = await fetch(url, fetchOptions);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      } catch (e) {
        lastErr = e;
        const backoff = 600 * (attempt + 1);
        await new Promise(r => setTimeout(r, backoff));
      }
    }
  }
  throw lastErr || new Error("Failed to fetch");
}

// Build Overpass query: buildings ways/relations in bbox
function buildOverpassQuery(bbox) {
  // bbox: [south, west, north, east]
  const [s, w, n, e] = bbox;
  return `
[out:json][timeout:60];
(
  way["building"](${s},${w},${n},${e});
  relation["building"](${s},${w},${n},${e});
);
out body;
>;
out skel qt;
`.trim();
}

function getBBoxFromInputs() {
  const lat1 = parseFloat(document.getElementById('lat1').value);
  const lon1 = parseFloat(document.getElementById('lon1').value);
  const lat2 = parseFloat(document.getElementById('lat2').value);
  const lon2 = parseFloat(document.getElementById('lon2').value);

  // Normalize to south, west, north, east
  const s = Math.min(lat1, lat2);
  const n = Math.max(lat1, lat2);
  const w = Math.min(lon1, lon2);
  const e = Math.max(lon1, lon2);

  return [s, w, n, e];
}

/* ---------------------------
   Convert Overpass JSON → GeoJSON polygons
   - ways with node lists
   - relations (multipolygon) simplified: outer rings only
---------------------------- */
function overpassToGeoJSON(data) {
  const nodes = new Map();
  const ways = new Map();
  const relations = [];

  for (const el of data.elements || []) {
    if (el.type === "node") nodes.set(el.id, [el.lat, el.lon]);
    else if (el.type === "way") ways.set(el.id, el);
    else if (el.type === "relation") relations.push(el);
  }

  function wayToRing(way) {
    const coords = [];
    for (const nid of (way.nodes || [])) {
      const ll = nodes.get(nid);
      if (!ll) continue;
      coords.push([ll[1], ll[0]]); // GeoJSON uses [lon,lat]
    }
    // Need closed ring
    if (coords.length >= 3) {
      const first = coords[0], last = coords[coords.length - 1];
      if (first[0] !== last[0] || first[1] !== last[1]) coords.push([...first]);
    }
    return coords.length >= 4 ? coords : null;
  }

  const features = [];

  // Ways directly tagged as buildings
  for (const way of ways.values()) {
    if (!way.tags || !way.tags.building) continue;
    const ring = wayToRing(way);
    if (!ring) continue;

    features.push({
      type: "Feature",
      properties: {
        osm_type: "way",
        osm_id: way.id,
        building: way.tags.building || "yes",
        name: way.tags.name || null
      },
      geometry: {
        type: "Polygon",
        coordinates: [ring]
      }
    });
  }

  // Relations (multipolygon) - take outer rings
  for (const rel of relations) {
    if (!rel.tags || !rel.tags.building) continue;

    const outers = [];
    for (const m of (rel.members || [])) {
      if (m.type !== "way") continue;
      if (m.role !== "outer") continue;
      const w = ways.get(m.ref);
      if (!w) continue;
      const ring = wayToRing(w);
      if (ring) outers.push(ring);
    }
    if (!outers.length) continue;

    // If multiple outers: MultiPolygon
    const geom = (outers.length === 1)
      ? { type: "Polygon", coordinates: [outers[0]] }
      : { type: "MultiPolygon", coordinates: outers.map(r => [r]) };

    features.push({
      type: "Feature",
      properties: {
        osm_type: "relation",
        osm_id: rel.id,
        building: rel.tags.building || "yes",
        name: rel.tags.name || null
      },
      geometry: geom
    });
  }

  return { type: "FeatureCollection", features };
}

/* ---------------------------
   Actions
---------------------------- */
document.getElementById('btnLocate').addEventListener('click', () => {
  if (!navigator.geolocation) {
    alert("Geolocation not supported.");
    return;
  }
  setStatus("Geolocating…");
  navigator.geolocation.getCurrentPosition(
    (pos) => {
      const { latitude, longitude } = pos.coords;
      map.setView([latitude, longitude], 17);
      L.circleMarker([latitude, longitude], { radius: 6 }).addTo(map);
      setStatus(`You: ${latitude.toFixed(6)}, ${longitude.toFixed(6)}`);
    },
    (err) => {
      setStatus("Geolocation error");
      alert(err.message);
    },
    { enableHighAccuracy: true, timeout: 8000, maximumAge: 0 }
  );
});

document.getElementById('btnLoad').addEventListener('click', loadBuildings);
async function loadBuildings() {
  buildingsLayer.clearLayers();
  lastPolygonsGeoJSON = null;

  // IMPORTANT: keep bbox SMALL to avoid Overpass timeouts
  const bbox = getBBoxFromInputs();
  const query = buildOverpassQuery(bbox);

  setStatus("Loading buildings from Overpass…");

  try {
    const payload = new URLSearchParams({ data: query }).toString();
    const data = await fetchWithFallback(
      OVERPASS_ENDPOINTS.map(u => `${u}?${payload}`),
      { method: "GET" },
      2
    );

    const geo = overpassToGeoJSON(data);
    lastPolygonsGeoJSON = geo;

    buildingsLayer.addData(geo);

    // zoom to layer
    const b = buildingsLayer.getBounds();
    if (b.isValid()) map.fitBounds(b.pad(0.05));

    setStatus(`Loaded polygons: ${geo.features.length}`);
  } catch (e) {
    console.error(e);
    setStatus("Overpass error (try smaller bbox)");
    alert("Overpass failed (often 504). Try a smaller BBox or retry later.\n\n" + e.message);
  }
}

document.getElementById('btnSend').addEventListener('click', sendPolygonsToPHP);
async function sendPolygonsToPHP() {
  if (!lastPolygonsGeoJSON || !lastPolygonsGeoJSON.features.length) {
    alert("No polygons loaded yet. Click 'Load buildings' first.");
    return;
  }

  // Area name used as filename prefix on server
  const areaName = "valencia_centro";

  setStatus("Sending polygons to PHP…");

  try {
    const res = await fetch("save_polygons.php", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        area: areaName,
        geojson: lastPolygonsGeoJSON
      })
    });

    const out = await res.json();
    if (!res.ok) throw new Error(out.error || `HTTP ${res.status}`);

    setStatus("Saved SVG: " + out.file);
    alert("SVG saved on server:\n" + out.file);
  } catch (e) {
    console.error(e);
    setStatus("PHP save error");
    alert("Error sending to PHP:\n" + e.message);
  }
}
</script>
</body>
</html>

