<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Staff + Durations + 4/4 + Polyphonic Piano-ish Synth</title>
  <style>
    body{font-family:system-ui;margin:24px}
    .bar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:12px}
    button, select{
      padding:10px 14px;border:1px solid #ccc;border-radius:10px;background:#fff;cursor:pointer
    }
    button:active{transform:translateY(1px)}
    .hint{opacity:.8;margin:0 0 12px}
    .wrap{max-width:1100px}
    svg{width:100%;max-width:1100px;height:auto;border:1px solid #e6e6e6;border-radius:14px;background:#fff;user-select:none}
    .small{font-size:13px;opacity:.75}
    code{background:#f3f3f3;padding:2px 6px;border-radius:6px}
  </style>
</head>
<body>
<div class="wrap">
  <div class="bar">
    <button id="enable">Enable audio</button>
    <button id="play">Play</button>
    <button id="stop">Stop</button>
    <button id="clear">Clear</button>

    <label class="small">Note value:</label>
    <select id="dur">
      <option value="whole">Whole (round)</option>
      <option value="half">Half</option>
      <option value="quarter" selected>Quarter (black)</option>
      <option value="eighth">Eighth</option>
      <option value="sixteenth">Sixteenth</option>
    </select>

    <label class="small">Tempo:</label>
    <select id="bpm">
      <option>60</option><option>80</option><option selected>100</option><option>120</option><option>140</option>
    </select>

    <span class="small">Click empty = create note (and plays). Drag existing note to move. Right-click note = delete.</span>
  </div>

  <p class="hint">
    Treble staff (G-clef), 4/4 with barlines. Notes snap to <b>lines/spaces</b> and to a <b>16th grid</b>.
    Playback is polyphonic (chords supported).
  </p>

  <svg id="score" viewBox="0 0 1100 280" role="img" aria-label="Treble staff with measures">
    <!-- drawn by JS -->
  </svg>

  <p class="small">
    Range is roughly <code>C4</code> to <code>A5</code>. Naturals only (no accidentals).
  </p>
</div>

<script>
(() => {
  // ============================================================
  // Audio: polyphonic "piano-ish" synth (sine + partials + filter)
  // ============================================================
  let ctx = null;
  let master = null;
  let stopAllScheduled = null; // function holder

  function ensureAudio() {
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (ctx.state !== "running") ctx.resume();
    if (!master) {
      master = ctx.createGain();
      master.gain.value = 0.85;
      master.connect(ctx.destination);
    }
  }

  function midiToFreq(m) {
    return 440 * Math.pow(2, (m - 69) / 12);
  }

  // One polyphonic voice per note event
  function pianoVoice(midi, when, durSec, velocity = 0.9) {
    ensureAudio();
    const t0 = Math.max(when, ctx.currentTime + 0.005);
    const f0 = midiToFreq(midi);

    // A tiny "piano click" via short noise burst
    const noiseDur = 0.02;
    const noiseBuf = ctx.createBuffer(1, Math.max(1, Math.floor(ctx.sampleRate * noiseDur)), ctx.sampleRate);
    {
      const data = noiseBuf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
    }
    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuf;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.0001, t0);
    noiseGain.gain.exponentialRampToValueAtTime(0.12 * velocity, t0 + 0.003);
    noiseGain.gain.exponentialRampToValueAtTime(0.0001, t0 + noiseDur);

    // Osc bank: sine fundamentals + a couple partials for "hammered string"
    const osc1 = ctx.createOscillator(); osc1.type = "sine";     osc1.frequency.setValueAtTime(f0, t0);
    const osc2 = ctx.createOscillator(); osc2.type = "sine";     osc2.frequency.setValueAtTime(f0 * 2.0, t0);
    const osc3 = ctx.createOscillator(); osc3.type = "triangle"; osc3.frequency.setValueAtTime(f0 * 3.0, t0);

    const mix = ctx.createGain();
    // amplitude envelope: fast attack, exponential decay, short release
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);

    const attack = 0.004;
    const decay1 = Math.min(0.18, durSec * 0.45);
    const sustain = 0.22 * velocity;
    const release = Math.min(0.10, Math.max(0.06, durSec * 0.25));

    g.gain.exponentialRampToValueAtTime(1.0 * velocity, t0 + attack);
    g.gain.exponentialRampToValueAtTime(sustain, t0 + attack + decay1);

    const relStart = t0 + Math.max(0.05, durSec - release);
    g.gain.setValueAtTime(Math.max(sustain, 0.0002), relStart);
    g.gain.exponentialRampToValueAtTime(0.0001, relStart + release);

    // low-pass filter to tame partials (more piano-like than raw sines)
    const filt = ctx.createBiquadFilter();
    filt.type = "lowpass";
    filt.frequency.setValueAtTime(Math.min(8000, Math.max(1200, f0 * 6)), t0);
    filt.Q.setValueAtTime(0.7, t0);

    // subtle detune for richness
    osc2.detune.setValueAtTime(-4, t0);
    osc3.detune.setValueAtTime(+3, t0);

    // Mix levels
    const g1 = ctx.createGain(); g1.gain.value = 0.85;
    const g2 = ctx.createGain(); g2.gain.value = 0.22;
    const g3 = ctx.createGain(); g3.gain.value = 0.10;

    osc1.connect(g1); g1.connect(mix);
    osc2.connect(g2); g2.connect(mix);
    osc3.connect(g3); g3.connect(mix);

    noise.connect(noiseGain);

    mix.connect(g);
    noiseGain.connect(g);

    g.connect(filt);
    filt.connect(master);

    // Start/stop
    noise.start(t0);
    noise.stop(t0 + noiseDur + 0.01);

    osc1.start(t0); osc2.start(t0); osc3.start(t0);
    const tStop = relStart + release + 0.03;
    osc1.stop(tStop); osc2.stop(tStop); osc3.stop(tStop);

    return { tStop };
  }

  // ============================================================
  // Staff geometry + pitch mapping
  // ============================================================
  const svg = document.getElementById("score");

  const W = 1100, H = 280;
  const marginL = 90;        // room for clef + time signature
  const marginR = 30;
  const staffTop = 85;
  const spacing = 14;        // staff line spacing
  const stepH = spacing / 2; // line/space step
  const staffBottomLineY = staffTop + 4 * spacing;

  // step 0 = E4 (bottom line). Diatonic (naturals only).
  const LETTERS = ["C","D","E","F","G","A","B"];
  const SEMI = {C:0, D:2, E:4, F:5, G:7, A:9, B:11};

  function stepToNote(step) {
    let letter = "E";
    let octave = 4;

    let idx = LETTERS.indexOf(letter);
    const dir = Math.sign(step);
    for (let i = 0; i < Math.abs(step); i++) {
      idx += dir;
      if (idx > 6) { idx = 0; octave += 1; }
      if (idx < 0) { idx = 6; octave -= 1; }
    }
    letter = LETTERS[idx];
    const midi = (octave + 1) * 12 + SEMI[letter];
    return { letter, octave, midi };
  }

  function stepToY(step) {
    return staffBottomLineY - step * stepH;
  }
  function yToStep(y) {
    return Math.round((staffBottomLineY - y) / stepH);
  }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // ============================================================
  // Time grid (4/4) with bar separators
  // - We snap X to 16th notes: 4 beats per bar, 4 subdivisions per beat => 16 per bar
  // ============================================================
  const subdivisionsPerBeat = 4; // 16th
  const beatsPerBar = 4;
  const subPerBar = beatsPerBar * subdivisionsPerBeat; // 16
  const grid = 20; // pixels per subdivision (16th)

  function snapXToGrid(x) {
    return Math.round(x / grid) * grid;
  }

  // How many bars fit
  const usableW = (W - marginR) - marginL;
  const barsVisible = Math.floor(usableW / (grid * subPerBar));
  const totalSubsVisible = barsVisible * subPerBar;

  // Convert x <-> time-subdivision index
  function xToSub(x) {
    return Math.round((x - marginL) / grid);
  }
  function subToX(sub) {
    return marginL + sub * grid;
  }

  // Durations in beats
  const durBeats = {
    whole: 4,
    half: 2,
    quarter: 1,
    eighth: 0.5,
    sixteenth: 0.25
  };
  function beatsToSeconds(beats, bpm) {
    return (60 / bpm) * beats;
  }

  // ============================================================
  // Notes model:
  // {id, sub (start time in 16th), step (pitch), dur ("quarter"...)}
  // ============================================================
  let notes = [];
  let nextId = 1;

  // ============================================================
  // SVG helpers + rendering
  // ============================================================
  function clearSVG() { while (svg.firstChild) svg.removeChild(svg.firstChild); }

  function el(name, attrs = {}) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k, v] of Object.entries(attrs)) n.setAttribute(k, String(v));
    return n;
  }

  function drawStaff() {
    // staff lines
    for (let i = 0; i < 5; i++) {
      const y = staffTop + i * spacing;
      svg.appendChild(el("line", {
        x1: marginL, y1: y, x2: W - marginR, y2: y,
        stroke: "#111", "stroke-width": 1.4
      }));
    }

    // clef
    const clef = el("text", {
      x: 18, y: staffTop + 4.2 * spacing,
      "font-size": 72, "font-family": "serif", fill: "#111"
    });
    clef.textContent = "ð„ž";
    svg.appendChild(clef);

    // time signature 4/4
    const tsTop = el("text", {
      x: 64, y: staffTop + 1.9 * spacing,
      "font-size": 28, "font-family": "serif", fill: "#111"
    });
    tsTop.textContent = "4";
    const tsBot = el("text", {
      x: 64, y: staffTop + 3.8 * spacing,
      "font-size": 28, "font-family": "serif", fill: "#111"
    });
    tsBot.textContent = "4";
    svg.appendChild(tsTop);
    svg.appendChild(tsBot);

    // beat grid (very subtle)
    for (let sub = 0; sub <= totalSubsVisible; sub++) {
      const x = subToX(sub);
      const isBeat = (sub % subdivisionsPerBeat) === 0;
      svg.appendChild(el("line", {
        x1: x, y1: staffTop - 24,
        x2: x, y2: staffTop + 4 * spacing + 24,
        stroke: "#000",
        "stroke-opacity": isBeat ? 0.06 : 0.03,
        "stroke-width": isBeat ? 1 : 1
      }));
    }

    // barlines
    for (let bar = 0; bar <= barsVisible; bar++) {
      const sub = bar * subPerBar;
      const x = subToX(sub);
      svg.appendChild(el("line", {
        x1: x, y1: staffTop - 26,
        x2: x, y2: staffTop + 4 * spacing + 26,
        stroke: "#111", "stroke-width": (bar === 0 ? 2.2 : 1.8)
      }));
    }
  }

  function drawLedgerLines(x, step) {
    const minStep = 0, maxStep = 8; // E4..F5
    const ledgers = [];
    if (step < minStep) for (let s = -2; s >= step; s -= 2) ledgers.push(s);
    if (step > maxStep) for (let s = 10; s <= step; s += 2) ledgers.push(s);
    for (const s of ledgers) {
      const y = stepToY(s);
      svg.appendChild(el("line", {
        x1: x - 18, y1: y, x2: x + 18, y2: y,
        stroke: "#111", "stroke-width": 1.4
      }));
    }
  }

  function drawFlag(xStem, yStemTop, up, count) {
    // simple stylized flag(s) using quadratic curves
    // count: 1 for eighth, 2 for sixteenth
    for (let i = 0; i < count; i++) {
      const dy = i * 8;
      const y0 = up ? (yStemTop + dy) : (yStemTop - dy);
      const path = el("path", {
        d: up
          ? `M ${xStem} ${y0} Q ${xStem+10} ${y0+4} ${xStem+6} ${y0+14} Q ${xStem+2} ${y0+22} ${xStem+14} ${y0+26}`
          : `M ${xStem} ${y0} Q ${xStem-10} ${y0-4} ${xStem-6} ${y0-14} Q ${xStem-2} ${y0-22} ${xStem-14} ${y0-26}`,
        fill: "none",
        stroke: "#111",
        "stroke-width": 2,
        "stroke-linecap": "round"
      });
      svg.appendChild(path);
    }
  }

  function drawNote(n) {
    const x = subToX(n.sub);
    const y = stepToY(n.step);

    drawLedgerLines(x, n.step);

    // Appearance based on duration
    const isWhole = n.dur === "whole";
    const isHalf = n.dur === "half";
    const isQuarter = n.dur === "quarter";
    const isEighth = n.dur === "eighth";
    const isSixteenth = n.dur === "sixteenth";

    const filled = isQuarter || isEighth || isSixteenth;

    // NOTE GROUP for dragging
    const g = el("g", { "data-note-id": n.id, cursor: "grab" });

    // head
    const head = el("ellipse", {
      cx: x, cy: y, rx: 10.5, ry: 7.2,
      fill: filled ? "#111" : "#fff",
      stroke: "#111", "stroke-width": 2,
      transform: `rotate(-18 ${x} ${y})`
    });

    // tooltip
    const { letter, octave } = stepToNote(n.step);
    const title = el("title");
    title.textContent = `${letter}${octave} (${n.dur})`;
    head.appendChild(title);

    g.appendChild(head);

    // stem/flags (not for whole)
    if (!isWhole) {
      const stemUp = n.step < 4; // below middle line -> stem up
      const xStem = stemUp ? (x + 9) : (x - 9);
      const y1 = y;
      const y2 = stemUp ? (y - 44) : (y + 44);

      const stem = el("line", {
        x1: xStem, y1: y1,
        x2: xStem, y2: y2,
        stroke: "#111", "stroke-width": 2.2,
        "stroke-linecap": "round"
      });
      g.appendChild(stem);

      if (isEighth) drawFlag(xStem, stemUp ? y2 : y2, stemUp, 1);
      if (isSixteenth) drawFlag(xStem, stemUp ? y2 : y2, stemUp, 2);
    }

    // right-click delete
    g.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      notes = notes.filter(x => x.id !== n.id);
      render();
    });

    svg.appendChild(g);
  }

  function render() {
    clearSVG();
    drawStaff();

    const sorted = [...notes].sort((a,b) => a.sub - b.sub || a.step - b.step);
    for (const n of sorted) drawNote(n);
  }

  // ============================================================
  // Hit testing + dragging
  // ============================================================
  function svgPoint(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    const m = svg.getScreenCTM().inverse();
    return pt.matrixTransform(m);
  }

  function findNoteGroup(target) {
    if (!target) return null;
    if (target.tagName === "g" && target.getAttribute("data-note-id")) return target;
    if (target.closest) return target.closest("g[data-note-id]");
    return null;
  }

  let drag = null; // {id, startSub, startStep, offsetSub, offsetStep}

  svg.addEventListener("mousedown", (e) => {
    const g = findNoteGroup(e.target);
    const p = svgPoint(e);

    if (g) {
      // start dragging existing note
      const id = Number(g.getAttribute("data-note-id"));
      const n = notes.find(nn => nn.id === id);
      if (!n) return;

      const subAtMouse = xToSub(p.x);
      const stepAtMouse = yToStep(p.y);

      drag = {
        id,
        offsetSub: n.sub - subAtMouse,
        offsetStep: n.step - stepAtMouse
      };
      g.setAttribute("cursor", "grabbing");
      return;
    }
  });

  svg.addEventListener("mousemove", (e) => {
    if (!drag) return;
    const p = svgPoint(e);

    let sub = xToSub(p.x) + drag.offsetSub;
    let step = yToStep(p.y) + drag.offsetStep;

    // snap + clamp to visible
    sub = clamp(sub, 0, totalSubsVisible);
    step = clamp(step, -2, 12);

    const n = notes.find(nn => nn.id === drag.id);
    if (!n) return;

    // keep snap to 16th grid (already subdivision units), and pitch to steps
    n.sub = Math.round(sub);
    n.step = Math.round(step);

    render();
  });

  window.addEventListener("mouseup", () => { drag = null; });

  // ============================================================
  // Create note on click (only if not dragging a note)
  // - each creation plays immediately (polyphonic)
  // ============================================================
  svg.addEventListener("click", (e) => {
    // If click was on a note group, do nothing (drag already handled)
    const g = findNoteGroup(e.target);
    if (g) return;
    if (drag) return;

    const p = svgPoint(e);

    // Compute snapped time position (subdivision index)
    let sub = xToSub(p.x);
    sub = clamp(sub, 0, totalSubsVisible);

    // Snap to staff steps
    let step = clamp(yToStep(p.y), -2, 12);

    const durSel = document.getElementById("dur").value;
    const n = { id: nextId++, sub: Math.round(sub), step: Math.round(step), dur: durSel };
    notes.push(n);
    render();

    // Play immediately (short preview based on selected duration)
    const bpm = Number(document.getElementById("bpm").value);
    const beats = durBeats[durSel] ?? 1;
    const sec = Math.min(0.9, Math.max(0.18, beatsToSeconds(beats, bpm) * 0.65));
    const { midi } = stepToNote(n.step);
    pianoVoice(midi, ctx ? ctx.currentTime : 0, sec, 0.95);
  });

  // ============================================================
  // Playback: polyphonic, scheduled by note.sub (time grid)
  // ============================================================
  function playAll() {
    if (!notes.length) return;
    ensureAudio();

    const bpm = Number(document.getElementById("bpm").value);
    const start = ctx.currentTime + 0.03;

    // group notes by start-sub (for chords)
    const bySub = new Map();
    for (const n of notes) {
      const k = n.sub;
      if (!bySub.has(k)) bySub.set(k, []);
      bySub.get(k).push(n);
    }

    const subs = [...bySub.keys()].sort((a,b) => a-b);

    // schedule, track last stop to allow "Stop" button to kill by muting master
    let lastStop = start;

    for (const sub of subs) {
      const timeBeats = sub / subdivisionsPerBeat; // 4 subs = 1 beat
      const when = start + beatsToSeconds(timeBeats, bpm);

      for (const n of bySub.get(sub)) {
        const beats = durBeats[n.dur] ?? 1;
        const durSec = beatsToSeconds(beats, bpm);

        const { midi } = stepToNote(n.step);
        const v = pianoVoice(midi, when, durSec, 0.9);
        lastStop = Math.max(lastStop, v.tStop);
      }
    }

    // Stop handler: mute master (simple + effective)
    stopAllScheduled = () => {
      if (!ctx || !master) return;
      const t = ctx.currentTime + 0.005;
      master.gain.cancelScheduledValues(t);
      master.gain.setValueAtTime(master.gain.value, t);
      master.gain.exponentialRampToValueAtTime(0.0001, t + 0.03);
      // restore after a moment for next playback
      master.gain.setValueAtTime(0.85, t + 0.08);
    };
  }

  // ============================================================
  // Buttons
  // ============================================================
  document.getElementById("enable").addEventListener("click", ensureAudio);
  document.getElementById("clear").addEventListener("click", () => { notes = []; render(); });
  document.getElementById("play").addEventListener("click", playAll);
  document.getElementById("stop").addEventListener("click", () => { if (stopAllScheduled) stopAllScheduled(); });

  // Initial render
  render();
})();
</script>
</body>
</html>

