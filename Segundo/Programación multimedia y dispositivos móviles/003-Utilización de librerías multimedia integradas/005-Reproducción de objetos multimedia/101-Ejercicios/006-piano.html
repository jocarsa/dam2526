<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pentagrama 췅 4/4 췅 Editor + Auto-guardado</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --ink:#111;
      --muted:#5b6270;
      --line:#e6e8ef;
      --shadow:0 10px 30px rgba(0,0,0,.08);
      --radius:16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;
      background:var(--bg);
      color:var(--ink);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    .app{
      width:min(1200px, 100%);
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:22px;
    }
    .top{
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom:16px;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:280px;
    }
    .title h1{
      margin:0;
      font-size:18px;
      letter-spacing:.2px;
    }
    .title p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
      max-width:56ch;
    }
    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    button, select{
      border:1px solid var(--line);
      background:#fff;
      color:var(--ink);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      cursor:pointer;
      transition:transform .05s ease, box-shadow .15s ease;
      box-shadow:0 1px 0 rgba(0,0,0,.02);
    }
    button:hover, select:hover{box-shadow:0 8px 18px rgba(0,0,0,.06)}
    button:active{transform:translateY(1px)}
    .danger{border-color:#f0c7c7}
    .danger:hover{box-shadow:0 8px 18px rgba(190,30,30,.10)}
    .pill{
      display:flex;
      gap:8px;
      align-items:center;
      padding:10px 12px;
      border:1px solid var(--line);
      background:#fff;
      border-radius:12px;
      color:var(--muted);
      font-size:13px;
      white-space:nowrap;
    }
    .stage{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:10px 0 4px;
    }
    svg{
      width:min(1100px, 100%);
      height:auto;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      user-select:none;
      touch-action:none;
    }
    .footer{
      margin-top:10px;
      color:var(--muted);
      font-size:12.5px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:space-between;
      align-items:center;
    }
    code{background:#f1f3f8;padding:2px 6px;border-radius:8px;color:#222}
    .ok{color:#1a7f37}
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div class="title">
        <h1>Pentagrama (Clave de Sol) 췅 4/4 췅 Editor con auto-guardado</h1>
        <p>
          Clic en vac칤o: crea nota (y suena). Arrastra una nota: reubica (suena al cambiar).
          Modo borrar: pulsa <b>Borrar</b> y luego clic en notas para eliminarlas.
          <span class="ok">Auto-guardado en LocalStorage.</span>
        </p>
      </div>

      <div class="controls">
        <button id="activar">Activar audio</button>
        <button id="reproducir">Reproducir</button>
        <button id="parar">Parar</button>

        <button id="modoBorrar" class="danger" title="Activa/desactiva el modo borrar">Borrar</button>
        <button id="limpiar" class="danger" title="Elimina todas las notas y borra el guardado">Limpiar todo</button>

        <div class="pill">
          <span>Figura:</span>
          <select id="dur">
            <option value="whole">Redonda</option>
            <option value="half">Blanca</option>
            <option value="quarter" selected>Negra</option>
            <option value="eighth">Corchea</option>
            <option value="sixteenth">Semicorchea</option>
          </select>
        </div>

        <div class="pill">
          <span>Tempo:</span>
          <select id="bpm">
            <option>60</option><option>80</option><option selected>100</option><option>120</option><option>140</option>
          </select>
          <span>bpm</span>
        </div>
      </div>
    </div>

    <div class="stage">
      <svg id="score" viewBox="0 0 1100 280" role="img" aria-label="Pentagrama con compases">
        <!-- Dibujado por JS -->
      </svg>
    </div>

    <div class="footer">
      <span>Cuantizaci칩n: <code>semicorcheas</code> (16 por comp치s). Agrupaci칩n: <code>por pulso</code> (beams dentro del pulso).</span>
      <span>Polifon칤a: s칤. Naturales (sin sostenidos/bemoles).</span>
    </div>
  </div>

<script>
(() => {
  // ============================================================
  // LocalStorage
  // ============================================================
  const LS_KEY = "pentagrama_editor_v2";

  // ============================================================
  // Audio: "piano" m치s rico (onda peri칩dica con arm칩nicos + resonancia + compresi칩n + reverb corta)
  // ============================================================
  let ctx = null;

  let master = null;
  let comp = null;
  let reverb = null;
  let wet = null;
  let dry = null;

  let pianoWave = null;
  let stopAllScheduled = null;

  function asegurarAudio() {
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (ctx.state !== "running") ctx.resume();

    if (!master) {
      master = ctx.createGain();
      master.gain.value = 0.92;

      // Compresi칩n suave (da "cuerpo" sin distorsionar)
      comp = ctx.createDynamicsCompressor();
      comp.threshold.value = -24;
      comp.knee.value = 24;
      comp.ratio.value = 3.2;
      comp.attack.value = 0.004;
      comp.release.value = 0.12;

      // Reverb corta tipo "sala peque침a"
      reverb = ctx.createConvolver();
      reverb.buffer = crearImpulsoReverb(1.35, 2.0);

      wet = ctx.createGain();
      dry = ctx.createGain();
      wet.gain.value = 0.16;
      dry.gain.value = 0.92;

      // Enrutado: (dry + wet) -> comp -> master -> destino
      dry.connect(comp);
      wet.connect(comp);
      comp.connect(master);
      master.connect(ctx.destination);
    }

    if (!pianoWave) pianoWave = crearOndaPiano();
  }

  function crearImpulsoReverb(segundos, decay) {
    const rate = ctx.sampleRate;
    const len = Math.max(1, Math.floor(rate * segundos));
    const buf = ctx.createBuffer(2, len, rate);
    for (let ch = 0; ch < 2; ch++) {
      const data = buf.getChannelData(ch);
      for (let i = 0; i < len; i++) {
        // ruido con ca칤da exponencial
        const t = i / len;
        const env = Math.pow(1 - t, decay);
        data[i] = (Math.random() * 2 - 1) * env;
      }
    }
    return buf;
  }

  function crearOndaPiano() {
    // Onda peri칩dica con arm칩nicos t칤picos de cuerda golpeada:
    // - fundamental fuerte, arm칩nicos decrecientes ~1/n pero con "colinas"
    // - algo de inarmonicidad perceptual: la simulamos con pesos (no con frecuencias) => suficiente para timbre
    const N = 32;
    const real = new Float32Array(N);
    const imag = new Float32Array(N);
    real[0] = 0; imag[0] = 0;

    for (let n = 1; n < N; n++) {
      // base 1/n
      let a = 1 / n;

      // refuerzos t칤picos (caja/puente) en ciertas bandas
      const bump =
        1.0
        + 0.55 * Math.exp(-Math.pow((n - 3) / 2.0, 2))
        + 0.35 * Math.exp(-Math.pow((n - 7) / 2.8, 2))
        + 0.22 * Math.exp(-Math.pow((n - 12) / 3.0, 2));

      a *= bump;

      // m치s apagado en agudos
      a *= Math.exp(-n / 18);

      // fase alternante muy leve (evita "seno puro" y da aspereza agradable)
      imag[n] = a * (n % 2 === 0 ? 0.18 : -0.12);
      real[n] = a;
    }
    return ctx.createPeriodicWave(real, imag, { disableNormalization: false });
  }

  function midiAHz(m){ return 440 * Math.pow(2, (m - 69) / 12); }

  function vozPiano(midi, cuando, durSec, vel = 0.95) {
    asegurarAudio();
    const t0 = Math.max(cuando, ctx.currentTime + 0.005);
    const f0 = midiAHz(midi);

    // 2 osciladores con onda "piano", micro-desafinaci칩n (chorus natural)
    const o1 = ctx.createOscillator();
    const o2 = ctx.createOscillator();
    o1.setPeriodicWave(pianoWave);
    o2.setPeriodicWave(pianoWave);
    o1.frequency.setValueAtTime(f0, t0);
    o2.frequency.setValueAtTime(f0, t0);
    o2.detune.setValueAtTime(+3.5, t0);

    // Ruido de martillo (muy corto, filtrado)
    const noiseDur = 0.010;
    const noiseBuf = ctx.createBuffer(1, Math.max(1, Math.floor(ctx.sampleRate * noiseDur)), ctx.sampleRate);
    {
      const data = noiseBuf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
    }
    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuf;

    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(Math.min(2200, Math.max(600, f0 * 2.2)), t0);
    hp.Q.setValueAtTime(0.9, t0);

    const gNoise = ctx.createGain();
    gNoise.gain.setValueAtTime(0.0001, t0);
    gNoise.gain.exponentialRampToValueAtTime(0.06 * vel, t0 + 0.002);
    gNoise.gain.exponentialRampToValueAtTime(0.0001, t0 + noiseDur);

    // Filtro din치mico: brillo en ataque, se cierra con la cola
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    const lpStart = Math.min(12000, Math.max(2500, f0 * 9));
    const lpEnd   = Math.min(7000,  Math.max(1400, f0 * 3.4));
    lp.frequency.setValueAtTime(lpStart, t0);
    lp.frequency.exponentialRampToValueAtTime(lpEnd, t0 + Math.min(1.1, durSec * 0.75));
    lp.Q.setValueAtTime(0.35, t0);

    // Ligera resonancia de caja (bandpass)
    const band = ctx.createBiquadFilter();
    band.type = "bandpass";
    band.frequency.setValueAtTime(Math.min(2600, Math.max(300, f0 * 2.4)), t0);
    band.Q.setValueAtTime(0.7, t0);

    // Envolvente de amplitud: ataque r치pido, ca칤da larga tipo piano
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);

    const attack = 0.004;
    // cola m치s musical: depende del registro (graves sostienen m치s)
    const reg = Math.max(0.65, Math.min(1.25, 110 / Math.max(55, f0)));
    const decay = Math.min(2.6, Math.max(0.55, durSec * 1.25 * reg));
    const release = 0.11;

    const peak = 1.00 * vel;
    const mid  = 0.16 * vel;

    g.gain.exponentialRampToValueAtTime(peak, t0 + attack);
    g.gain.exponentialRampToValueAtTime(mid,  t0 + attack + decay);

    const relStart = t0 + Math.max(0.10, durSec - release);
    g.gain.setValueAtTime(Math.max(0.02 * vel, 0.00025), relStart);
    g.gain.exponentialRampToValueAtTime(0.0001, relStart + release);

    // Mezcla y espacialidad simple (dry/wet)
    const mix = ctx.createGain();
    mix.gain.setValueAtTime(1.0, t0);

    // Pan (ligeramente) seg칰n altura: agudos un poco a la derecha
    const pan = ctx.createStereoPanner();
    const panVal = Math.max(-0.35, Math.min(0.35, (midi - 64) / 26));
    pan.pan.setValueAtTime(panVal, t0);

    // Cadena principal
    o1.connect(mix);
    o2.connect(mix);

    mix.connect(lp);
    lp.connect(band);
    band.connect(pan);
    pan.connect(g);

    // split dry/wet
    g.connect(dry);
    g.connect(reverb);
    reverb.connect(wet);

    // martillo
    noise.connect(hp);
    hp.connect(gNoise);
    gNoise.connect(dry);
    gNoise.connect(reverb);
    reverb.connect(wet);

    // start/stop
    o1.start(t0); o2.start(t0);
    noise.start(t0); noise.stop(t0 + noiseDur + 0.01);

    const tStop = relStart + release + 0.04;
    o1.stop(tStop); o2.stop(tStop);

    return { tStop };
  }

  // ============================================================
  // Pentagrama + altura (diat칩nico)
  // ============================================================
  const svg = document.getElementById("score");
  const W = 1100;
  const marginL = 90;
  const marginR = 30;
  const staffTop = 85;
  const spacing = 14;
  const stepH = spacing / 2;
  const staffBottomLineY = staffTop + 4 * spacing;

  const LETRAS = ["C","D","E","F","G","A","B"];
  const SEMI = {C:0, D:2, E:4, F:5, G:7, A:9, B:11};

  function stepANota(step) {
    let letra = "E", octava = 4;
    let idx = LETRAS.indexOf(letra);
    const dir = Math.sign(step);
    for (let i=0; i<Math.abs(step); i++) {
      idx += dir;
      if (idx > 6) { idx = 0; octava += 1; }
      if (idx < 0) { idx = 6; octava -= 1; }
    }
    letra = LETRAS[idx];
    const midi = (octava + 1) * 12 + SEMI[letra];
    return { letra, octava, midi };
  }
  function stepAY(step){ return staffBottomLineY - step * stepH; }
  function yAStep(y){ return Math.round((staffBottomLineY - y) / stepH); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // ============================================================
  // Tiempo: 4/4, semicorcheas (16 por comp치s)
  // ============================================================
  const subdivPorPulso = 4;               // 4 semicorcheas = 1 pulso
  const pulsosPorCompas = 4;
  const subdivPorCompas = subdivPorPulso * pulsosPorCompas; // 16
  const gridPx = 20;

  const usableW = (W - marginR) - marginL;
  const compasesVisibles = Math.floor(usableW / (gridPx * subdivPorCompas));
  const totalSubdivVisibles = compasesVisibles * subdivPorCompas;

  function xASubdiv(x){ return Math.round((x - marginL) / gridPx); }
  function subdivAX(sub){ return marginL + sub * gridPx; }

  const durBeats = { whole:4, half:2, quarter:1, eighth:0.5, sixteenth:0.25 };
  function beatsASeg(beats, bpm){ return (60/bpm) * beats; }

  // ============================================================
  // Notas: {id, sub, step, dur}
  // ============================================================
  let notas = [];
  let nextId = 1;
  let modoBorrar = false;

  // ============================================================
  // Guardado / carga
  // ============================================================
  function guardar() {
    const payload = { notas, nextId };
    try { localStorage.setItem(LS_KEY, JSON.stringify(payload)); } catch {}
  }
  function cargar() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const data = JSON.parse(raw);
      if (Array.isArray(data.notas)) notas = data.notas;
      if (typeof data.nextId === "number") nextId = data.nextId;
    } catch {}
  }
  function borrarGuardado() {
    try { localStorage.removeItem(LS_KEY); } catch {}
  }

  // ============================================================
  // SVG helpers + render
  // ============================================================
  function limpiarSVG(){ while (svg.firstChild) svg.removeChild(svg.firstChild); }

  function el(name, attrs={}) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
    return n;
  }

  function dibujarPentagrama() {
    for (let i=0; i<5; i++) {
      const y = staffTop + i*spacing;
      svg.appendChild(el("line",{x1:marginL,y1:y,x2:W-marginR,y2:y,stroke:"#111","stroke-width":1.4}));
    }

    const clave = el("text",{x:18,y:staffTop+4.2*spacing,"font-size":72,"font-family":"serif",fill:"#111"});
    clave.textContent="洧";
    svg.appendChild(clave);

    const tsTop = el("text",{x:64,y:staffTop+1.9*spacing,"font-size":28,"font-family":"serif",fill:"#111"});
    tsTop.textContent="4";
    const tsBot = el("text",{x:64,y:staffTop+3.8*spacing,"font-size":28,"font-family":"serif",fill:"#111"});
    tsBot.textContent="4";
    svg.appendChild(tsTop); svg.appendChild(tsBot);

    for (let sub=0; sub<=totalSubdivVisibles; sub++) {
      const x = subdivAX(sub);
      const esPulso = (sub % subdivPorPulso)===0;
      svg.appendChild(el("line",{
        x1:x,y1:staffTop-24,x2:x,y2:staffTop+4*spacing+24,
        stroke:"#000","stroke-opacity":esPulso?0.06:0.03,"stroke-width":1
      }));
    }

    for (let c=0; c<=compasesVisibles; c++) {
      const x = subdivAX(c*subdivPorCompas);
      svg.appendChild(el("line",{
        x1:x,y1:staffTop-26,x2:x,y2:staffTop+4*spacing+26,
        stroke:"#111","stroke-width":(c===0?2.2:1.8)
      }));
    }
  }

  function dibujarLineasAdicionales(x, step) {
    const minStep=0,maxStep=8;
    const ledgers=[];
    if (step<minStep) for (let s=-2;s>=step;s-=2) ledgers.push(s);
    if (step>maxStep) for (let s=10;s<=step;s+=2) ledgers.push(s);
    for (const s of ledgers) {
      const y = stepAY(s);
      svg.appendChild(el("line",{x1:x-18,y1:y,x2:x+18,y2:y,stroke:"#111","stroke-width":1.4}));
    }
  }

  // Direcci칩n plica por "grupo" (acorde en el mismo sub) + regla de media vs l칤nea central
  function stemUpPara(step, stepsGrupo) {
    if (stepsGrupo && stepsGrupo.length>1) {
      const media = stepsGrupo.reduce((a,b)=>a+b,0)/stepsGrupo.length;
      return media < 4;
    }
    return step < 4;
  }

  // ============================================================
  // Beaming mejorado:
  // - Solo dentro del pulso (ventana de 4 semicorcheas)
  // - Beam base: une notas beamables consecutivas (corchea o semicorchea)
  // - Beam secundario: solo entre semicorcheas consecutivas
  // - Pendiente suave: basada en extremos de stems (clamp)
  // - Si una corchea queda sola (o no se une), se dibuja bandera
  // ============================================================
  const BEAM_THICK = 5;
  const BEAM_GAP = 7;

  function beamable(dur){ return dur === "eighth" || dur === "sixteenth"; }
  function isSix(dur){ return dur === "sixteenth"; }

  function rectBeam(x1,y1,x2,y2,thick){
    // Rect치ngulo "girado" (paralelogramo) como path:
    // construimos normal a la direcci칩n y escalamos thick
    const dx = x2-x1, dy = y2-y1;
    const len = Math.hypot(dx,dy) || 1;
    const nx = -dy/len, ny = dx/len;
    const ox = nx * thick, oy = ny * thick;

    const d = [
      `M ${x1} ${y1}`,
      `L ${x2} ${y2}`,
      `L ${x2+ox} ${y2+oy}`,
      `L ${x1+ox} ${y1+oy}`,
      "Z"
    ].join(" ");
    return el("path",{ d, fill:"#111" });
  }

  function dibujarBeamsMejorado(notasOrdenadas, stemsInfoPorId) {
    // Agrupar por pulso
    const porPulso = new Map();
    for (const n of notasOrdenadas) {
      if (!beamable(n.dur)) continue;
      const pulso = Math.floor(n.sub / subdivPorPulso);
      if (!porPulso.has(pulso)) porPulso.set(pulso, []);
      porPulso.get(pulso).push(n);
    }

    for (const [pulso, arr] of porPulso.entries()) {
      arr.sort((a,b)=>a.sub-b.sub || a.step-b.step);

      // nos quedamos con UNA nota representativa por subdiv (si hay acorde, beaming usa la "media")
      // (visual: no resuelve voces; pero mejora coherencia)
      const bySub = new Map();
      for (const n of arr) {
        if (!bySub.has(n.sub)) bySub.set(n.sub, []);
        bySub.get(n.sub).push(n);
      }

      const reps = [];
      for (const [sub, list] of bySub.entries()) {
        // representante: media de steps, id del primero para stem info (ya existe uno)
        const avgStep = list.reduce((a,b)=>a+b.step,0)/list.length;
        reps.push({ sub, stepAvg: avgStep, ids: list.map(x=>x.id), anySix: list.some(x=>isSix(x.dur)), anyEighth: list.some(x=>x.dur==="eighth") });
      }
      reps.sort((a,b)=>a.sub-b.sub);

      // runs consecutivos dentro del pulso (gap m치ximo 2 subdiv para permitir corcheas: 0->2, 2->4 no existe dentro pulso, etc)
      // definimos continuidad si (next.sub - cur.sub) <= 2 (semicorchea adyacente o corchea a distancia 2)
      // y si hay al menos 2 puntos en el run.
      const runs = [];
      let cur = [];
      for (let i=0;i<reps.length;i++){
        if (!cur.length) { cur.push(reps[i]); continue; }
        const prev = cur[cur.length-1];
        const gap = reps[i].sub - prev.sub;
        if (gap <= 2) cur.push(reps[i]);
        else { runs.push(cur); cur=[reps[i]]; }
      }
      if (cur.length) runs.push(cur);

      for (const run of runs) {
        if (run.length < 2) continue;

        // Direcci칩n del beam seg칰n media de alturas
        const avg = run.reduce((a,b)=>a+b.stepAvg,0)/run.length;
        const up = avg < 4;

        // Obtener extremos de stems reales (si falta, saltar)
        const xys = run.map(r=>{
          // cogemos el stem de la primera nota del sub (existe en stemsInfoPorId)
          const info = stemsInfoPorId.get(r.ids[0]);
          if (!info) return null;
          const xStem = info.xStem;
          const yEnd = info.yStemEnd;
          return { xStem, yEnd };
        }).filter(Boolean);

        if (xys.length !== run.length) continue;

        // Pendiente: unir extremos (primero-칰ltimo) y clamping para no exagerar
        const first = xys[0];
        const last  = xys[xys.length-1];

        // Beam "altura base": por encima o por debajo del extremo de stem, con offset
        const off = up ? -8 : +8;
        let y1 = first.yEnd + off;
        let y2 = last.yEnd  + off;

        // Limitar pendiente m치xima
        const maxSlope = 0.35; // px por px
        const dx = (last.xStem - first.xStem) || 1;
        const slope = (y2 - y1) / dx;
        if (slope > maxSlope)  y2 = y1 + maxSlope * dx;
        if (slope < -maxSlope) y2 = y1 - maxSlope * dx;

        // Beam base: siempre que el run tenga al menos 2 notas beamables
        svg.appendChild(rectBeam(first.xStem, y1, last.xStem, y2, BEAM_THICK));

        // Beam secundario: solo entre semicorcheas consecutivas (gap==1) y solo si hay semicorcheas
        // Reglas simples:
        // - Si hay pares consecutivos de semicorcheas, dibujamos segmentos cortos.
        // - Si hay una semicorchea aislada entre corcheas, hacemos "half beam" (segmento corto hacia la derecha).
        const needsSecond = run.some(r=>r.anySix);
        if (needsSecond) {
          const y1b = up ? (y1 + BEAM_THICK + BEAM_GAP) : (y1 - BEAM_THICK - BEAM_GAP);
          const y2b = up ? (y2 + BEAM_THICK + BEAM_GAP) : (y2 - BEAM_THICK - BEAM_GAP);

          function yAt(x){
            // interpolaci칩n lineal sobre el beam base
            const t = (x - first.xStem) / dx;
            const y = y1 + (y2 - y1) * t;
            return up ? (y + BEAM_THICK + BEAM_GAP) : (y - BEAM_THICK - BEAM_GAP);
          }

          // construir segmentos
          for (let i=0;i<run.length;i++){
            const a = run[i];
            const ax = xys[i].xStem;

            const aIsSix = a.anySix;
            if (!aIsSix) continue;

            const next = run[i+1];
            const prev = run[i-1];

            const nextGap = next ? (next.sub - a.sub) : 999;
            const prevGap = prev ? (a.sub - prev.sub) : 999;

            if (next && nextGap === 1 && next.anySix) {
              // segmento entre a y next
              const bx = xys[i+1].xStem;
              svg.appendChild(rectBeam(ax, yAt(ax), bx, yAt(bx), BEAM_THICK));
            } else if (prevGap !== 1) {
              // aislada: half beam corto hacia la derecha
              const short = ax + 14;
              svg.appendChild(rectBeam(ax, yAt(ax), short, yAt(short), BEAM_THICK));
            }
          }
        }
      }
    }
  }

  function dibujarBanderasSueltas(notasOrdenadas, stemsInfoPorId) {
    // Bandera si:
    // - es corchea/semicorchea
    // - y est치 sola en su pulso (o sea, no se puede "beamear")
    // Mejora: contamos beamables por pulso y adem치s verificamos si hay vecino cercano (gap<=2).
    const porPulso = new Map();
    for (const n of notasOrdenadas) {
      if (!beamable(n.dur)) continue;
      const pulso = Math.floor(n.sub / subdivPorPulso);
      if (!porPulso.has(pulso)) porPulso.set(pulso, []);
      porPulso.get(pulso).push(n);
    }

    function banderaPath(xStem, yEnd, up, i) {
      const dy = i * 8;
      const y0 = up ? (yEnd + dy) : (yEnd - dy);
      return up
        ? `M ${xStem} ${y0} Q ${xStem+10} ${y0+4} ${xStem+6} ${y0+14} Q ${xStem+2} ${y0+22} ${xStem+14} ${y0+26}`
        : `M ${xStem} ${y0} Q ${xStem-10} ${y0-4} ${xStem-6} ${y0-14} Q ${xStem-2} ${y0-22} ${xStem-14} ${y0-26}`;
    }

    for (const [pulso, arr] of porPulso.entries()) {
      arr.sort((a,b)=>a.sub-b.sub);

      // Si hay 2 o m치s beamables con gap<=2, asumimos que habr치 beam y NO ponemos banderas
      let hasBeamPair = false;
      for (let i=0;i<arr.length-1;i++){
        if ((arr[i+1].sub - arr[i].sub) <= 2) { hasBeamPair = true; break; }
      }
      if (hasBeamPair) continue;

      // Si no hay pareja, cada una lleva bandera
      for (const n of arr) {
        const info = stemsInfoPorId.get(n.id);
        if (!info) continue;
        const count = (n.dur === "sixteenth") ? 2 : 1;
        for (let i=0; i<count; i++) {
          svg.appendChild(el("path",{
            d: banderaPath(info.xStem, info.yStemEnd, info.stemUp, i),
            fill:"none", stroke:"#111", "stroke-width":2, "stroke-linecap":"round"
          }));
        }
      }
    }
  }

  // ============================================================
  // Dibujo de nota
  // ============================================================
  function dibujarNota(n, stepsGrupo, stemsInfoPorId) {
    const x = subdivAX(n.sub);
    const y = stepAY(n.step);

    dibujarLineasAdicionales(x, n.step);

    const esRedonda = n.dur==="whole";
    const esBlanca  = n.dur==="half";
    const esNegra   = n.dur==="quarter";
    const esCorchea = n.dur==="eighth";
    const esSemi    = n.dur==="sixteenth";
    const rellena = esNegra || esCorchea || esSemi;

    const g = el("g", { "data-note-id": n.id, cursor: modoBorrar ? "not-allowed" : "grab" });

    const cabeza = el("ellipse",{
      cx:x, cy:y, rx:10.5, ry:7.2,
      fill: rellena ? "#111" : "#fff",
      stroke:"#111","stroke-width":2,
      transform:`rotate(-18 ${x} ${y})`
    });

    const { letra, octava } = stepANota(n.step);
    const title = el("title");
    title.textContent = `${letra}${octava} 췅 ${n.dur}`;
    cabeza.appendChild(title);

    g.appendChild(cabeza);

    if (!esRedonda) {
      const stemUp = stemUpPara(n.step, stepsGrupo);
      const xStem = stemUp ? (x + 9) : (x - 9);
      const y1 = y;
      const y2 = stemUp ? (y - 44) : (y + 44);

      const stem = el("line",{
        x1:xStem,y1:y1,x2:xStem,y2:y2,
        stroke:"#111","stroke-width":2.2,"stroke-linecap":"round"
      });
      g.appendChild(stem);

      stemsInfoPorId.set(n.id, { xStem, yStemEnd: y2, stemUp });
      // banderas individuales se dibujan al final si procede
    }

    g.addEventListener("click", (e) => {
      if (!modoBorrar) return;
      e.stopPropagation();
      notas = notas.filter(x => x.id !== n.id);
      guardar();
      render();
    });
    g.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      notas = notas.filter(x => x.id !== n.id);
      guardar();
      render();
    });

    svg.appendChild(g);
  }

  function render() {
    limpiarSVG();
    dibujarPentagrama();

    const grupoPorSub = new Map();
    for (const n of notas) {
      if (!grupoPorSub.has(n.sub)) grupoPorSub.set(n.sub, []);
      grupoPorSub.get(n.sub).push(n);
    }

    const ordenadas = [...notas].sort((a,b)=>a.sub-b.sub || a.step-b.step);

    const stemsInfoPorId = new Map();
    for (const n of ordenadas) {
      const grupo = grupoPorSub.get(n.sub) || [];
      const steps = grupo.map(x=>x.step);
      dibujarNota(n, steps, stemsInfoPorId);
    }

    // Beams mejorados
    dibujarBeamsMejorado(ordenadas, stemsInfoPorId);

    // Banderas para notas sueltas
    dibujarBanderasSueltas(ordenadas, stemsInfoPorId);
  }

  // ============================================================
  // Interacci칩n: crear / arrastrar / sonido al mover
  // ============================================================
  function puntoSVG(evt) {
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    const m = svg.getScreenCTM().inverse();
    return pt.matrixTransform(m);
  }
  function encontrarGrupoNota(target) {
    if (!target) return null;
    if (target.tagName === "g" && target.getAttribute("data-note-id")) return target;
    if (target.closest) return target.closest("g[data-note-id]");
    return null;
  }

  let drag = null; // {id, offSub, offStep, lastKey, lastT}
  const PREVIEW_MIN_MS = 55;

  function previsualizar(nota) {
    const bpm = Number(document.getElementById("bpm").value);
    const beats = durBeats[nota.dur] ?? 1;
    const sec = Math.min(1.35, Math.max(0.18, beatsASeg(beats, bpm) * 0.62));
    const { midi } = stepANota(nota.step);
    vozPiano(midi, ctx ? ctx.currentTime : 0, sec, 0.95);
  }

  svg.addEventListener("mousedown", (e) => {
    const g = encontrarGrupoNota(e.target);
    if (!g) return;
    if (modoBorrar) return;

    const id = Number(g.getAttribute("data-note-id"));
    const n = notas.find(nn => nn.id === id);
    if (!n) return;

    const p = puntoSVG(e);
    const subMouse = xASubdiv(p.x);
    const stepMouse = yAStep(p.y);

    drag = {
      id,
      offSub: n.sub - subMouse,
      offStep: n.step - stepMouse,
      lastKey: `${n.sub}:${n.step}`,
      lastT: performance.now()
    };

    g.setAttribute("cursor", "grabbing");
  });

  svg.addEventListener("mousemove", (e) => {
    if (!drag) return;

    const p = puntoSVG(e);
    let sub = xASubdiv(p.x) + drag.offSub;
    let step = yAStep(p.y) + drag.offStep;

    sub = clamp(sub, 0, totalSubdivVisibles);
    step = clamp(step, -2, 12);

    sub = Math.round(sub);
    step = Math.round(step);

    const n = notas.find(nn => nn.id === drag.id);
    if (!n) return;

    const changed = (n.sub !== sub) || (n.step !== step);
    if (changed) {
      n.sub = sub;
      n.step = step;
      render();
      guardar();

      const key = `${n.sub}:${n.step}`;
      const now = performance.now();
      if (key !== drag.lastKey && (now - drag.lastT) >= PREVIEW_MIN_MS) {
        drag.lastKey = key;
        drag.lastT = now;
        previsualizar(n);
      }
    }
  });

  window.addEventListener("mouseup", () => { drag = null; });

  svg.addEventListener("click", (e) => {
    const g = encontrarGrupoNota(e.target);
    if (g) return;
    if (drag) return;
    if (modoBorrar) return;

    const p = puntoSVG(e);

    let sub = clamp(xASubdiv(p.x), 0, totalSubdivVisibles);
    let step = clamp(yAStep(p.y), -2, 12);

    const durSel = document.getElementById("dur").value;
    const n = { id: nextId++, sub: Math.round(sub), step: Math.round(step), dur: durSel };
    notas.push(n);

    render();
    guardar();
    previsualizar(n);
  });

  // ============================================================
  // Reproducci칩n polif칩nica
  // ============================================================
  function reproducirTodo() {
    if (!notas.length) return;
    asegurarAudio();

    const bpm = Number(document.getElementById("bpm").value);
    const start = ctx.currentTime + 0.03;

    const porSub = new Map();
    for (const n of notas) {
      if (!porSub.has(n.sub)) porSub.set(n.sub, []);
      porSub.get(n.sub).push(n);
    }

    const subs = [...porSub.keys()].sort((a,b)=>a-b);
    let lastStop = start;

    for (const sub of subs) {
      const beatsDesdeInicio = sub / subdivPorPulso;
      const cuando = start + beatsASeg(beatsDesdeInicio, bpm);

      for (const n of porSub.get(sub)) {
        const beats = durBeats[n.dur] ?? 1;
        const durSec = beatsASeg(beats, bpm);
        const { midi } = stepANota(n.step);
        const v = vozPiano(midi, cuando, durSec, 0.98);
        lastStop = Math.max(lastStop, v.tStop);
      }
    }

    stopAllScheduled = () => {
      if (!ctx || !master) return;
      const t = ctx.currentTime + 0.005;
      master.gain.cancelScheduledValues(t);
      master.gain.setValueAtTime(master.gain.value, t);
      master.gain.exponentialRampToValueAtTime(0.0001, t + 0.04);
      master.gain.setValueAtTime(0.92, t + 0.09);
    };
  }

  // ============================================================
  // UI botones
  // ============================================================
  const btnBorrar = document.getElementById("modoBorrar");
  function actualizarUIBorrar() {
    btnBorrar.textContent = modoBorrar ? "Borrar (activo)" : "Borrar";
    btnBorrar.style.background = modoBorrar ? "#fff5f5" : "#fff";
  }

  document.getElementById("activar").addEventListener("click", asegurarAudio);
  document.getElementById("reproducir").addEventListener("click", reproducirTodo);
  document.getElementById("parar").addEventListener("click", () => { if (stopAllScheduled) stopAllScheduled(); });

  document.getElementById("limpiar").addEventListener("click", () => {
    notas = [];
    nextId = 1;
    borrarGuardado();
    render();
  });

  btnBorrar.addEventListener("click", () => {
    modoBorrar = !modoBorrar;
    actualizarUIBorrar();
    render();
  });

  // ============================================================
  // Arranque
  // ============================================================
  cargar();
  actualizarUIBorrar();
  render();
})();
</script>
</body>
</html>

