<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js Scene</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    // =========================
    // Scene setup
    // =========================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.set(0, 5, 3);
    camera.rotation.x = -Math.PI / 4;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // =========================
    // Helpers
    // =========================
    function lerp(a, b, t) { return a + (b - a) * t; }

    function lerpAngle(a, b, t) {
      let diff = b - a;
      while (diff < -Math.PI) diff += Math.PI * 2;
      while (diff >  Math.PI) diff -= Math.PI * 2;
      return a + diff * t;
    }

    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    // =========================
    // GLTF Loader / Player
    // =========================
    const loader = new THREE.GLTFLoader();

    const player = new THREE.Object3D();
    player.position.set(0, 0, 0);
    scene.add(player);

    loader.load('robot.glb', (gltf) => {
      const playerModel = gltf.scene;
      playerModel.position.set(0, 0, 0);
      playerModel.traverse((child) => {
        if (child.isMesh) child.castShadow = true;
      });
      player.add(playerModel);
    });

    // =========================
    // Floor
    // =========================
    const floorGeometry = new THREE.PlaneGeometry(20, 20);
    const textureLoader = new THREE.TextureLoader();
    const gridTexture = textureLoader.load('grid.jpg');
    gridTexture.wrapS = THREE.RepeatWrapping;
    gridTexture.wrapT = THREE.RepeatWrapping;
    gridTexture.repeat.set(10, 10);

    const floorMaterial = new THREE.MeshStandardMaterial({
      map: gridTexture,
      side: THREE.DoubleSide
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    floor.receiveShadow = true;
    scene.add(floor);

    // =========================
    // Lights
    // =========================
    const spotLight = new THREE.SpotLight(0xffffff, 1);
    spotLight.position.set(3, 8, 3);
    spotLight.target = player;
    spotLight.angle = Math.PI / 4;
    spotLight.penumbra = 0.1;
    spotLight.castShadow = true;
    spotLight.shadow.mapSize.width = 1024;
    spotLight.shadow.mapSize.height = 1024;
    scene.add(spotLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    // =========================
    // Other players
    // =========================
    const otherPlayers = {};

    function updateOtherPlayers(players) {
      players.forEach(p => {
        if (!otherPlayers[p.id]) {
          const container = new THREE.Object3D();
          container.position.set(p.x, p.y, p.z);
          scene.add(container);

          otherPlayers[p.id] = {
            mesh: container,
            targetPos: { x: p.x, y: p.y, z: p.z }
          };

          loader.load('robot.glb', (gltf) => {
            const model = gltf.scene;
            model.position.set(0, 0, 0);
            model.traverse((child) => {
              if (child.isMesh) child.castShadow = true;
            });
            container.add(model);
          });
        } else {
          otherPlayers[p.id].targetPos = { x: p.x, y: p.y, z: p.z };
        }
      });

      const activeIds = players.map(p => p.id);
      Object.keys(otherPlayers).forEach(id => {
        if (!activeIds.includes(id)) {
          scene.remove(otherPlayers[id].mesh);
          delete otherPlayers[id];
        }
      });
    }

    function interpolateOtherPlayers() {
      const lerpFactor = 0.1;
      Object.values(otherPlayers).forEach(p => {
        const oldX = p.mesh.position.x;
        const oldZ = p.mesh.position.z;

        p.mesh.position.x += (p.targetPos.x - p.mesh.position.x) * lerpFactor;
        p.mesh.position.y += (p.targetPos.y - p.mesh.position.y) * lerpFactor;
        p.mesh.position.z += (p.targetPos.z - p.mesh.position.z) * lerpFactor;

        const dx = p.mesh.position.x - oldX;
        const dz = p.mesh.position.z - oldZ;
        if (Math.abs(dx) > 0.001 || Math.abs(dz) > 0.001) {
          const angle = Math.atan2(dx, dz);
          p.mesh.rotation.y = angle;
        }
      });
    }

    // =========================
    // Bullets (local + network)
    // =========================
    const BULLET_SPEED = 7.5;     // units/sec
    const BULLET_TTL_MS = 2000;   // keep bullets alive ~2s
    const BULLET_RADIUS = 0.12;

    const bulletGeometry = new THREE.SphereGeometry(BULLET_RADIUS, 12, 12);
    const myBulletMaterial = new THREE.MeshStandardMaterial({ color: 0xffdd33 });
    const otherBulletMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });

    // Local bullets (for immediate feel)
    const myBullets = []; // {id, mesh, vx, vy, vz, bornMs}

    // Network bullets (rendered from server)
    const otherBullets = {}; // id -> {mesh, targetPos:{x,y,z}}

    function spawnLocalBullet() {
      // Spawn a bit above floor
      const start = new THREE.Vector3(player.position.x, 0.35, player.position.z);

      // IMPORTANT: your rotation convention makes "forward" aligned with +Z
      // (because angle = atan2(dx, dz)). So base forward is (0,0,1).
      const forward = new THREE.Vector3(0, 0, 1)
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y)
        .normalize();

      // Spawn slightly in front of player
      start.add(forward.clone().multiplyScalar(0.6));

      const vx = forward.x * BULLET_SPEED;
      const vy = 0;
      const vz = forward.z * BULLET_SPEED;

      const bullet = new THREE.Mesh(bulletGeometry, myBulletMaterial);
      bullet.position.copy(start);
      bullet.castShadow = true;
      scene.add(bullet);

      const id = `${Date.now()}_${Math.floor(Math.random() * 1e9)}`;

      myBullets.push({
        id,
        mesh: bullet,
        vx, vy, vz,
        bornMs: Date.now()
      });

      // Send to server (so others can see it)
      sendShotToServer({ id, x: start.x, y: start.y, z: start.z, vx, vy, vz, created: Math.floor(Date.now() / 1000) });
    }

    function updateLocalBullets(dt) {
      const now = Date.now();
      for (let i = myBullets.length - 1; i >= 0; i--) {
        const b = myBullets[i];

        b.mesh.position.x += b.vx * dt;
        b.mesh.position.y += b.vy * dt;
        b.mesh.position.z += b.vz * dt;

        // Remove if TTL exceeded or out of arena bounds (slightly larger than floor)
        const out =
          Math.abs(b.mesh.position.x) > 15 ||
          Math.abs(b.mesh.position.z) > 15;

        if (now - b.bornMs > BULLET_TTL_MS || out) {
          scene.remove(b.mesh);
          myBullets.splice(i, 1);
        }
      }
    }

    function updateNetworkBullets(bulletsFromServer) {
      // Create/update
      bulletsFromServer.forEach(b => {
        if (!otherBullets[b.id]) {
          const m = new THREE.Mesh(bulletGeometry, otherBulletMaterial);
          m.position.set(b.x, b.y, b.z);
          m.castShadow = true;
          scene.add(m);
          otherBullets[b.id] = {
            mesh: m,
            targetPos: { x: b.x, y: b.y, z: b.z }
          };
        } else {
          otherBullets[b.id].targetPos = { x: b.x, y: b.y, z: b.z };
        }
      });

      // Remove stale (server is source of truth)
      const activeIds = new Set(bulletsFromServer.map(b => b.id));
      Object.keys(otherBullets).forEach(id => {
        if (!activeIds.has(id)) {
          scene.remove(otherBullets[id].mesh);
          delete otherBullets[id];
        }
      });
    }

    function interpolateNetworkBullets() {
      const lerpFactor = 0.35; // a bit snappier than players
      Object.values(otherBullets).forEach(b => {
        b.mesh.position.x += (b.targetPos.x - b.mesh.position.x) * lerpFactor;
        b.mesh.position.y += (b.targetPos.y - b.mesh.position.y) * lerpFactor;
        b.mesh.position.z += (b.targetPos.z - b.mesh.position.z) * lerpFactor;
      });
    }

    // =========================
    // Input: WASD + mouse click
    // =========================
    const keys = {};
    const moveSpeed = 0.1;

    window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

    // Prevent context menu (right click)
    window.addEventListener('contextmenu', (e) => e.preventDefault());

    // Left click shoots
    window.addEventListener('mousedown', (e) => {
      if (e.button === 0) { // left
        spawnLocalBullet();
      }
    });

    function updatePlayerMovement() {
      const oldX = player.position.x;
      const oldZ = player.position.z;

      if (keys['w']) player.position.z -= moveSpeed;
      if (keys['s']) player.position.z += moveSpeed;
      if (keys['a']) player.position.x -= moveSpeed;
      if (keys['d']) player.position.x += moveSpeed;

      player.position.x = clamp(player.position.x, -9.5, 9.5);
      player.position.z = clamp(player.position.z, -9.5, 9.5);

      const dx = player.position.x - oldX;
      const dz = player.position.z - oldZ;
      if (dx !== 0 || dz !== 0) {
        const targetAngle = Math.atan2(dx, dz);
        const rotationSpeed = 0.15;
        player.rotation.y = lerpAngle(player.rotation.y, targetAngle, rotationSpeed);
      }

      // Camera follows
      camera.position.x = player.position.x;
      camera.position.z = player.position.z + 3;

      // Spotlight follows
      spotLight.position.x = player.position.x + 3;
      spotLight.position.z = player.position.z + 3;
    }

    // =========================
    // Resize
    // =========================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // =========================
    // Networking
    // =========================
    const ENDPOINT = 'https://static.jocarsa.com/moba/';

    async function sendShotToServer(shot) {
      try {
        // Send shot immediately (also updates position)
        await fetch(ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            x: player.position.x,
            y: player.position.y,
            z: player.position.z,
            shot
          })
        });
      } catch (err) {
        console.error('Shot send error:', err);
      }
    }

    // Heartbeat: send position, receive players + bullets
    setInterval(async () => {
      try {
        const response = await fetch(ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            x: player.position.x,
            y: player.position.y,
            z: player.position.z
          })
        });

        const data = await response.json();
        // Expect: { players:[...], bullets:[...] }
        updateOtherPlayers(data.players || []);
        updateNetworkBullets(data.bullets || []);
      } catch (error) {
        console.error('Sync error:', error);
      }
    }, 250); // smoother bullets than 1000ms

    // =========================
    // Main loop (dt-based)
    // =========================
    let lastT = performance.now();
    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const dt = (now - lastT) / 1000; // seconds
      lastT = now;

      updatePlayerMovement();
      interpolateOtherPlayers();

      updateLocalBullets(dt);
      interpolateNetworkBullets();

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>

