<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Simulación de robots tipo Roomba (evolutivos)</title>
    <style>
        body {
            margin: 0;
            background: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #eee;
            font-family: sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            background: #111;
            border: 1px solid #555;
            display: block;
        }
        #info {
            position: absolute;
            left: 10px;
            top: 10px;
            background: rgba(0,0,0,0.6);
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 4px;
            white-space: pre-line;
        }
    </style>
</head>
<body>
<div id="container">
    <canvas id="sim"></canvas>
    <div id="info"></div>
</div>

<script>
/* ---------- Configuración básica ---------- */
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");
const infoDiv = document.getElementById("info");

// Pantalla completa
canvas.width  = window.innerWidth;
canvas.height = window.innerHeight;

// Rejilla del laberinto
const walls = [];
let cellSize;           // tamaño de cada celda
let cols, rows;         // número de columnas y filas
let border = 20;        // margen externo

let GOAL_RADIUS = 35;
let GOAL_X = 0;
let GOAL_Y = 0;

const NUM_ROBOTS = 100;
let generation = 1;

// Tiempos (en segundos) para el robot más rápido de cada generación
let generationTimes = [];
let generationStartTime = performance.now();

// "Genes" del mejor robot hasta el momento
let bestGenes = null;

// Genes por defecto (primera generación)
const defaultGenes = {
    radius: 10,
    speed: 1.8,
    sensorLength: 100,
    sensorAngles: [-0.6, -0.25, 0, 0.25, 0.6],
    turnCooldownMax: 20,
    baseTurnAngle: 0.4,
    randomTurnRange: 1.0
};

let robots = [];

/* ---------- Utilidades geométricas ---------- */

function segmentIntersection(p0, p1, p2, p3) {
    const s1x = p1.x - p0.x;
    const s1y = p1.y - p0.y;
    const s2x = p3.x - p2.x;
    const s2y = p3.y - p2.y;

    const denom = (-s2x * s1y + s1x * s2y);
    if (denom === 0) return null;

    const s = (-s1y * (p0.x - p2.x) + s1x * (p0.y - p2.y)) / denom;
    const t = ( s2x * (p0.y - p2.y) - s2y * (p0.x - p2.x)) / denom;

    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
        return {
            x: p0.x + (t * s1x),
            y: p0.y + (t * s1y),
            t: t,
            u: s
        };
    }
    return null;
}

function circleIntersectsRect(cx, cy, radius, rect) {
    const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
    const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) < (radius * radius);
}

/* ---------- Generación de laberinto clásico (DFS en rejilla) ---------- */

function createMaze() {
    walls.length = 0;

    const W = canvas.width;
    const H = canvas.height;

    // Calculamos tamaño de celda en función de la pantalla
    const targetCell = 250;  // tamaño aproximado deseado
    const usableW = W - 2 * border;
    const usableH = H - 2 * border;

    cols = Math.max(5, Math.floor(usableW / targetCell));
    rows = Math.max(5, Math.floor(usableH / targetCell));

    cellSize = Math.min(usableW / cols, usableH / rows);

    // Reajustar borde para centrar un poco
    const usedW = cols * cellSize;
    const usedH = rows * cellSize;
    border = 0.5 * (Math.min(W - usedW, H - usedH));

    // Celdas del laberinto
    const grid = [];
    for (let y = 0; y < rows; y++) {
        const row = [];
        for (let x = 0; x < cols; x++) {
            row.push({
                x,
                y,
                visited: false,
                walls: { top: true, right: true, bottom: true, left: true }
            });
        }
        grid.push(row);
    }

    function neighbours(cell) {
        const list = [];
        const { x, y } = cell;
        if (y > 0) list.push(grid[y - 1][x]);        // arriba
        if (x < cols - 1) list.push(grid[y][x + 1]); // derecha
        if (y < rows - 1) list.push(grid[y + 1][x]); // abajo
        if (x > 0) list.push(grid[y][x - 1]);        // izquierda
        return list;
    }

    function removeWall(a, b) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        if (dx === 1) {
            // b está a la derecha
            a.walls.right = false;
            b.walls.left = false;
        } else if (dx === -1) {
            // b a la izquierda
            a.walls.left = false;
            b.walls.right = false;
        } else if (dy === 1) {
            // b abajo
            a.walls.bottom = false;
            b.walls.top = false;
        } else if (dy === -1) {
            // b arriba
            a.walls.top = false;
            b.walls.bottom = false;
        }
    }

    // DFS recursivo con pila (backtracking)
    const stack = [];
    const startCell = grid[0][0];
    startCell.visited = true;
    stack.push(startCell);

    while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const neigh = neighbours(current).filter(n => !n.visited);

        if (neigh.length === 0) {
            stack.pop();
        } else {
            const next = neigh[Math.floor(Math.random() * neigh.length)];
            next.visited = true;
            removeWall(current, next);
            stack.push(next);
        }
    }

    // Convertimos paredes de celdas en rectángulos para colisiones/dibujo
    const wallThickness = Math.max(4, cellSize * 0.15);

    function cellToX(c) {
        return border + c * cellSize;
    }
    function cellToY(r) {
        return border + r * cellSize;
    }

    // Recalculamos posición de META en el centro de la celda final
    GOAL_X = cellToX(cols - 1) + cellSize / 2;
    GOAL_Y = cellToY(rows - 1) + cellSize / 2;
    GOAL_RADIUS = cellSize * 0.35;

    // Generar paredes externas + internas basadas en las celdas
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            const c = grid[y][x];
            const cx = cellToX(x);
            const cy = cellToY(y);

            // pared superior
            if (c.walls.top && y === 0) {
                walls.push({
                    x: cx,
                    y: cy,
                    w: cellSize,
                    h: wallThickness
                });
            }
            // pared izquierda
            if (c.walls.left && x === 0) {
                walls.push({
                    x: cx,
                    y: cy,
                    w: wallThickness,
                    h: cellSize
                });
            }
            // pared inferior (entre esta celda y la de abajo)
            if (c.walls.bottom && y < rows - 1) {
                walls.push({
                    x: cx,
                    y: cy + cellSize - wallThickness / 2,
                    w: cellSize,
                    h: wallThickness
                });
            }
            // pared derecha (entre esta celda y la de la derecha)
            if (c.walls.right && x < cols - 1) {
                walls.push({
                    x: cx + cellSize - wallThickness / 2,
                    y: cy,
                    w: wallThickness,
                    h: cellSize
                });
            }

            // bordes extremos inferiores y derechos
            if (y === rows - 1 && c.walls.bottom) {
                walls.push({
                    x: cx,
                    y: cy + cellSize - wallThickness,
                    w: cellSize,
                    h: wallThickness
                });
            }
            if (x === cols - 1 && c.walls.right) {
                walls.push({
                    x: cx + cellSize - wallThickness,
                    y: cy,
                    w: wallThickness,
                    h: cellSize
                });
            }
        }
    }
}

function drawWalls() {
    ctx.fillStyle = "#444";
    for (const w of walls) {
        ctx.fillRect(w.x, w.y, w.w, w.h);
    }
}

function drawGoal() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(GOAL_X, GOAL_Y, GOAL_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(50, 180, 50, 0.3)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#00ff88";
    ctx.stroke();

    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#00ff88";
    ctx.textAlign = "center";
    ctx.fillText("META", GOAL_X, GOAL_Y + 4);
    ctx.restore();
}

/* ---------- Clase Robot ---------- */

class Robot {
    constructor(x, y, genes) {
        const g = genes || defaultGenes;

        this.x = x;
        this.y = y;
        this.radius = g.radius;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = g.speed;

        this.sensorLength = g.sensorLength;
        this.sensorAngles = g.sensorAngles.slice();

        this.sensorHits = [];

        this.turnCooldown = 0;
        this.turnCooldownMax = g.turnCooldownMax;
        this.baseTurnAngle = g.baseTurnAngle;
        this.randomTurnRange = g.randomTurnRange;
    }

    update() {
        const hits = this.checkSensors();

        const anyHit = hits.some(h => h.hit);
        if (anyHit && this.turnCooldown === 0) {
            const direction = Math.random() < 0.5 ? -1 : 1;
            const angleChange =
                (this.baseTurnAngle + Math.random() * this.randomTurnRange) * direction;
            this.angle += angleChange;
            this.turnCooldown = this.turnCooldownMax;
        }

        if (this.turnCooldown > 0) {
            this.turnCooldown--;
        }

        const newX = this.x + Math.cos(this.angle) * this.speed;
        const newY = this.y + Math.sin(this.angle) * this.speed;

        let collided = false;
        for (const w of walls) {
            if (circleIntersectsRect(newX, newY, this.radius, w)) {
                collided = true;
                break;
            }
        }

        if (!collided) {
            this.x = newX;
            this.y = newY;
        } else {
            const backX = this.x - Math.cos(this.angle) * this.speed * 2;
            const backY = this.y - Math.sin(this.angle) * this.speed * 2;
            this.x = backX;
            this.y = backY;
            this.angle += (Math.random() - 0.5) * Math.PI;
            this.turnCooldown = this.turnCooldownMax;
        }
    }

    checkSensors() {
        this.sensorHits = [];

        for (const relAngle of this.sensorAngles) {
            const sensorDir = this.angle + relAngle;

            const start = { x: this.x, y: this.y };
            const end = {
                x: this.x + Math.cos(sensorDir) * this.sensorLength,
                y: this.y + Math.sin(sensorDir) * this.sensorLength
            };

            let closestHit = null;
            let closestT = Infinity;

            for (const w of walls) {
                const edges = [
                    { a: { x: w.x,         y: w.y },         b: { x: w.x + w.w, y: w.y } },
                    { a: { x: w.x,         y: w.y + w.h },   b: { x: w.x + w.w, y: w.y + w.h } },
                    { a: { x: w.x,         y: w.y },         b: { x: w.x,       y: w.y + w.h } },
                    { a: { x: w.x + w.w,   y: w.y },         b: { x: w.x + w.w, y: w.y + w.h } }
                ];

                for (const edge of edges) {
                    const result = segmentIntersection(start, end, edge.a, edge.b);
                    if (result && result.t < closestT) {
                        closestT = result.t;
                        closestHit = { x: result.x, y: result.y };
                    }
                }
            }

            if (closestHit) {
                this.sensorHits.push({
                    angle: sensorDir,
                    hit: true,
                    from: start,
                    to: closestHit
                });
            } else {
                this.sensorHits.push({
                    angle: sensorDir,
                    hit: false,
                    from: start,
                    to: end
                });
            }
        }

        return this.sensorHits;
    }

    hasReachedGoal() {
        const dx = this.x - GOAL_X;
        const dy = this.y - GOAL_Y;
        const dist2 = dx * dx + dy * dy;
        return dist2 < (GOAL_RADIUS * GOAL_RADIUS);
    }

    draw(ctx) {
        for (const s of this.sensorHits) {
            ctx.beginPath();
            ctx.moveTo(s.from.x, s.from.y);
            ctx.lineTo(s.to.x, s.to.y);
            ctx.strokeStyle = s.hit ? "#ff5555" : "#55ff55";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#dddddd";
        ctx.fill();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "#333333";
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.radius, 0);
        ctx.strokeStyle = "#00aaff";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();
    }
}

/* ---------- Evolución ---------- */

function mutateValue(value, factor, minVal, maxVal) {
    const delta = (Math.random() * 2 - 1) * factor;
    let v = value * (1 + delta);
    if (minVal !== undefined) v = Math.max(minVal, v);
    if (maxVal !== undefined) v = Math.min(maxVal, v);
    return v;
}

function mutateGenes(parent) {
    const g = {
        radius: parent.radius,
        speed: mutateValue(parent.speed, 0.2, 0.5, 4.0),
        sensorLength: mutateValue(parent.sensorLength, 0.2, 40, 250),
        turnCooldownMax: Math.round(mutateValue(parent.turnCooldownMax, 0.3, 5, 80)),
        baseTurnAngle: mutateValue(parent.baseTurnAngle, 0.3, 0.1, 1.2),
        randomTurnRange: mutateValue(parent.randomTurnRange, 0.3, 0.2, 2.5),
        sensorAngles: parent.sensorAngles.slice()
    };

    for (let i = 0; i < g.sensorAngles.length; i++) {
        g.sensorAngles[i] += (Math.random() * 2 - 1) * 0.1;
    }

    g.sensorAngles.sort((a, b) => a - b);
    return g;
}

function extractGenesFromRobot(robot) {
    return {
        radius: robot.radius,
        speed: robot.speed,
        sensorLength: robot.sensorLength,
        sensorAngles: robot.sensorAngles.slice(),
        turnCooldownMax: robot.turnCooldownMax,
        baseTurnAngle: robot.baseTurnAngle,
        randomTurnRange: robot.randomTurnRange
    };
}

/* ---------- Gestión de simulación ---------- */

function resetSimulation() {
    robots = [];
    const parentGenes = bestGenes || defaultGenes;

    // Nuevo laberinto clásico para esta generación
    createMaze();

    // Centro de la celda (0,0)
    const startCellX = border + cellSize * 0.5;
    const startCellY = border + cellSize * 0.5;
    const spread = cellSize * 0.3;

    for (let i = 0; i < NUM_ROBOTS; i++) {
        const genes = bestGenes ? mutateGenes(parentGenes) : parentGenes;

        const startX = startCellX + (Math.random() * 2 - 1) * spread;
        const startY = startCellY + (Math.random() * 2 - 1) * spread;

        robots.push(new Robot(startX, startY, genes));
    }

    generationStartTime = performance.now();
}

function updateInfo() {
    let text = `Generación: ${generation}
Robots: ${NUM_ROBOTS}`;

    if (bestGenes && generationTimes.length > 0) {
        const lastTime = generationTimes[generationTimes.length - 1];
        text += `

Mejores genes (ganador generación anterior):
- velocidad: ${bestGenes.speed.toFixed(2)}
- longitud de sensores: ${bestGenes.sensorLength.toFixed(1)}
- enfriamiento giro: ${bestGenes.turnCooldownMax}
- ángulo base de giro: ${bestGenes.baseTurnAngle.toFixed(2)}
- rango giro aleatorio: ${bestGenes.randomTurnRange.toFixed(2)}

Tiempo última generación: ${lastTime.toFixed(2)} s`;
    } else {
        text += `

Mejores genes: ninguno todavía (evolucionando...)`;
    }

    infoDiv.textContent = text;
}

/* ---------- Gráfico de barras ---------- */

function drawChart() {
    if (generationTimes.length === 0) return;

    const chartWidth  = Math.min(260, canvas.width * 0.25);
    const chartHeight = Math.min(160, canvas.height * 0.25);
    const chartX = canvas.width - chartWidth - 10;
    const chartY = canvas.height - chartHeight - 10;

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(chartX, chartY, chartWidth, chartHeight);

    ctx.strokeStyle = "#aaaaaa";
    ctx.lineWidth = 1;
    ctx.strokeRect(chartX, chartY, chartWidth, chartHeight);

    ctx.fillStyle = "#ffffff";
    ctx.font = "11px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Tiempo hasta la meta (s)", chartX + 6, chartY + 14);

    const maxBars = 30;
    const data = generationTimes.slice(-maxBars);
    const maxTime = Math.max(...data);
    const minTime = Math.min(...data);

    const innerX = chartX + 30;
    const innerY = chartY + 25;
    const innerWidth = chartWidth - 40;
    const innerHeight = chartHeight - 35;

    ctx.strokeStyle = "#888";
    ctx.beginPath();
    ctx.moveTo(innerX, innerY);
    ctx.lineTo(innerX, innerY + innerHeight);
    ctx.lineTo(innerX + innerWidth, innerY + innerHeight);
    ctx.stroke();

    ctx.fillStyle = "#aaaaaa";
    ctx.textAlign = "right";
    ctx.fillText(maxTime.toFixed(1), innerX - 4, innerY + 8);
    ctx.fillText(minTime.toFixed(1), innerX - 4, innerY + innerHeight);

    const barCount = data.length;
    const barGap = 2;
    const barWidth = Math.max(3, (innerWidth - barGap * (barCount - 1)) / barCount);

    ctx.textAlign = "center";

    for (let i = 0; i < barCount; i++) {
        const t = data[i];
        const norm = t / maxTime;
        const barH = norm * innerHeight;
        const x = innerX + i * (barWidth + barGap);
        const y = innerY + innerHeight - barH;

        ctx.fillStyle = "#00aaee";
        ctx.fillRect(x, y, barWidth, barH);

        if ((i + 1) % 5 === 0 || i === barCount - 1) {
            const genIndex = generationTimes.length - data.length + i + 1;
            ctx.fillStyle = "#ffffff";
            ctx.font = "9px sans-serif";
            ctx.fillText(genIndex, x + barWidth / 2, innerY + innerHeight + 10);
        }
    }

    ctx.restore();
}

/* ---------- Bucle principal ---------- */

resetSimulation();
updateInfo();

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawWalls();
    drawGoal();

    let winner = null;

    for (const r of robots) {
        r.update();
        r.draw(ctx);

        if (!winner && r.hasReachedGoal()) {
            winner = r;
        }
    }

    if (winner) {
        const now = performance.now();
        const elapsedSeconds = (now - generationStartTime) / 1000.0;

        generationTimes.push(elapsedSeconds);
        bestGenes = extractGenesFromRobot(winner);
        generation++;
        resetSimulation();
        updateInfo();
    }

    drawChart();
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>

