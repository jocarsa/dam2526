<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Evolving Roomba Robots</title>
    <style>
        body {
            margin: 0;
            background: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #eee;
            font-family: sans-serif;
        }
        #container {
            position: relative;
        }
        canvas {
            background: #111;
            border: 1px solid #555;
            display: block;
        }
        #info {
            position: absolute;
            left: 10px;
            top: 10px;
            background: rgba(0,0,0,0.6);
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 4px;
            white-space: pre-line;
        }
    </style>
</head>
<body>
<div id="container">
    <canvas id="sim" width="800" height="600"></canvas>
    <div id="info"></div>
</div>

<script>
/* ---------- Basic setup ---------- */
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");
const infoDiv = document.getElementById("info");

const walls = [];

const GOAL_RADIUS = 35;
const GOAL_X = canvas.width - 80;
const GOAL_Y = canvas.height - 80;

const NUM_ROBOTS = 100;
let generation = 1;

// "Genes" of the best robot so far (winner of last generation)
let bestGenes = null;

// Default base genes for the very first generation
const defaultGenes = {
    radius: 10,
    speed: 1.8,
    sensorLength: 100,
    sensorAngles: [-0.6, -0.25, 0, 0.25, 0.6],
    turnCooldownMax: 20,
    baseTurnAngle: 0.4,
    randomTurnRange: 1.0
};

let robots = [];

// Create some maze walls (axis-aligned rectangles)
function createMaze() {
    const W = canvas.width;
    const H = canvas.height;

    // Outer border
    walls.push({x: 0, y: 0, w: W, h: 20});
    walls.push({x: 0, y: H - 20, w: W, h: 20});
    walls.push({x: 0, y: 0, w: 20, h: H});
    walls.push({x: W - 20, y: 0, w: 20, h: H});

    // Internal walls
    walls.push({x: 150, y: 80, w: 20,  h: 350});
    walls.push({x: 300, y: 200, w: 250, h: 20});
    walls.push({x: 450, y: 80, w: 20,  h: 150});
    walls.push({x: 550, y: 280, w: 20,  h: 250});
    walls.push({x: 220, y: 420, w: 280, h: 20});
}

function drawWalls() {
    ctx.fillStyle = "#444";
    for (const w of walls) {
        ctx.fillRect(w.x, w.y, w.w, w.h);
    }
}

function drawGoal() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(GOAL_X, GOAL_Y, GOAL_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(50, 180, 50, 0.3)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#00ff88";
    ctx.stroke();

    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#00ff88";
    ctx.textAlign = "center";
    ctx.fillText("GOAL", GOAL_X, GOAL_Y + 4);
    ctx.restore();
}

/* ---------- Geometry helpers ---------- */

// Segment–segment intersection (p0->p1 with p2->p3)
// Returns {x, y, t, u} or null
function segmentIntersection(p0, p1, p2, p3) {
    const s1x = p1.x - p0.x;
    const s1y = p1.y - p0.y;
    const s2x = p3.x - p2.x;
    const s2y = p3.y - p2.y;

    const denom = (-s2x * s1y + s1x * s2y);
    if (denom === 0) return null; // Parallel or collinear

    const s = (-s1y * (p0.x - p2.x) + s1x * (p0.y - p2.y)) / denom;
    const t = ( s2x * (p0.y - p2.y) - s2y * (p0.x - p2.x)) / denom;

    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
        return {
            x: p0.x + (t * s1x),
            y: p0.y + (t * s1y),
            t: t,
            u: s
        };
    }
    return null;
}

// Circle vs rectangle collision (robot is a circle, walls are rects)
function circleIntersectsRect(cx, cy, radius, rect) {
    const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
    const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) < (radius * radius);
}

/* ---------- Robot class ---------- */

class Robot {
    constructor(x, y, genes) {
        const g = genes || defaultGenes;

        this.x = x;
        this.y = y;
        this.radius = g.radius;
        this.angle = Math.random() * Math.PI * 2; // heading in radians
        this.speed = g.speed;

        // Sensor configuration (angles relative to heading)
        this.sensorLength = g.sensorLength;
        this.sensorAngles = g.sensorAngles.slice();

        this.sensorHits = [];  // info per sensor for drawing

        // Turn behavior
        this.turnCooldown = 0;
        this.turnCooldownMax = g.turnCooldownMax;
        this.baseTurnAngle = g.baseTurnAngle;
        this.randomTurnRange = g.randomTurnRange;
    }

    update() {
        // Check sensors (raycasting)
        const hits = this.checkSensors();

        // If any sensor is hitting something and we are not in cooldown, rotate
        const anyHit = hits.some(h => h.hit);
        if (anyHit && this.turnCooldown === 0) {
            // Random direction and magnitude based on genes
            const direction = Math.random() < 0.5 ? -1 : 1;
            const angleChange =
                (this.baseTurnAngle + Math.random() * this.randomTurnRange) * direction;
            this.angle += angleChange;
            this.turnCooldown = this.turnCooldownMax;
        }

        if (this.turnCooldown > 0) {
            this.turnCooldown--;
        }

        // Move forward
        const newX = this.x + Math.cos(this.angle) * this.speed;
        const newY = this.y + Math.sin(this.angle) * this.speed;

        // Check collision with walls
        let collided = false;
        for (const w of walls) {
            if (circleIntersectsRect(newX, newY, this.radius, w)) {
                collided = true;
                break;
            }
        }

        if (!collided) {
            this.x = newX;
            this.y = newY;
        } else {
            // If collision, backtrack slightly and turn randomly
            const backX = this.x - Math.cos(this.angle) * this.speed * 2;
            const backY = this.y - Math.sin(this.angle) * this.speed * 2;
            this.x = backX;
            this.y = backY;
            this.angle += (Math.random() - 0.5) * Math.PI; // big random turn
            this.turnCooldown = this.turnCooldownMax;
        }
    }

    checkSensors() {
        this.sensorHits = [];

        for (const relAngle of this.sensorAngles) {
            const sensorDir = this.angle + relAngle;

            const start = { x: this.x, y: this.y };
            const end = {
                x: this.x + Math.cos(sensorDir) * this.sensorLength,
                y: this.y + Math.sin(sensorDir) * this.sensorLength
            };

            let closestHit = null;
            let closestT = Infinity;

            // Check ray against all walls (their edges)
            for (const w of walls) {
                const edges = [
                    // top
                    { a: { x: w.x,         y: w.y },         b: { x: w.x + w.w, y: w.y } },
                    // bottom
                    { a: { x: w.x,         y: w.y + w.h },   b: { x: w.x + w.w, y: w.y + w.h } },
                    // left
                    { a: { x: w.x,         y: w.y },         b: { x: w.x,       y: w.y + w.h } },
                    // right
                    { a: { x: w.x + w.w,   y: w.y },         b: { x: w.x + w.w, y: w.y + w.h } }
                ];

                for (const edge of edges) {
                    const result = segmentIntersection(start, end, edge.a, edge.b);
                    if (result && result.t < closestT) {
                        closestT = result.t;
                        closestHit = { x: result.x, y: result.y };
                    }
                }
            }

            if (closestHit) {
                this.sensorHits.push({
                    angle: sensorDir,
                    hit: true,
                    from: start,
                    to: closestHit
                });
            } else {
                this.sensorHits.push({
                    angle: sensorDir,
                    hit: false,
                    from: start,
                    to: end
                });
            }
        }

        return this.sensorHits;
    }

    hasReachedGoal() {
        const dx = this.x - GOAL_X;
        const dy = this.y - GOAL_Y;
        const dist2 = dx * dx + dy * dy;
        return dist2 < (GOAL_RADIUS * GOAL_RADIUS);
    }

    draw(ctx) {
        // Draw sensors
        for (const s of this.sensorHits) {
            ctx.beginPath();
            ctx.moveTo(s.from.x, s.from.y);
            ctx.lineTo(s.to.x, s.to.y);
            ctx.strokeStyle = s.hit ? "#ff5555" : "#55ff55"; // red if hit, green otherwise
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Draw robot body
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Body
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#dddddd";
        ctx.fill();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "#333333";
        ctx.stroke();

        // "Front" indicator
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.radius, 0);
        ctx.strokeStyle = "#00aaff";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();
    }
}

/* ---------- Evolution helpers ---------- */

// Mutate a numeric gene by a factor (e.g. 0.2 = ±20%)
function mutateValue(value, factor, minVal, maxVal) {
    const delta = (Math.random() * 2 - 1) * factor; // [-factor, factor]
    let v = value * (1 + delta);
    if (minVal !== undefined) v = Math.max(minVal, v);
    if (maxVal !== undefined) v = Math.min(maxVal, v);
    return v;
}

// Create a mutated copy of parent's genes
function mutateGenes(parent) {
    const g = {
        radius: parent.radius, // keep radius constant, or mutate slightly if you want
        speed: mutateValue(parent.speed, 0.2, 0.5, 4.0),
        sensorLength: mutateValue(parent.sensorLength, 0.2, 40, 200),
        turnCooldownMax: Math.round(mutateValue(parent.turnCooldownMax, 0.3, 5, 60)),
        baseTurnAngle: mutateValue(parent.baseTurnAngle, 0.3, 0.1, 1.0),
        randomTurnRange: mutateValue(parent.randomTurnRange, 0.3, 0.2, 2.0),
        sensorAngles: parent.sensorAngles.slice()
    };

    // Slightly perturb each sensor angle
    for (let i = 0; i < g.sensorAngles.length; i++) {
        g.sensorAngles[i] += (Math.random() * 2 - 1) * 0.1; // ±0.1 rad
    }

    // Optional: sort angles so they're still roughly ordered
    g.sensorAngles.sort((a, b) => a - b);

    return g;
}

// Extract genes from a winning robot
function extractGenesFromRobot(robot) {
    return {
        radius: robot.radius,
        speed: robot.speed,
        sensorLength: robot.sensorLength,
        sensorAngles: robot.sensorAngles.slice(),
        turnCooldownMax: robot.turnCooldownMax,
        baseTurnAngle: robot.baseTurnAngle,
        randomTurnRange: robot.randomTurnRange
    };
}

/* ---------- Simulation management ---------- */

function resetSimulation() {
    robots = [];

    const parentGenes = bestGenes || defaultGenes;

    for (let i = 0; i < NUM_ROBOTS; i++) {
        // First generation uses defaultGenes directly
        // Later generations use mutated genes from the best
        const genes = bestGenes ? mutateGenes(parentGenes) : parentGenes;

        // Safe area near top-left, away from outer walls and first vertical wall
        const startX = 40 + Math.random() * 80; // between 40 and 120
        const startY = 40 + Math.random() * 80; // between 40 and 120

        robots.push(new Robot(startX, startY, genes));
    }
}

function updateInfo() {
    let text = `Generation: ${generation}
Robots: ${NUM_ROBOTS}`;

    if (bestGenes) {
        text += `

Best genes (last winner):
- speed: ${bestGenes.speed.toFixed(2)}
- sensorLength: ${bestGenes.sensorLength.toFixed(1)}
- turnCooldownMax: ${bestGenes.turnCooldownMax}
- baseTurnAngle: ${bestGenes.baseTurnAngle.toFixed(2)}
- randomTurnRange: ${bestGenes.randomTurnRange.toFixed(2)}`;
    } else {
        text += `

Best genes: (none yet – evolving...)`;
    }

    infoDiv.textContent = text;
}

/* ---------- Main loop ---------- */

createMaze();
resetSimulation();
updateInfo();

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawWalls();
    drawGoal();

    let winner = null;

    for (const r of robots) {
        r.update();
        r.draw(ctx);

        if (!winner && r.hasReachedGoal()) {
            winner = r;
        }
    }

    // If any robot reaches the goal, evolve and restart
    if (winner) {
        bestGenes = extractGenesFromRobot(winner);
        generation++;
        resetSimulation();
        updateInfo();
    }

    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>

