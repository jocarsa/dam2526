<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Roomba-like Robot Simulation</title>
    <style>
        body {
            margin: 0;
            background: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #eee;
            font-family: sans-serif;
        }
        #container {
            position: relative;
        }
        canvas {
            background: #111;
            border: 1px solid #555;
            display: block;
        }
        #info {
            position: absolute;
            left: 10px;
            top: 10px;
            background: rgba(0,0,0,0.6);
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<div id="container">
    <canvas id="sim" width="800" height="600"></canvas>
    <div id="info">
        100 Roomba-like robots with ray sensors<br>
        All start at top-left · Goal at bottom-right<br>
        Simulation stops when one reaches the goal
    </div>
</div>

<script>
/* ---------- Basic setup ---------- */
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");

const walls = [];

const GOAL_RADIUS = 35;
const GOAL_X = canvas.width - 80;
const GOAL_Y = canvas.height - 80;

let gameOver = false;

// Create some maze walls (axis-aligned rectangles)
function createMaze() {
    const W = canvas.width;
    const H = canvas.height;

    // Outer border
    walls.push({x: 0, y: 0, w: W, h: 20});
    walls.push({x: 0, y: H - 20, w: W, h: 20});
    walls.push({x: 0, y: 0, w: 20, h: H});
    walls.push({x: W - 20, y: 0, w: 20, h: H});

    // Internal walls
    walls.push({x: 150, y: 80, w: 20,  h: 350});
    walls.push({x: 300, y: 200, w: 250, h: 20});
    walls.push({x: 450, y: 80, w: 20,  h: 150});
    walls.push({x: 550, y: 280, w: 20,  h: 250});
    walls.push({x: 220, y: 420, w: 280, h: 20});
}

function drawWalls() {
    ctx.fillStyle = "#444";
    for (const w of walls) {
        ctx.fillRect(w.x, w.y, w.w, w.h);
    }
}

function drawGoal() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(GOAL_X, GOAL_Y, GOAL_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(50, 180, 50, 0.3)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#00ff88";
    ctx.stroke();

    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#00ff88";
    ctx.textAlign = "center";
    ctx.fillText("GOAL", GOAL_X, GOAL_Y + 4);
    ctx.restore();
}

/* ---------- Geometry helpers ---------- */

// Segment–segment intersection (p0->p1 with p2->p3)
// Returns {x, y, t, u} or null
function segmentIntersection(p0, p1, p2, p3) {
    const s1x = p1.x - p0.x;
    const s1y = p1.y - p0.y;
    const s2x = p3.x - p2.x;
    const s2y = p3.y - p2.y;

    const denom = (-s2x * s1y + s1x * s2y);
    if (denom === 0) return null; // Parallel or collinear

    const s = (-s1y * (p0.x - p2.x) + s1x * (p0.y - p2.y)) / denom;
    const t = ( s2x * (p0.y - p2.y) - s2y * (p0.x - p2.x)) / denom;

    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
        return {
            x: p0.x + (t * s1x),
            y: p0.y + (t * s1y),
            t: t,
            u: s
        };
    }
    return null;
}

// Circle vs rectangle collision (robot is a circle, walls are rects)
function circleIntersectsRect(cx, cy, radius, rect) {
    const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
    const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) < (radius * radius);
}

/* ---------- Robot class ---------- */

class Robot {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 10;
        this.angle = Math.random() * Math.PI * 2; // heading in radians
        this.speed = 1.8;

        // Sensor configuration (angles relative to heading)
        this.sensorLength = 100;
        this.sensorAngles = [
            -0.6,  // far left
            -0.25, // mid left
            0,     // center
            0.25,  // mid right
            0.6    // far right
        ];

        this.sensorHits = [];  // info per sensor for drawing

        // Cooldown after a turn to avoid jitter
        this.turnCooldown = 0;
        this.turnCooldownMax = 20;
    }

    update() {
        if (gameOver) return;

        // Check sensors (raycasting)
        const hits = this.checkSensors();

        // If any sensor is hitting something and we are not in cooldown, rotate
        const anyHit = hits.some(h => h.hit);
        if (anyHit && this.turnCooldown === 0) {
            // Random direction and magnitude
            const direction = Math.random() < 0.5 ? -1 : 1;
            const angleChange = (0.4 + Math.random() * 1.0) * direction; // ~23° to ~80°
            this.angle += angleChange;
            this.turnCooldown = this.turnCooldownMax;
        }

        if (this.turnCooldown > 0) {
            this.turnCooldown--;
        }

        // Move forward
        const newX = this.x + Math.cos(this.angle) * this.speed;
        const newY = this.y + Math.sin(this.angle) * this.speed;

        // Check collision with walls
        let collided = false;
        for (const w of walls) {
            if (circleIntersectsRect(newX, newY, this.radius, w)) {
                collided = true;
                break;
            }
        }

        if (!collided) {
            this.x = newX;
            this.y = newY;
        } else {
            // If collision, backtrack slightly and turn randomly
            const backX = this.x - Math.cos(this.angle) * this.speed * 2;
            const backY = this.y - Math.sin(this.angle) * this.speed * 2;
            this.x = backX;
            this.y = backY;
            this.angle += (Math.random() - 0.5) * Math.PI; // big random turn
            this.turnCooldown = this.turnCooldownMax;
        }
    }

    checkSensors() {
        this.sensorHits = [];

        for (const relAngle of this.sensorAngles) {
            const sensorDir = this.angle + relAngle;

            const start = { x: this.x, y: this.y };
            const end = {
                x: this.x + Math.cos(sensorDir) * this.sensorLength,
                y: this.y + Math.sin(sensorDir) * this.sensorLength
            };

            let closestHit = null;
            let closestT = Infinity;

            // Check ray against all walls (their edges)
            for (const w of walls) {
                const edges = [
                    // top
                    { a: { x: w.x,         y: w.y },         b: { x: w.x + w.w, y: w.y } },
                    // bottom
                    { a: { x: w.x,         y: w.y + w.h },   b: { x: w.x + w.w, y: w.y + w.h } },
                    // left
                    { a: { x: w.x,         y: w.y },         b: { x: w.x,       y: w.y + w.h } },
                    // right
                    { a: { x: w.x + w.w,   y: w.y },         b: { x: w.x + w.w, y: w.y + w.h } }
                ];

                for (const edge of edges) {
                    const result = segmentIntersection(start, end, edge.a, edge.b);
                    if (result && result.t < closestT) {
                        closestT = result.t;
                        closestHit = { x: result.x, y: result.y };
                    }
                }
            }

            if (closestHit) {
                this.sensorHits.push({
                    angle: sensorDir,
                    hit: true,
                    from: start,
                    to: closestHit
                });
            } else {
                this.sensorHits.push({
                    angle: sensorDir,
                    hit: false,
                    from: start,
                    to: end
                });
            }
        }

        return this.sensorHits;
    }

    hasReachedGoal() {
        const dx = this.x - GOAL_X;
        const dy = this.y - GOAL_Y;
        const dist2 = dx * dx + dy * dy;
        return dist2 < (GOAL_RADIUS * GOAL_RADIUS);
    }

    draw(ctx) {
        // Draw sensors
        for (const s of this.sensorHits) {
            ctx.beginPath();
            ctx.moveTo(s.from.x, s.from.y);
            ctx.lineTo(s.to.x, s.to.y);
            ctx.strokeStyle = s.hit ? "#ff5555" : "#55ff55"; // red if hit, green otherwise
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Draw robot body
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Body
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#dddddd";
        ctx.fill();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "#333333";
        ctx.stroke();

        // "Front" indicator
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.radius, 0);
        ctx.strokeStyle = "#00aaff";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();
    }
}

/* ---------- Simulation loop ---------- */

createMaze();

// Create 100 robots starting near the top-left corner, inside the maze
const robots = [];
const NUM_ROBOTS = 100;

// Safe area near top-left, away from outer walls (20px border) and first vertical wall (x=150)
for (let i = 0; i < NUM_ROBOTS; i++) {
    const startX = 40 + Math.random() * 80; // between 40 and 120
    const startY = 40 + Math.random() * 80; // between 40 and 120
    robots.push(new Robot(startX, startY));
}

function drawGameOverOverlay() {
    ctx.save();
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "center";
    ctx.font = "28px sans-serif";
    ctx.fillText("A robot reached the goal!", canvas.width / 2, canvas.height / 2 - 10);

    ctx.font = "16px sans-serif";
    ctx.fillText("Reload the page to run the simulation again.", canvas.width / 2, canvas.height / 2 + 20);
    ctx.restore();
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawWalls();
    drawGoal();

    let someoneReached = false;

    for (const r of robots) {
        r.update();
        r.draw(ctx);
        if (!gameOver && r.hasReachedGoal()) {
            someoneReached = true;
        }
    }

    if (someoneReached) {
        gameOver = true;
        drawGameOverOverlay();
        return; // stop the loop
    }

    if (!gameOver) {
        requestAnimationFrame(loop);
    }
}

loop();
</script>
</body>
</html>

