<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Simulación de robots tipo Roomba (evolutivos)</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            background: radial-gradient(circle at top left, #1b2735 0%, #090a0f 40%, #000000 100%);
            height: 100vh;
            color: #eee;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            overflow: hidden;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
            padding: 16px;
            gap: 16px;
        }
        #leftPane {
            flex: 1 1 auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #rightPane {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        #sim {
            background: radial-gradient(circle at center, #141820 0%, #050609 100%);
            border-radius: 14px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
            display: block;
            width: 100%;
            height: 100%;
        }
        #chart {
            background: linear-gradient(135deg, rgba(10,10,20,0.96), rgba(5,8,18,0.96));
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.45);
        }
        #info {
            background: linear-gradient(135deg, rgba(10,10,20,0.95), rgba(25,25,45,0.96));
            padding: 10px 14px;
            font-size: 12px;
            border-radius: 10px;
            white-space: pre-line;
            border: 1px solid rgba(120, 160, 255, 0.3);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            backdrop-filter: blur(6px);
        }
        #info strong {
            color: #9cc4ff;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="leftPane">
        <canvas id="sim"></canvas>
    </div>
    <div id="rightPane">
        <div id="info"></div>
        <canvas id="chart" width="280" height="170"></canvas>
    </div>
</div>

<script>
/* ---------- Configuración básica ---------- */
const simCanvas   = document.getElementById("sim");
const simCtx      = simCanvas.getContext("2d");
const infoDiv     = document.getElementById("info");
const chartCanvas = document.getElementById("chart");
const chartCtx    = chartCanvas.getContext("2d");

// Margen interno aproximado para el canvas de simulación
const margin = 16;
const SIDEBAR_WIDTH = 320;

// Ajuste de tamaño del canvas de simulación
simCanvas.width  = window.innerWidth  - SIDEBAR_WIDTH - margin * 3;
simCanvas.height = window.innerHeight - margin * 2;

// Rejilla del laberinto
const walls = [];
let cellSize;
let cols, rows;
let border = 20;

let GOAL_RADIUS = 35;
let GOAL_X = 0;
let GOAL_Y = 0;

// Zona de inicio (coordenadas para dibujarla)
let START_X = 0;
let START_Y = 0;
let START_RADIUS = 0;

const NUM_ROBOTS = 100;
let generation = 1;

// Tiempos (en segundos) para el robot más rápido de cada generación
let generationTimes = [];
let generationStartTime = performance.now();

// "Genes" del mejor robot hasta el momento
let bestGenes = null;

// Genes por defecto (primera generación) – ahora incluyen color y radio
const defaultGenes = {
    radius: 9,
    speed: 1.8,
    sensorLength: 95,
    sensorAngles: [-0.6, -0.25, 0, 0.25, 0.6],
    turnCooldownMax: 18,
    baseTurnAngle: 0.45,
    randomTurnRange: 0.9,
    hue: 200 // tono base (HSL) evolutivo
};

let robots = [];

/* ---------- Utilidades geométricas ---------- */

function segmentIntersection(p0, p1, p2, p3) {
    const s1x = p1.x - p0.x;
    const s1y = p1.y - p0.y;
    const s2x = p3.x - p2.x;
    const s2y = p3.y - p2.y;

    const denom = (-s2x * s1y + s1x * s2y);
    if (denom === 0) return null;

    const s = (-s1y * (p0.x - p2.x) + s1x * (p0.y - p2.y)) / denom;
    const t = ( s2x * (p0.y - p2.y) - s2y * (p0.x - p2.x)) / denom;

    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
        return {
            x: p0.x + (t * s1x),
            y: p0.y + (t * s1y),
            t: t,
            u: s
        };
    }
    return null;
}

function circleIntersectsRect(cx, cy, radius, rect) {
    const closestX = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
    const closestY = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) < (radius * radius);
}

/* ---------- Generación de laberinto clásico (DFS en rejilla) ---------- */

function createMaze() {
    walls.length = 0;

    const W = simCanvas.width;
    const H = simCanvas.height;

    const targetCell = 100;
    const usableW = W - 2 * border;
    const usableH = H - 2 * border;

    cols = Math.max(1, Math.floor(usableW / targetCell));
    rows = Math.max(1, Math.floor(usableH / targetCell));

    cellSize = Math.min(usableW / cols, usableH / rows);

    const usedW = cols * cellSize;
    const usedH = rows * cellSize;
    border = 0.5 * (Math.min(W - usedW, H - usedH));

    const grid = [];
    for (let y = 0; y < rows; y++) {
        const row = [];
        for (let x = 0; x < cols; x++) {
            row.push({
                x,
                y,
                visited: false,
                walls: { top: true, right: true, bottom: true, left: true }
            });
        }
        grid.push(row);
    }

    function neighbours(cell) {
        const list = [];
        const { x, y } = cell;
        if (y > 0) list.push(grid[y - 1][x]);
        if (x < cols - 1) list.push(grid[y][x + 1]);
        if (y < rows - 1) list.push(grid[y + 1][x]);
        if (x > 0) list.push(grid[y][x - 1]);
        return list;
    }

    function removeWall(a, b) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        if (dx === 1)      { a.walls.right  = false; b.walls.left   = false; }
        else if (dx === -1){ a.walls.left   = false; b.walls.right  = false; }
        else if (dy === 1) { a.walls.bottom = false; b.walls.top    = false; }
        else if (dy === -1){ a.walls.top    = false; b.walls.bottom = false; }
    }

    // DFS con backtracking
    const stack = [];
    const startCell = grid[0][0];
    startCell.visited = true;
    stack.push(startCell);

    while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const neigh = neighbours(current).filter(n => !n.visited);

        if (neigh.length === 0) {
            stack.pop();
        } else {
            const next = neigh[Math.floor(Math.random() * neigh.length)];
            next.visited = true;
            removeWall(current, next);
            stack.push(next);
        }
    }

    const wallThickness = Math.max(4, cellSize * 0.14);

    function cellToX(c) { return border + c * cellSize; }
    function cellToY(r) { return border + r * cellSize; }

    // META y zona de inicio (para dibujar)
    GOAL_X = cellToX(cols - 1) + cellSize / 2;
    GOAL_Y = cellToY(rows - 1) + cellSize / 2;
    GOAL_RADIUS = cellSize * 0.35;

    START_X = cellToX(0) + cellSize / 2;
    START_Y = cellToY(0) + cellSize / 2;
    START_RADIUS = cellSize * 0.32;

    // Construcción de paredes
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            const c = grid[y][x];
            const cx = cellToX(x);
            const cy = cellToY(y);

            // superior
            if (c.walls.top && y === 0) {
                walls.push({ x: cx, y: cy, w: cellSize, h: wallThickness });
            }
            // izquierda
            if (c.walls.left && x === 0) {
                walls.push({ x: cx, y: cy, w: wallThickness, h: cellSize });
            }
            // inferior interna
            if (c.walls.bottom && y < rows - 1) {
                walls.push({
                    x: cx,
                    y: cy + cellSize - wallThickness / 2,
                    w: cellSize,
                    h: wallThickness
                });
            }
            // derecha interna
            if (c.walls.right && x < cols - 1) {
                walls.push({
                    x: cx + cellSize - wallThickness / 2,
                    y: cy,
                    w: wallThickness,
                    h: cellSize
                });
            }
            // bordes exteriores adicionales
            if (y === rows - 1 && c.walls.bottom) {
                walls.push({
                    x: cx,
                    y: cy + cellSize - wallThickness,
                    w: cellSize,
                    h: wallThickness
                });
            }
            if (x === cols - 1 && c.walls.right) {
                walls.push({
                    x: cx + cellSize - wallThickness,
                    y: cy,
                    w: wallThickness,
                    h: cellSize
                });
            }
        }
    }
}

function drawBackgroundGrid() {
    // leve cuadriculado de fondo
    simCtx.save();
    simCtx.globalAlpha = 0.15;
    simCtx.strokeStyle = "#1f2933";
    simCtx.lineWidth = 1;

    for (let x = 0; x <= cols; x++) {
        const gx = border + x * cellSize;
        simCtx.beginPath();
        simCtx.moveTo(gx, border);
        simCtx.lineTo(gx, border + rows * cellSize);
        simCtx.stroke();
    }
    for (let y = 0; y <= rows; y++) {
        const gy = border + y * cellSize;
        simCtx.beginPath();
        simCtx.moveTo(border, gy);
        simCtx.lineTo(border + cols * cellSize, gy);
        simCtx.stroke();
    }
    simCtx.restore();
}

function drawWalls() {
    simCtx.save();
    simCtx.shadowColor = "rgba(0, 0, 0, 0.8)";
    simCtx.shadowBlur = 8;
    simCtx.fillStyle = "#1f3b4d";
    for (const w of walls) {
        simCtx.fillRect(w.x, w.y, w.w, w.h);
    }
    simCtx.shadowBlur = 0;
    simCtx.globalAlpha = 0.4;
    simCtx.strokeStyle = "#56c7ff";
    simCtx.lineWidth = 1;
    for (const w of walls) {
        simCtx.strokeRect(w.x, w.y, w.w, w.h);
    }
    simCtx.restore();
}

function drawStart() {
    simCtx.save();
    // halo
    simCtx.globalAlpha = 0.4;
    const haloR = START_RADIUS * 1.5;
    const grad = simCtx.createRadialGradient(
        START_X, START_Y, START_RADIUS * 0.3,
        START_X, START_Y, haloR
    );
    grad.addColorStop(0, "rgba(120, 220, 255, 0.6)");
    grad.addColorStop(1, "rgba(120, 220, 255, 0.0)");
    simCtx.fillStyle = grad;
    simCtx.beginPath();
    simCtx.arc(START_X, START_Y, haloR, 0, Math.PI * 2);
    simCtx.fill();

    // círculo principal
    simCtx.globalAlpha = 1;
    simCtx.beginPath();
    simCtx.arc(START_X, START_Y, START_RADIUS, 0, Math.PI * 2);
    simCtx.fillStyle = "rgba(120, 220, 255, 0.25)";
    simCtx.fill();
    simCtx.lineWidth = 2;
    simCtx.strokeStyle = "#7fe4ff";
    simCtx.stroke();

    simCtx.font = "12px system-ui";
    simCtx.fillStyle = "#bfefff";
    simCtx.textAlign = "center";
    simCtx.fillText("INICIO", START_X, START_Y + 4);
    simCtx.restore();
}

function drawGoal() {
    simCtx.save();
    // halo
    simCtx.globalAlpha = 0.5;
    const haloR = GOAL_RADIUS * 1.7;
    const grad = simCtx.createRadialGradient(
        GOAL_X, GOAL_Y, GOAL_RADIUS * 0.3,
        GOAL_X, GOAL_Y, haloR
    );
    grad.addColorStop(0, "rgba(80, 255, 160, 0.7)");
    grad.addColorStop(1, "rgba(80, 255, 160, 0.0)");
    simCtx.fillStyle = grad;
    simCtx.beginPath();
    simCtx.arc(GOAL_X, GOAL_Y, haloR, 0, Math.PI * 2);
    simCtx.fill();

    // círculo principal
    simCtx.globalAlpha = 1;
    simCtx.beginPath();
    simCtx.arc(GOAL_X, GOAL_Y, GOAL_RADIUS, 0, Math.PI * 2);
    simCtx.fillStyle = "rgba(80, 255, 160, 0.20)";
    simCtx.fill();
    simCtx.lineWidth = 2;
    simCtx.strokeStyle = "#5affb0";
    simCtx.stroke();

    simCtx.font = "12px system-ui";
    simCtx.fillStyle = "#caffde";
    simCtx.textAlign = "center";
    simCtx.fillText("META", GOAL_X, GOAL_Y + 4);
    simCtx.restore();
}

/* ---------- Clase Robot ---------- */

class Robot {
    constructor(x, y, genes) {
        const g = genes || defaultGenes;

        this.x = x;
        this.y = y;
        this.radius = g.radius;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = g.speed;

        this.sensorLength = g.sensorLength;
        this.sensorAngles = g.sensorAngles.slice();

        this.sensorHits = [];

        this.turnCooldown = 0;
        this.turnCooldownMax = g.turnCooldownMax;
        this.baseTurnAngle = g.baseTurnAngle;
        this.randomTurnRange = g.randomTurnRange;

        // Color basado en los genes, con ligera variación individual
        const baseHue = g.hue !== undefined ? g.hue : Math.random() * 360;
        this.hue = (baseHue + (Math.random() * 60 - 30) + 360) % 360;

        this.history = [];
        this.historyMax = 14;
    }

    update() {
        const hits = this.checkSensors();

        const anyHit = hits.some(h => h.hit);
        if (anyHit && this.turnCooldown === 0) {
            const direction = Math.random() < 0.5 ? -1 : 1;
            const angleChange =
                (this.baseTurnAngle + Math.random() * this.randomTurnRange) * direction;
            this.angle += angleChange;
            this.turnCooldown = this.turnCooldownMax;
        }

        if (this.turnCooldown > 0) {
            this.turnCooldown--;
        }

        const newX = this.x + Math.cos(this.angle) * this.speed;
        const newY = this.y + Math.sin(this.angle) * this.speed;

        let collided = false;
        for (const w of walls) {
            if (circleIntersectsRect(newX, newY, this.radius, w)) {
                collided = true;
                break;
            }
        }

        if (!collided) {
            this.x = newX;
            this.y = newY;
        } else {
            const backX = this.x - Math.cos(this.angle) * this.speed * 2;
            const backY = this.y - Math.sin(this.angle) * this.speed * 2;
            this.x = backX;
            this.y = backY;
            this.angle += (Math.random() - 0.5) * Math.PI;
            this.turnCooldown = this.turnCooldownMax;
        }

        // actualizar historial (estela)
        this.history.push({ x: this.x, y: this.y });
        if (this.history.length > this.historyMax) {
            this.history.shift();
        }
    }

    checkSensors() {
        this.sensorHits = [];

        for (const relAngle of this.sensorAngles) {
            const sensorDir = this.angle + relAngle;

            const start = { x: this.x, y: this.y };
            const end = {
                x: this.x + Math.cos(sensorDir) * this.sensorLength,
                y: this.y + Math.sin(sensorDir) * this.sensorLength
            };

            let closestHit = null;
            let closestT = Infinity;

            for (const w of walls) {
                const edges = [
                    { a: { x: w.x,         y: w.y },         b: { x: w.x + w.w, y: w.y } },
                    { a: { x: w.x,         y: w.y + w.h },   b: { x: w.x + w.w, y: w.y + w.h } },
                    { a: { x: w.x,         y: w.y },         b: { x: w.x,       y: w.y + w.h } },
                    { a: { x: w.x + w.w,   y: w.y },         b: { x: w.x + w.w, y: w.y + w.h } }
                ];

                for (const edge of edges) {
                    const result = segmentIntersection(start, end, edge.a, edge.b);
                    if (result && result.t < closestT) {
                        closestT = result.t;
                        closestHit = { x: result.x, y: result.y };
                    }
                }
            }

            if (closestHit) {
                this.sensorHits.push({
                    angle: sensorDir,
                    hit: true,
                    from: start,
                    to: closestHit
                });
            } else {
                this.sensorHits.push({
                    angle: sensorDir,
                    hit: false,
                    from: start,
                    to: end
                });
            }
        }

        return this.sensorHits;
    }

    hasReachedGoal() {
        const dx = this.x - GOAL_X;
        const dy = this.y - GOAL_Y;
        const dist2 = dx * dx + dy * dy;
        return dist2 < (GOAL_RADIUS * GOAL_RADIUS);
    }

    drawTrail(ctx) {
        if (this.history.length < 2) return;

        ctx.save();
        ctx.lineWidth = 1.5;
        for (let i = 1; i < this.history.length; i++) {
            const p0 = this.history[i - 1];
            const p1 = this.history[i];
            const t = i / (this.history.length - 1);
            ctx.strokeStyle = `hsla(${this.hue}, 80%, ${40 + 20 * t}%, ${0.12 + 0.2 * t})`;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.stroke();
        }
        ctx.restore();
    }

    draw(ctx) {
        // Estela
        this.drawTrail(ctx);

        // Sensores
        ctx.save();
        ctx.globalAlpha = 0.35;
        for (const s of this.sensorHits) {
            ctx.beginPath();
            ctx.moveTo(s.from.x, s.from.y);
            ctx.lineTo(s.to.x, s.to.y);
            ctx.strokeStyle = s.hit
                ? `hsla(${this.hue}, 100%, 70%, 0.8)`
                : `hsla(${this.hue}, 70%, 55%, 0.5)`;
            ctx.lineWidth = 1.2;
            ctx.stroke();
        }
        ctx.restore();

        // Cuerpo del robot
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        const innerGrad = ctx.createRadialGradient(
            0, 0, this.radius * 0.1,
            0, 0, this.radius
        );
        innerGrad.addColorStop(0, `hsl(${this.hue}, 80%, 75%)`);
        innerGrad.addColorStop(1, `hsl(${this.hue}, 60%, 35%)`);

        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = innerGrad;
        ctx.fill();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "rgba(0,0,0,0.7)";
        ctx.stroke();

        // "tapa" superior para efecto bisel
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.65, -Math.PI * 0.1, Math.PI * 1.1);
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.fill();

        // indicador de frente
        ctx.beginPath();
        ctx.moveTo(this.radius * 0.3, 0);
        ctx.lineTo(this.radius * 0.95, 0);
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();
    }
}

/* ---------- Evolución ---------- */

function mutateValue(value, factor, minVal, maxVal) {
    const delta = (Math.random() * 2 - 1) * factor;
    let v = value * (1 + delta);
    if (minVal !== undefined) v = Math.max(minVal, v);
    if (maxVal !== undefined) v = Math.min(maxVal, v);
    return v;
}

function mutateHue(hue, range = 40) {
    let h = hue + (Math.random() * 2 - 1) * range;
    h %= 360;
    if (h < 0) h += 360;
    return h;
}

function mutateGenes(parent) {
    const g = {
        // radio evolutivo
        radius: mutateValue(parent.radius, 0.2, 4, 22),
        // velocidad evolutiva
        speed: mutateValue(parent.speed, 0.22, 0.5, 4.0),
        sensorLength: mutateValue(parent.sensorLength, 0.25, 40, 260),
        turnCooldownMax: Math.round(mutateValue(parent.turnCooldownMax, 0.3, 5, 80)),
        // parámetros de giro evolutivos
        baseTurnAngle: mutateValue(parent.baseTurnAngle, 0.25, 0.08, 1.2),
        randomTurnRange: mutateValue(parent.randomTurnRange, 0.3, 0.2, 2.5),
        sensorAngles: parent.sensorAngles.slice(),
        // color evolutivo
        hue: mutateHue(parent.hue !== undefined ? parent.hue : 200, 40)
    };

    for (let i = 0; i < g.sensorAngles.length; i++) {
        g.sensorAngles[i] += (Math.random() * 2 - 1) * 0.09;
    }

    g.sensorAngles.sort((a, b) => a - b);
    return g;
}

function extractGenesFromRobot(robot) {
    return {
        radius: robot.radius,
        speed: robot.speed,
        sensorLength: robot.sensorLength,
        sensorAngles: robot.sensorAngles.slice(),
        turnCooldownMax: robot.turnCooldownMax,
        baseTurnAngle: robot.baseTurnAngle,
        randomTurnRange: robot.randomTurnRange,
        hue: robot.hue
    };
}

/* ---------- Gestión de simulación ---------- */

function resetSimulation() {
    robots = [];
    const parentGenes = bestGenes || defaultGenes;

    // Nuevo laberinto clásico
    createMaze();

    // Centro de la celda (0,0)
    const startCellX = START_X;
    const startCellY = START_Y;
    const spread = cellSize * 0.25;

    for (let i = 0; i < NUM_ROBOTS; i++) {
        // siempre hay variación evolutiva a partir de los genes del "padre"
        const genes = mutateGenes(parentGenes);

        const startX = startCellX + (Math.random() * 2 - 1) * spread;
        const startY = startCellY + (Math.random() * 2 - 1) * spread;

        robots.push(new Robot(startX, startY, genes));
    }

    generationStartTime = performance.now();
}

function updateInfo() {
    let text = `<strong>Generación:</strong> ${generation}
Robots: ${NUM_ROBOTS}`;

    if (bestGenes && generationTimes.length > 0) {
        const lastTime = generationTimes[generationTimes.length - 1];
        const bestTime = Math.min(...generationTimes);
        text += `

<strong>Mejores genes (ganador generación anterior):</strong>
· color (hue): ${bestGenes.hue.toFixed(1)}°
· radio: ${bestGenes.radius.toFixed(2)}
· velocidad: ${bestGenes.speed.toFixed(2)}
· longitud sensores: ${bestGenes.sensorLength.toFixed(1)}
· enfriamiento giro: ${bestGenes.turnCooldownMax}
· ángulo base giro: ${bestGenes.baseTurnAngle.toFixed(2)}
· rango giro aleatorio: ${bestGenes.randomTurnRange.toFixed(2)}

Tiempo última generación: ${lastTime.toFixed(2)} s
Mejor tiempo histórico: ${bestTime.toFixed(2)} s`;
    } else {
        text += `

<strong>Mejores genes:</strong> ninguno todavía (evolucionando...)`;
    }

    infoDiv.innerHTML = text;
}

/* ---------- Gráfico de barras (canvas separado) ---------- */

function drawChart() {
    chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
    if (generationTimes.length === 0) return;

    const chartWidth  = chartCanvas.width;
    const chartHeight = chartCanvas.height;

    const padding = 10;
    const innerX = 40;
    const innerY = 26;
    const innerWidth  = chartWidth - innerX - padding;
    const innerHeight = chartHeight - innerY - 18;

    // fondo
    const bgGrad = chartCtx.createLinearGradient(0, 0, 0, chartHeight);
    bgGrad.addColorStop(0, "rgba(10, 16, 30, 0.96)");
    bgGrad.addColorStop(1, "rgba(5, 8, 18, 0.96)");
    chartCtx.fillStyle = bgGrad;
    chartCtx.fillRect(0, 0, chartWidth, chartHeight);

    chartCtx.strokeStyle = "rgba(120,160,255,0.7)";
    chartCtx.lineWidth = 1;
    chartCtx.strokeRect(0.5, 0.5, chartWidth - 1, chartHeight - 1);

    chartCtx.fillStyle = "#e5eeff";
    chartCtx.font = "11px system-ui";
    chartCtx.textAlign = "left";
    chartCtx.fillText("Tiempo hasta la meta (s)", 8, 16);

    const maxBars = 30;
    const data = generationTimes.slice(-maxBars);
    const maxTime = Math.max(...data);
    const minTime = Math.min(...data);
    const bestTime = Math.min(...generationTimes);

    // rejilla horizontal
    chartCtx.strokeStyle = "rgba(255,255,255,0.08)";
    chartCtx.lineWidth = 1;
    const gridLines = 4;
    for (let i = 0; i <= gridLines; i++) {
        const gy = innerY + (innerHeight / gridLines) * i;
        chartCtx.beginPath();
        chartCtx.moveTo(innerX, gy);
        chartCtx.lineTo(innerX + innerWidth, gy);
        chartCtx.stroke();
    }

    // ejes
    chartCtx.strokeStyle = "rgba(200,220,255,0.6)";
    chartCtx.beginPath();
    chartCtx.moveTo(innerX, innerY);
    chartCtx.lineTo(innerX, innerY + innerHeight);
    chartCtx.lineTo(innerX + innerWidth, innerY + innerHeight);
    chartCtx.stroke();

    // textos min / max
    chartCtx.fillStyle = "#c5d7ff";
    chartCtx.textAlign = "right";
    chartCtx.fillText(maxTime.toFixed(1), innerX - 4, innerY + 9);
    chartCtx.fillText(minTime.toFixed(1), innerX - 4, innerY + innerHeight);

    const barCount = data.length;
    const barGap = 2;
    const barWidth = Math.max(3, (innerWidth - barGap * (barCount - 1)) / barCount);

    chartCtx.textAlign = "center";

    for (let i = 0; i < barCount; i++) {
        const t = data[i];
        const norm = t / maxTime;
        const barH = norm * innerHeight;
        const x = innerX + i * (barWidth + barGap);
        const y = innerY + innerHeight - barH;

        const gGlobalIndex = generationTimes.length - data.length + i;
        const isBest = generationTimes[gGlobalIndex] === bestTime;

        const grad = chartCtx.createLinearGradient(x, y, x, y + barH);
        if (isBest) {
            grad.addColorStop(0, "rgba(102, 255, 204, 0.95)");
            grad.addColorStop(1, "rgba(46, 204, 113, 0.85)");
        } else {
            grad.addColorStop(0, "rgba(80, 190, 255, 0.95)");
            grad.addColorStop(1, "rgba(0, 118, 210, 0.85)");
        }
        chartCtx.fillStyle = grad;
        chartCtx.fillRect(x, y, barWidth, barH);

        if ((i + 1) % 5 === 0 || i === barCount - 1) {
            const genIndex = generationTimes.length - data.length + i + 1;
            chartCtx.fillStyle = "#dde6ff";
            chartCtx.font = "9px system-ui";
            chartCtx.fillText(genIndex, x + barWidth / 2, innerY + innerHeight + 11);
        }
    }
}

/* ---------- Bucle principal ---------- */

function loop() {
    simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);

    drawBackgroundGrid();
    drawWalls();
    drawStart();
    drawGoal();

    let winner = null;

    for (const r of robots) {
        r.update();
        r.draw(simCtx);

        if (!winner && r.hasReachedGoal()) {
            winner = r;
        }
    }

    if (winner) {
        const now = performance.now();
        const elapsedSeconds = (now - generationStartTime) / 1000.0;

        generationTimes.push(elapsedSeconds);
        bestGenes = extractGenesFromRobot(winner);
        generation++;
        resetSimulation();
        updateInfo();
    }

    drawChart();
    requestAnimationFrame(loop);
}

/* ---------- Inicio ---------- */
resetSimulation();
updateInfo();
loop();
</script>
</body>
</html>

