<!doctype html>
<html>
  <head>
    <style>
      body,html{margin:0px;padding:0px;}
    </style>
  </head>
  <body>
    <canvas></canvas>
    <script>
    
      function distance2D(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }
      function bounceAngle(incidentAngle, wallAngle) {
          const relative = incidentAngle - wallAngle;   // angle of incidence
          const reflectedRelative = -relative;          // mirror
          return reflectedRelative + wallAngle;         // return to world space
      }
      let anchura = window.innerWidth;
      let altura = window.innerHeight;
      let lienzo = document.querySelector("canvas")
      let contexto = lienzo.getContext("2d")
      lienzo.width = anchura
      lienzo.height = altura
      contexto.textAlign = "center";
      contexto.textBaseline = "middle";
      let nombres = ['Juan','Julia','Jorge','Jaime','Jose','Julian']
      
      class Particula{
          constructor(x,y,a){
              this.x = x;
              this.y = y;
              this.a = a;
              this.v = 0.5
              this.texto = nombres[Math.floor(Math.random()*nombres.length)]
          }
          dibuja(){
              let anchopastilla = 20
              let altopastilla = 10
              contexto.strokeStyle = "black"
              contexto.beginPath();
              contexto.moveTo(this.x-anchopastilla,this.y-altopastilla)
              contexto.lineTo(this.x+anchopastilla,this.y-altopastilla)
              contexto.arc(this.x+anchopastilla,this.y,altopastilla,0-Math.PI/2,Math.PI-Math.PI/2)
              contexto.lineTo(this.x-anchopastilla,this.y+10)
              contexto.arc(this.x-anchopastilla,this.y,altopastilla,Math.PI-Math.PI/2,0-Math.PI/2)
              contexto.fillStyle = "white"
              contexto.strokeStyle = "black";
              contexto.fill();
              contexto.stroke()
              contexto.fillStyle = "black"
              contexto.fillText(this.texto,this.x,this.y)
          }
          lineas(){
            contexto.strokeStyle = "grey"
              for(let i = 0;i<numeroparticulas;i++){
                  if(distance2D(this.x, this.y, particulas[i].x, particulas[i].y) < 100){
                      contexto.beginPath();
                      contexto.moveTo(this.x,this.y);
                      contexto.lineTo(particulas[i].x, particulas[i].y);
                      contexto.stroke();
                  }
              }
          }
          mueve(){
              //this.a += (Math.random()-0.5) * 0.1;
              this.x += Math.cos(this.a)*this.v;
              this.y += Math.sin(this.a)*this.v;
          }

          rebote(){
              // Right wall
              if (this.x > anchura) {
                  this.x = anchura;
                  this.a = bounceAngle(this.a, Math.PI/2); // wall angle = vertical
              }
              // Left wall
              if (this.x < 0) {
                  this.x = 0;
                  this.a = bounceAngle(this.a, Math.PI/2);
              }

              // Bottom wall
              if (this.y > altura) {
                  this.y = altura;
                  this.a = bounceAngle(this.a, 0); // horizontal wall
              }
              // Top wall
              if (this.y < 0) {
                  this.y = 0;
                  this.a = bounceAngle(this.a, 0);
              }
          }
          interacciones(particulas) {
              let rango = 340;          // detection radius
              let fuerzaAtraccion = 0.03;
              let fuerzaRepulsion = 0.05;
              let distanciaMin = 135;    // ✔️ minimum spacing between same particles

              let ax = 0;
              let ay = 0;

              for (let p of particulas) {
                  if (p === this) continue;

                  let d = distance2D(this.x, this.y, p.x, p.y);
                  if (d > rango || d === 0) continue;

                  let dx = p.x - this.x;
                  let dy = p.y - this.y;

                  // Normalize direction
                  let ux = dx / d;
                  let uy = dy / d;

                  if (p.texto === this.texto) {

                      if (d > distanciaMin) {
                          // ✔️ Farther than minimum: attract
                          ax += ux;
                          ay += uy;
                      } else {
                          // ❌ Too close: gently push away
                          ax -= ux * 2;
                          ay -= uy * 2;
                      }

                  } else {
                      // ❌ Repel different text
                      ax -= ux * fuerzaRepulsion;
                      ay -= uy * fuerzaRepulsion;
                  }
              }

              // Apply steering
              if (ax !== 0 || ay !== 0) {
                  let targetAngle = Math.atan2(ay, ax);
                  let diff = targetAngle - this.a;
                  diff = Math.atan2(Math.sin(diff), Math.cos(diff)); // normalize
                  this.a += diff * fuerzaAtraccion;
              }
          }


      }

      let particulas = [];
      let numeroparticulas = 250
      
      for(let i = 0;i<numeroparticulas;i++){
        particulas.push(
          new Particula(
            Math.random()*anchura,
            Math.random()*altura,
            Math.random()*Math.PI*2
          )
        )
      }
      let temporizador = setTimeout("bucle()",1000)
      function bucle(){
        contexto.clearRect(0,0,anchura,altura)
        // Las particulas
        for (let i = 0; i < numeroparticulas; i++) {
            particulas[i].interacciones(particulas);
            particulas[i].mueve();
            particulas[i].lineas();
            particulas[i].dibuja();
            particulas[i].rebote();
        }

        clearTimeout(temporizador)
        temporizador = setTimeout("bucle()",10)
      }
      
    </script>
  </body>
</html>
