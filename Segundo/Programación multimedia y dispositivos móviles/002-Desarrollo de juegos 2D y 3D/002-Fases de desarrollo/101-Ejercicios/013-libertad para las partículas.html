<!doctype html>
<html>
  <head>
    <style>
      body,html{
        margin:0;
        padding:0;
        background:#ffffff;
      }
    </style>
  </head>
  <body>
    <canvas></canvas>
    <script>
      function distance2D(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
      }

      let anchura = window.innerWidth;
      let altura = window.innerHeight;
      let lienzo = document.querySelector("canvas");
      let contexto = lienzo.getContext("2d");
      lienzo.width = anchura;
      lienzo.height = altura;
      contexto.textAlign = "center";
      contexto.textBaseline = "middle";

      let nombres = ['Juan','Julia','Jorge','Jaime','Jose','Julian'];

      class Particula{
        constructor(x,y,a){
          this.x = x;
          this.y = y;
          this.v = 0.5;        // velocidad base inicial

          // velocidad inicial a partir del ángulo
          this.vx = Math.cos(a) * this.v;
          this.vy = Math.sin(a) * this.v;

          // aceleración (fuerzas acumuladas)
          this.ax = 0;
          this.ay = 0;

          this.texto = nombres[Math.floor(Math.random()*nombres.length)];

          // control de estabilidad
          this.fija = false;
          this.estableFrames = 0;
        }

        dibuja(){
          let anchopastilla = 20;
          let altopastilla = 10;
          contexto.strokeStyle = "black";
          contexto.beginPath();
          contexto.moveTo(this.x-anchopastilla,this.y-altopastilla);
          contexto.lineTo(this.x+anchopastilla,this.y-altopastilla);
          contexto.arc(this.x+anchopastilla,this.y,altopastilla,0-Math.PI/2,Math.PI-Math.PI/2);
          contexto.lineTo(this.x-anchopastilla,this.y+10);
          contexto.arc(this.x-anchopastilla,this.y,altopastilla,Math.PI-Math.PI/2,0-Math.PI/2);
          contexto.fillStyle = "white";
          contexto.strokeStyle = "black";
          contexto.fill();
          contexto.stroke();
          contexto.fillStyle = "black";
          contexto.fillText(this.texto,this.x,this.y);
        }

        lineas(){
          for(let i = 0;i<numeroparticulas;i++){
            const p = particulas[i];
            if (p === this) continue;
            const d = distance2D(this.x, this.y, p.x, p.y);
            if(d < 160){ // rango visual de conexiones
              contexto.strokeStyle = "rgba(128,128,128,0.3)";
              contexto.beginPath();
              contexto.moveTo(this.x,this.y);
              contexto.lineTo(p.x, p.y);
              contexto.stroke();
            }
          }
        }

        interacciones(particulas) {
          if (this.fija) {
            // las partículas fijas no se mueven ni se recalculan fuerzas
            this.ax = 0;
            this.ay = 0;
            return;
          }

          // radio de búsqueda: toda la pantalla (diagonal)
          let rangoGlobal = Math.sqrt(anchura*anchura + altura*altura);

          // parámetros de interacción
          let distanciaObjetivo = 120;         // distancia "ideal" entre iguales
          let distanciaMinima = 80;            // distancia mínima para evitar solapamiento
          let distanciaRepulsionDistinto = 200; // hasta aquí repelen distinto

          let kAtraccionIgual = 0.0012;       // muelle entre iguales
          let kRepulsionDistinto = 0.001;     // repulsión suave entre distintos
          let kRepulsionCorta = 0.06;         // repulsión fuerte muy cercana

          let fx = 0;
          let fy = 0;

          for (let p of particulas) {
            if (p === this) continue;

            let d = distance2D(this.x, this.y, p.x, p.y);
            if (d === 0 || d > rangoGlobal) continue;

            let dx = p.x - this.x;
            let dy = p.y - this.y;

            let ux = dx / d;
            let uy = dy / d;

            // repulsión fuerte para evitar solapamiento, independientemente del texto
            if (d < distanciaMinima) {
              let intensidad = (distanciaMinima - d) * kRepulsionCorta;
              fx -= ux * intensidad;
              fy -= uy * intensidad;
              continue;
            }

            if (p.texto === this.texto) {
              // atracción + ajuste hacia distanciaObjetivo
              let delta = d - distanciaObjetivo; // si d > objetivo, delta > 0 => atrae; si <, repele suave
              fx += ux * delta * kAtraccionIgual;
              fy += uy * delta * kAtraccionIgual;
            } else {
              // repulsión solo si está relativamente cerca
              if (d < distanciaRepulsionDistinto) {
                let intensidad = (distanciaRepulsionDistinto - d) * kRepulsionDistinto;
                fx -= ux * intensidad;
                fy -= uy * intensidad;
              }
            }
          }

          // limitar la fuerza total para evitar inestabilidades numéricas
          const maxForce = 0.05;
          let fmag = Math.sqrt(fx*fx + fy*fy);
          if (fmag > maxForce) {
            fx = fx / fmag * maxForce;
            fy = fy / fmag * maxForce;
          }

          this.ax = fx;
          this.ay = fy;
        }

        mueve(){
          if (this.fija) return;

          // integrar aceleración -> velocidad
          this.vx += this.ax;
          this.vy += this.ay;

          // fricción para que el sistema tienda a parar
          const friccion = 0.93;
          this.vx *= friccion;
          this.vy *= friccion;

          // integrar velocidad -> posición
          this.x += this.vx;
          this.y += this.vy;

          // comprobar estabilidad
          const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
          const fuerza = Math.sqrt(this.ax*this.ax + this.ay*this.ay);

          if (speed < 0.02 && fuerza < 0.002) {
            this.estableFrames++;
            // tras cierto número de frames casi sin fuerza ni velocidad, se fija
            if (this.estableFrames > 60) {
              this.fija = true;
              this.vx = 0;
              this.vy = 0;
            }
          } else {
            this.estableFrames = 0;
          }
        }

        rebote(){
          if (this.fija) return;

          // choque con paredes con rebote amortiguado
          const reboteFactor = -0.5; // rebote con pérdida de energía

          // paredes verticales
          if (this.x > anchura) {
            this.x = anchura;
            this.vx *= reboteFactor;
          }
          if (this.x < 0) {
            this.x = 0;
            this.vx *= reboteFactor;
          }

          // paredes horizontales
          if (this.y > altura) {
            this.y = altura;
            this.vy *= reboteFactor;
          }
          if (this.y < 0) {
            this.y = 0;
            this.vy *= reboteFactor;
          }
        }
      }

      let particulas = [];
      let numeroparticulas = 250;

      for(let i = 0;i<numeroparticulas;i++){
        particulas.push(
          new Particula(
            Math.random()*anchura,
            Math.random()*altura,
            Math.random()*Math.PI*2
          )
        );
      }

      function bucle(){
        contexto.clearRect(0,0,anchura,altura);

        // primero calculamos fuerzas de interacción
        for (let i = 0; i < numeroparticulas; i++) {
          particulas[i].interacciones(particulas);
        }

        // después actualizamos movimiento y rebote
        for (let i = 0; i < numeroparticulas; i++) {
          particulas[i].mueve();
          particulas[i].rebote();
        }

        // dibujar conexiones y partículas (con posiciones ya actualizadas)
        for (let i = 0; i < numeroparticulas; i++) {
          particulas[i].lineas();
        }
        for (let i = 0; i < numeroparticulas; i++) {
          particulas[i].dibuja();
        }

        requestAnimationFrame(bucle);
      }

      // iniciar animación
      requestAnimationFrame(bucle);
    </script>
  </body>
</html>

