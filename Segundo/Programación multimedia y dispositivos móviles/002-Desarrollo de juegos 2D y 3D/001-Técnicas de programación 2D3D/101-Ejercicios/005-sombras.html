<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Parallax 3d</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- Environment component for gradient sky etc. -->
  <script src="https://cdn.jsdelivr.net/gh/feiss/aframe-environment-component/dist/aframe-environment-component.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
      color: #eee;
    }
    #video {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 220px;
      transform: scaleX(-1); /* mirror horizontally */
      opacity: 0.4;
      z-index: 10;
      border: 2px solid #444;
      border-radius: 4px;
    }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 20;
      background: rgba(0,0,0,0.6);
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #555;
      font-size: 14px;
    }
    #parallaxRange {
      width: 150px;
      vertical-align: middle;
    }
    label {
      margin-right: 4px;
    }
  </style>
</head>
<body>
  <!-- UI for parallax strength -->
  <div id="ui">
    <label for="parallaxRange">Parallax:</label>
    <input id="parallaxRange" type="range" min="0" max="5" step="0.05" value="1" />
    <span id="parallaxValue">1.00</span>
  </div>

  <!-- Webcam preview (debug) -->
  <video id="video" autoplay playsinline></video>

  <!-- 3D scene -->
  <a-scene
    renderer="antialias: true; colorManagement: true; physicallyCorrectLights: true; shadowMap.enabled: true; shadowMap.type: pcfsoft"
  >
    <!-- Gradient sky + distant ground (environment component) -->
    <a-entity environment="
      preset: default;
      ground: flat;
      groundYScale: 1;
      groundTexture: none;
      groundColor: #303030;
      groundColor2: #404040;
      skyType: gradient;
      skyColor: #88ccee;
      horizonColor: #ffffff;
      lighting: none;
    "></a-entity>

    <!-- MAIN GROUND PLANE near the camera, receiving shadows -->
    <a-plane position="0 0 0"
             rotation="-90 0 0"
             width="100"
             height="100"
             color="#404040"
             shadow="receive: true">
    </a-plane>

    <!-- Camera rig: above ground, at some distance looking towards origin -->
    <!-- Base camera position will be (0, baseY, baseZ) and we move around that -->
    <a-entity id="rig" position="0 1.6 0">
      <a-entity id="cam" camera look-controls="enabled: false"></a-entity>
    </a-entity>

    <!-- A target entity to orient the sun towards origin -->
    <a-entity id="sunTarget" position="0 0 0"></a-entity>

    <!-- Directional sun light with shadows -->
    <a-entity light="type: directional; intensity: 1.1; castShadow: true"
              position="4 8 6"
              target="#sunTarget">
    </a-entity>

    <!-- Soft ambient/global light -->
    <a-entity light="type: ambient; intensity: 0.35; color: #ffffff"></a-entity>

    <!-- PRIMITIVES SCATTERED ON THE PLANE (all casting / receiving shadows) -->

    <!-- Cluster 1 -->
    <a-sphere position="-2 0.5 -3"
              radius="0.5"
              color="#ff4444"
              shadow="cast: true; receive: true"></a-sphere>

    <a-box position="-0.8 0.4 -2.2"
           depth="0.6" height="0.6" width="0.6"
           color="#44ff44"
           shadow="cast: true; receive: true"></a-box>

    <a-cylinder position="0.6 0.5 -3.2"
                radius="0.3" height="1"
                color="#4444ff"
                shadow="cast: true; receive: true"></a-cylinder>

    <!-- Cluster 2 -->
    <a-torus-knot position="1.8 0.9 -4"
                   radius="0.6"
                   radius-tubular="0.08"
                   color="#ffcc00"
                   shadow="cast: true; receive: true"></a-torus-knot>

    <a-dodecahedron position="3 0.7 -5"
                    radius="0.5"
                    color="#ff00aa"
                    shadow="cast: true; receive: true"></a-dodecahedron>

    <a-octahedron position="-3 0.7 -4.5"
                  radius="0.4"
                  color="#00ffcc"
                  shadow="cast: true; receive: true"></a-octahedron>

    <!-- Cluster 3 -->
    <a-ring position="-1 0.01 -6"
            rotation="-90 0 0"
            radius-inner="0.3"
            radius-outer="0.6"
            color="#ffdddd"
            shadow="cast: true; receive: true"></a-ring>

    <a-cone position="1 0.9 -6.5"
            radius-bottom="0.5"
            radius-top="0.0"
            height="1.2"
            color="#ffddff"
            shadow="cast: true; receive: true"></a-cone>

    <a-torus position="0 0.8 -5.2"
             rotation="0 45 0"
             radius="0.7"
             radius-tubular="0.12"
             color="#88aaff"
             shadow="cast: true; receive: true"></a-torus>

    <!-- Little path of spheres into the distance -->
    <a-sphere position="-1 0.2 -2.5" radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
    <a-sphere position="-0.5 0.2 -3.5" radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
    <a-sphere position="0 0.2 -4.5"   radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
    <a-sphere position="0.5 0.2 -5.5" radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
    <a-sphere position="1 0.2 -6.5"   radius="0.12" color="#ffffff" shadow="cast: true; receive: true"></a-sphere>
  </a-scene>

  <!-- JS (MediaPipe Tasks Vision) -->
  <script type="module">
    import {
      FaceLandmarker,
      FilesetResolver
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js";

    const video          = document.getElementById("video");
    const parallaxRange  = document.getElementById("parallaxRange");
    const parallaxValue  = document.getElementById("parallaxValue");
    const rigEl          = document.getElementById("rig");

    let faceLandmarker   = null;
    let running          = false;
    let lastVideoTime    = -1;
    let parallaxFactor   = 1.0;

    // Camera base position (the rig has this as its neutral)
    const baseCam = { x: 0, y: 1.0, z: 0 };

    // For Z from head distance
    let baselineScale = null; // size of face at "neutral" distance

    parallaxRange.addEventListener("input", (e) => {
      parallaxFactor = parseFloat(e.target.value);
      parallaxValue.textContent = parallaxFactor.toFixed(2);
    });

    async function initCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 640, height: 480 }
      });
      video.srcObject = stream;
      return new Promise(resolve => {
        video.onloadedmetadata = () => resolve();
      });
    }

    async function initFaceLandmarker() {
      const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );

      faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task"
        },
        runningMode: "VIDEO",
        numFaces: 1
      });
    }

    // Get center (x,y) and an approximate "scale" (how big the face is), using eye distance
    function getHeadMetrics(landmarks) {
      if (!landmarks || !landmarks.length) return null;

      // Center: average all landmarks (normalized [0..1])
      let sumX = 0;
      let sumY = 0;
      const n = landmarks.length;
      for (let i = 0; i < n; i++) {
        sumX += landmarks[i].x;
        sumY += landmarks[i].y;
      }
      const center = { x: sumX / n, y: sumY / n };

      // Scale: distance between approximate outer eye corners (33 and 263 in FaceMesh / FaceLandmarker)
      let scale = 0.1;
      const leftIdx  = 33;
      const rightIdx = 263;
      if (landmarks[leftIdx] && landmarks[rightIdx]) {
        const lx = landmarks[leftIdx].x;
        const ly = landmarks[leftIdx].y;
        const rx = landmarks[rightIdx].x;
        const ry = landmarks[rightIdx].y;
        scale = Math.hypot(rx - lx, ry - ly);
      }

      return { center, scale };
    }

    // head left  -> camera right
    // head right -> camera left
    // head up    -> camera up      (Y FIXED HERE)
    // head down  -> camera down
    function mapHeadToCamera(center, scale) {
      const nx = center.x * 2 - 1;   // -1 = left, +1 = right
      const ny = center.y * 2 - 1;   // -1 = top,  +1 = bottom

      // Base XY movement range in scene units
      const baseMaxX = 0.5;
      const baseMaxY = 0.3;

      const maxX = baseMaxX * parallaxFactor;
      const maxY = baseMaxY * parallaxFactor;

      // X: invert so head left -> cam right
      const dx = -nx * maxX;
      // Y: invert ny so head up (ny=-1) -> cam up (positive Y)
      const dy = -ny * maxY;

      // Z from face scale (distance to camera)
      // Initialize baseline on first valid frame
      if (scale && !baselineScale) baselineScale = scale;
      let dz = 0;
      if (scale && baselineScale) {
        let rel = scale / baselineScale;         // 1.0 at baseline, >1 closer, <1 farther
        rel = Math.min(Math.max(rel, 0.7), 1.3); // clamp
        const delta = rel - 1.0;
        const maxDepthOffset = 0.8;              // how much we move in/out
        dz = -delta * maxDepthOffset * parallaxFactor;
        // rel>1 (closer)  -> delta>0 -> dz negative -> camera moves closer to scene
        // rel<1 (farther) -> delta<0 -> dz positive -> camera moves away
      }

      return {
        x: baseCam.x + dx,
        y: baseCam.y + dy,
        z: baseCam.z + dz
      };
    }

    function smooth(prev, next, factor) {
      if (!prev) return next;
      return {
        x: prev.x + (next.x - prev.x) * factor,
        y: prev.y + (next.y - prev.y) * factor,
        z: prev.z + (next.z - prev.z) * factor
      };
    }

    let smoothedCamPos = null;

    async function processVideoFrame() {
      if (!running) return;

      const nowMs = performance.now();
      const videoTime = video.currentTime;

      if (videoTime === lastVideoTime) {
        requestAnimationFrame(processVideoFrame);
        return;
      }
      lastVideoTime = videoTime;

      const results = faceLandmarker.detectForVideo(video, nowMs);

      if (results.faceLandmarks && results.faceLandmarks.length > 0) {
        const landmarks = results.faceLandmarks[0];
        const metrics = getHeadMetrics(landmarks);

        if (metrics) {
          const camPos = mapHeadToCamera(metrics.center, metrics.scale);
          smoothedCamPos = smooth(smoothedCamPos, camPos, 0.18);

          rigEl.setAttribute(
            "position",
            `${smoothedCamPos.x} ${smoothedCamPos.y} ${smoothedCamPos.z}`
          );
        }
      }

      requestAnimationFrame(processVideoFrame);
    }

    (async function start() {
      try {
        await initCamera();
        await initFaceLandmarker();
        running = true;
        processVideoFrame();
      } catch (e) {
        console.error("Error initializing:", e);
      }
    })();
  </script>
</body>
</html>

