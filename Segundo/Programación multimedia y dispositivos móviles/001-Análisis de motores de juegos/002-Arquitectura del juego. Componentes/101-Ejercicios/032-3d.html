<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Asteroids 3D · Third-person</title>
  <style>
    html,body{margin:0;padding:0;overflow:hidden;background:#000}
    canvas{display:block}
    #hud2d{
      position:fixed;inset:0;pointer-events:none;
    }
    #ui{
      position:fixed;left:12px;top:12px;z-index:10;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;font-size:13px;
      background:rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:10px;
      padding:10px 12px;
      backdrop-filter: blur(6px);
      user-select:none;
    }
    #ui .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    #ui label{display:flex;gap:8px;align-items:center;cursor:pointer}
    #ui input{accent-color:#52c7ff}
    #ui .hint{opacity:.8;font-size:12px;margin-top:8px;line-height:1.25}
    #centerHint{
      position:fixed;left:50%;top:50%;
      transform:translate(-50%,-50%);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;opacity:.9;
      padding:10px 14px;border-radius:10px;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="row">
      <label><input id="invX" type="checkbox">Invert mouse X</label>
      <label><input id="invY" type="checkbox">Invert mouse Y</label>
      <label><input id="mouseEnable" type="checkbox" checked>Mouse control</label>
    </div>
    <div class="hint">
      Click to lock mouse. <b>W</b> thrust, <b>S</b> brake, <b>A/D</b> strafe, <b>Q/E</b> roll,
      <b>Space</b> or <b>LMB</b> shoot. <b>Esc</b> unlock.
    </div>
  </div>
  <div id="centerHint">Click to start (pointer lock)</div>

  <!-- 3D canvas is created by Three.js -->
  <canvas id="hud2d"></canvas>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    // -----------------------------
    // Helpers
    // -----------------------------
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const randInt = (a,b)=>Math.floor(rand(a,b+1));
    const tmpV = new THREE.Vector3();
    const tmpV2 = new THREE.Vector3();
    const tmpQ = new THREE.Quaternion();

    // -----------------------------
    // DOM / HUD2D
    // -----------------------------
    const hud = document.getElementById("hud2d");
    const hudCtx = hud.getContext("2d");
    const uiInvX = document.getElementById("invX");
    const uiInvY = document.getElementById("invY");
    const uiMouseEnable = document.getElementById("mouseEnable");
    const centerHint = document.getElementById("centerHint");

    function resizeHUD(){
      hud.width = window.innerWidth * devicePixelRatio;
      hud.height = window.innerHeight * devicePixelRatio;
      hud.style.width = window.innerWidth + "px";
      hud.style.height = window.innerHeight + "px";
      hudCtx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }

    // -----------------------------
    // Three.js setup
    // -----------------------------
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    document.body.insertBefore(renderer.domElement, hud);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 200, 12200);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 800000);
    camera.position.set(0, 6, 18);

    const ambient = new THREE.AmbientLight(0xffffff, 0.00);
    scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xffffff, 2);
    keyLight.position.set(40, 60, 30);
    scene.add(keyLight);

    // -----------------------------
    // Starfield (bigger + "unreachable": follow ship)
    // - White boxes around a 360 sphere, centered on the ship each frame
    // -----------------------------
    const starfield = new THREE.Group();
    scene.add(starfield);

    {
      const STAR_COUNT = 3200;
      const R = 5200; // far
      const geom = new THREE.BoxGeometry(1,1,1);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      // Instanced for speed
      const inst = new THREE.InstancedMesh(geom, mat, STAR_COUNT);
      inst.frustumCulled = false;

      const m = new THREE.Matrix4();
      const s = new THREE.Vector3();
      const p = new THREE.Vector3();
      const q = new THREE.Quaternion();

      for(let i=0;i<STAR_COUNT;i++){
        // random direction on sphere
        const u = Math.random();
        const v = Math.random();
        const theta = 2*Math.PI*u;
        const phi = Math.acos(2*v - 1);
        const x = Math.sin(phi)*Math.cos(theta);
        const y = Math.cos(phi);
        const z = Math.sin(phi)*Math.sin(theta);

        p.set(x,y,z).multiplyScalar(R + rand(-250, 250));

        // bigger stars
        const size = (Math.random()<0.12) ? rand(6, 12) : rand(2.2, 6.2);
        s.set(size, size, size);

        q.setFromEuler(new THREE.Euler(rand(0,Math.PI), rand(0,Math.PI), rand(0,Math.PI)));

        m.compose(p, q, s);
        inst.setMatrixAt(i, m);
      }
      inst.instanceMatrix.needsUpdate = true;
      starfield.add(inst);
    }

    // -----------------------------
    // Player ship (more amazing)
    // -----------------------------
    const ship = new THREE.Group();
    scene.add(ship);

    function makeShip(){
      // Materials
      const hullMat = new THREE.MeshStandardMaterial({
        color: 0xf6f6f6,
        roughness: 0.35,
        metalness: 0.15,
        emissive: 0x000000,
      });
      const darkMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.7,
        metalness: 0.1,
      });
      const glowMat = new THREE.MeshStandardMaterial({
        color: 0x66ccff,
        emissive: 0x44b7ff,
        emissiveIntensity: 1.2,
        roughness: 0.2,
        metalness: 0.0,
      });
      const redCore = new THREE.MeshStandardMaterial({
        color: 0xff6a6a,
        emissive: 0xff3f3f,
        emissiveIntensity: 1.4,
        roughness: 0.25,
        metalness: 0.0,
      });

      // Nose (cone)
      const nose = new THREE.Mesh(new THREE.ConeGeometry(1.05, 3.6, 20), hullMat);
      nose.rotation.x = Math.PI/2;
      nose.position.z = 3.2;

      // Main fuselage (capsule-like using cylinder + spheres)
      const body = new THREE.Mesh(new THREE.CylinderGeometry(1.0, 1.15, 5.8, 20), hullMat);
      body.rotation.x = Math.PI/2;
      body.position.z = 0.1;

      const bodyFront = new THREE.Mesh(new THREE.SphereGeometry(1.05, 20, 16), hullMat);
      bodyFront.position.z = 2.9;

      const bodyRear = new THREE.Mesh(new THREE.SphereGeometry(1.1, 20, 16), hullMat);
      bodyRear.position.z = -2.7;

      // Wings (swept)
      const wingGeom = new THREE.BoxGeometry(4.8, 0.22, 2.3);
      const wingL = new THREE.Mesh(wingGeom, hullMat);
      wingL.position.set(-2.0, 0.0, 0.2);
      wingL.rotation.y = -0.22;

      const wingR = wingL.clone();
      wingR.position.x = 2.0;
      wingR.rotation.y = 0.22;

      // Wing tips (small fins)
      const finGeom = new THREE.BoxGeometry(1.2, 0.5, 1.2);
      const finL = new THREE.Mesh(finGeom, darkMat);
      finL.position.set(-4.35, 0.35, -0.1);
      finL.rotation.z = 0.25;

      const finR = finL.clone();
      finR.position.x = 4.35;
      finR.rotation.z = -0.25;

      // Canopy
      const canopy = new THREE.Mesh(new THREE.SphereGeometry(0.85, 24, 18), glowMat);
      canopy.scale.set(1.35, 0.75, 1.1);
      canopy.position.set(0, 0.55, 1.05);

      // Engine pods
      const podGeom = new THREE.CylinderGeometry(0.32, 0.42, 2.3, 16);
      const podL = new THREE.Mesh(podGeom, darkMat);
      podL.rotation.x = Math.PI/2;
      podL.position.set(-1.55, -0.35, -2.0);

      const podR = podL.clone();
      podR.position.x = 1.55;

      // Engine glow discs
      const glowGeom = new THREE.CircleGeometry(0.36, 24);
      const glowL = new THREE.Mesh(glowGeom, redCore);
      glowL.position.set(-1.55, -0.35, -3.15);
      glowL.rotation.y = Math.PI; // face backward

      const glowR = glowL.clone();
      glowR.position.x = 1.55;

      // Center core glow
      const core = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 12), redCore);
      core.position.set(0, 0.0, -2.45);

      // Add
      ship.add(nose, body, bodyFront, bodyRear, wingL, wingR, finL, finR, canopy, podL, podR, glowL, glowR, core);

      // Slight tilt so it feels aircraft-like
      ship.rotation.order = "YXZ"; // yaw, pitch, roll
    }
    makeShip();

    // -----------------------------
    // Rocks (3D)
    // -----------------------------
    const rocks = [];
    function makeRock(radius){
      // Icosahedron with noise-ish deformation
      const detail = radius > 18 ? 2 : 1;
      const g = new THREE.IcosahedronGeometry(radius, detail);
      const pos = g.attributes.position;
      for(let i=0;i<pos.count;i++){
        tmpV.fromBufferAttribute(pos, i);
        const n = (Math.random()*2 - 1) * 0.22; // roughness
        tmpV.multiplyScalar(1 + n);
        pos.setXYZ(i, tmpV.x, tmpV.y, tmpV.z);
      }
      pos.needsUpdate = true;
      g.computeVertexNormals();

      const m = new THREE.MeshStandardMaterial({
        color: 0xa0a0a0,
        roughness: 0.85,
        metalness: 0.05,
      });
      const mesh = new THREE.Mesh(g, m);
      mesh.castShadow = false;
      mesh.receiveShadow = false;

      // subtle highlight rim
      const rim = new THREE.Mesh(
        g.clone(),
        new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.08 })
      );
      rim.scale.setScalar(1.01);
      mesh.add(rim);

      return mesh;
    }

    function spawnRocks(n, avoidPos){
      for(let i=0;i<n;i++){
        const r = rand(12, 34);
        const mesh = makeRock(r);
        scene.add(mesh);

        // place around ship but not too close
        let p;
        for(;;){
          p = new THREE.Vector3(rand(-220,220), rand(-140,140), rand(-220,220));
          p.add(ship.position);
          if(avoidPos && p.distanceTo(avoidPos) < 90) continue;
          if(p.distanceTo(ship.position) < 120) continue;
          break;
        }

        mesh.position.copy(p);
        mesh.rotation.set(rand(0,Math.PI), rand(0,Math.PI), rand(0,Math.PI));

        rocks.push({
          mesh,
          radius: r,
          vel: new THREE.Vector3(rand(-1.4,1.4), rand(-1.2,1.2), rand(-1.4,1.4)),
          rot: new THREE.Vector3(rand(-0.012,0.012), rand(-0.012,0.012), rand(-0.012,0.012)),
        });
      }
    }

    // -----------------------------
    // Particles (GPU-friendly: Points)
    // -----------------------------
    const particles = []; // each system: {points, geo, mat, data[]}
    function spawnParticleBurst(pos, dir, count, speedMin, speedMax, size, lifeMin, lifeMax, color){
      const positions = new Float32Array(count*3);
      const velocities = new Float32Array(count*3);
      const lifetimes = new Float32Array(count);
      const maxLifetimes = new Float32Array(count);

      for(let i=0;i<count;i++){
        // start
        positions[i*3+0] = pos.x + rand(-0.6,0.6);
        positions[i*3+1] = pos.y + rand(-0.6,0.6);
        positions[i*3+2] = pos.z + rand(-0.6,0.6);

        // velocity: around dir, with random spread
        const a = new THREE.Vector3(rand(-1,1), rand(-1,1), rand(-1,1)).normalize();
        const spread = 0.55;
        tmpV.copy(dir).normalize().multiplyScalar(1 - spread).add(a.multiplyScalar(spread)).normalize();

        const s = rand(speedMin, speedMax);
        velocities[i*3+0] = tmpV.x * s;
        velocities[i*3+1] = tmpV.y * s;
        velocities[i*3+2] = tmpV.z * s;

        const life = rand(lifeMin, lifeMax);
        lifetimes[i] = life;
        maxLifetimes[i] = life;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geo.setAttribute("aLife", new THREE.BufferAttribute(lifetimes, 1));
      geo.setAttribute("aMaxLife", new THREE.BufferAttribute(maxLifetimes, 1));

      // simple shader-like fade using onBeforeCompile would be nicer,
      // but keep it simple: we update material opacity from average life.
      const mat = new THREE.PointsMaterial({
        color,
        size,
        transparent:true,
        opacity: 1,
        depthWrite:false,
      });

      const points = new THREE.Points(geo, mat);
      scene.add(points);

      particles.push({ points, geo, mat, positions, velocities, lifetimes, maxLifetimes });
    }

    function updateParticles(dt){
      for(let s=particles.length-1;s>=0;s--){
        const sys = particles[s];
        const posAttr = sys.geo.getAttribute("position");
        let aliveCount = 0;
        let lifeSum = 0;
        for(let i=0;i<sys.lifetimes.length;i++){
          if(sys.lifetimes[i] <= 0) continue;
          sys.lifetimes[i] -= dt;

          const idx = i*3;
          // drag
          sys.velocities[idx+0] *= 0.992;
          sys.velocities[idx+1] *= 0.992;
          sys.velocities[idx+2] *= 0.992;

          sys.positions[idx+0] += sys.velocities[idx+0] * dt;
          sys.positions[idx+1] += sys.velocities[idx+1] * dt;
          sys.positions[idx+2] += sys.velocities[idx+2] * dt;

          posAttr.setXYZ(i, sys.positions[idx+0], sys.positions[idx+1], sys.positions[idx+2]);

          aliveCount++;
          lifeSum += (sys.lifetimes[i] / sys.maxLifetimes[i]);
        }
        posAttr.needsUpdate = true;

        // fade whole system by average remaining life
        sys.mat.opacity = aliveCount ? clamp(lifeSum / aliveCount, 0, 1) : 0;

        if(aliveCount === 0){
          scene.remove(sys.points);
          sys.geo.dispose();
          sys.mat.dispose();
          particles.splice(s,1);
        }
      }
    }

    // -----------------------------
    // Bullets
    // -----------------------------
    const bullets = [];
    const bulletGeom = new THREE.SphereGeometry(0.25, 10, 10);
    const bulletMat = new THREE.MeshBasicMaterial({ color: 0x3aa7ff });

    function shoot(){
      const muzzleLocal = new THREE.Vector3(0, 0, 4.6);
      const muzzleWorld = muzzleLocal.clone().applyQuaternion(ship.quaternion).add(ship.position);

      const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(ship.quaternion).normalize();

      const mesh = new THREE.Mesh(bulletGeom, bulletMat);
      mesh.position.copy(muzzleWorld);
      scene.add(mesh);

      bullets.push({
        mesh,
        vel: dir.multiplyScalar(58).add(shipUserVel.clone().multiplyScalar(0.35)),
        life: 1.35, // seconds
      });

      // shoot particles
      spawnParticleBurst(muzzleWorld, dir, 18, 10, 26, 0.12, 0.25, 0.55, 0x66ccff);
    }

    // -----------------------------
    // Controls
    // -----------------------------
    const keys = new Set();
    window.addEventListener("keydown", (e)=>{
      keys.add(e.code);
      if(e.code === "Space") shoot();
    });
    window.addEventListener("keyup", (e)=> keys.delete(e.code));

    // LMB to shoot
    window.addEventListener("mousedown", (e)=>{
      if(e.button === 0){
        // if not locked yet, request lock; also allow shoot
        if(document.pointerLockElement !== renderer.domElement){
          renderer.domElement.requestPointerLock();
        }else{
          shoot();
        }
      }
    });

    // Pointer lock
    document.addEventListener("pointerlockchange", ()=>{
      const locked = document.pointerLockElement === renderer.domElement;
      centerHint.style.display = locked ? "none" : "block";
    });

    // "Previous-style" mouse control: pointer-lock deltas -> yaw/pitch with smoothing
    let yaw = 0, pitch = 0, roll = 0;
    let yawVel = 0, pitchVel = 0;
    const mouse = { dx:0, dy:0 };

    window.addEventListener("mousemove", (e)=>{
      if(!uiMouseEnable.checked) return;
      if(document.pointerLockElement !== renderer.domElement) return;

      const invX = uiInvX.checked ? -1 : 1;
      const invY = uiInvY.checked ? -1 : 1;

      // accumulate deltas (smooth later)
      mouse.dx += e.movementX * invX;
      mouse.dy += e.movementY * invY;
    });

    // Ship physics state
    const shipUserVel = new THREE.Vector3();
    const shipMaxSpeed = 85;
    const shipAccel = 65;       // m/s^2 feel
    const shipStrafe = 45;
    const shipBrake = 55;
    const shipDrag = 0.985;

    // camera follow
    const camOffset = new THREE.Vector3(0, 6.5, -18); // in ship-local space
    const camLookAt = new THREE.Vector3(0, 2.2, 10);  // in ship-local space

    // -----------------------------
    // Levels
    // -----------------------------
    let level = 1;
    let rocksPerLevel = 10;
    function startLevel(){
      // clear existing
      for(const r of rocks) scene.remove(r.mesh);
      rocks.length = 0;

      spawnRocks(rocksPerLevel, ship.position);
      levelTimer = 2.0;
    }
    let levelTimer = 2.0;
    startLevel();

    // -----------------------------
    // Target selection (for crosshairs)
    // -----------------------------
    function pickTarget(){
      // choose best rock in front & near center
      const forward = new THREE.Vector3(0,0,1).applyQuaternion(ship.quaternion).normalize();
      let best = null;
      let bestScore = Infinity;

      for(const r of rocks){
        tmpV.copy(r.mesh.position).sub(ship.position);
        const d = tmpV.length();
        if(d > 1800) continue;

        const nd = tmpV.multiplyScalar(1/d);
        const dot = clamp(nd.dot(forward), -1, 1);
        if(dot < 0.4) continue; // in front-ish
        const ang = Math.acos(dot);
        const score = ang*420 + d*0.35;
        if(score < bestScore){
          bestScore = score;
          best = r;
        }
      }
      return best;
    }

    // -----------------------------
    // Rock fragmentation + explosion particles
    // -----------------------------
    function explodeRock(rock){
      const p = rock.mesh.position.clone();
      const dir = ship.position.clone().sub(p).normalize().multiplyScalar(-1);

      spawnParticleBurst(p, dir, 90, 8, 38, 0.14, 0.55, 1.35, 0xffffff);
      spawnParticleBurst(p, dir, 42, 5, 22, 0.18, 0.45, 1.1, 0xcfcfcf);

      const r = rock.radius;
      if(r >= 30){
        const pieces = randInt(2,3);
        for(let i=0;i<pieces;i++){
          const nr = r * rand(0.45, 0.6);
          const mesh = makeRock(nr);
          mesh.position.copy(p).add(new THREE.Vector3(rand(-3,3),rand(-3,3),rand(-3,3)));
          scene.add(mesh);
          rocks.push({
            mesh,
            radius: nr,
            vel: rock.vel.clone().add(new THREE.Vector3(rand(-8,8),rand(-8,8),rand(-8,8))),
            rot: new THREE.Vector3(rand(-0.02,0.02), rand(-0.02,0.02), rand(-0.02,0.02)),
          });
        }
      }else if(r >= 18){
        const pieces = randInt(2,3);
        for(let i=0;i<pieces;i++){
          const nr = r * rand(0.55, 0.75);
          const mesh = makeRock(nr);
          mesh.position.copy(p).add(new THREE.Vector3(rand(-2.5,2.5),rand(-2.5,2.5),rand(-2.5,2.5)));
          scene.add(mesh);
          rocks.push({
            mesh,
            radius: nr,
            vel: rock.vel.clone().add(new THREE.Vector3(rand(-10,10),rand(-10,10),rand(-10,10))),
            rot: new THREE.Vector3(rand(-0.03,0.03), rand(-0.03,0.03), rand(-0.03,0.03)),
          });
        }
      }
      // else: just particles (no pieces)
    }

    // -----------------------------
    // 2D crosshair drawing (project to screen)
    // - Draw for rocks that are far (and/or target) so they remain trackable
    // -----------------------------
    function clearHud(){
      hudCtx.clearRect(0,0,window.innerWidth,window.innerHeight);
    }

    function drawCrosshair2D(x,y,rad,alpha,isTarget=false){
      hudCtx.save();
      hudCtx.globalAlpha = alpha;

      // ring
      hudCtx.lineWidth = isTarget ? 2.5 : 2.0;
      hudCtx.strokeStyle = "rgba(82,199,255,0.95)";
      hudCtx.beginPath();
      hudCtx.arc(x,y,rad,0,Math.PI*2);
      hudCtx.stroke();

      // ticks
      hudCtx.lineWidth = isTarget ? 3.0 : 2.2;
      hudCtx.strokeStyle = "rgba(82,199,255,0.75)";
      const t = Math.max(8, rad*0.25);
      hudCtx.beginPath(); hudCtx.moveTo(x, y-rad); hudCtx.lineTo(x, y-rad+t); hudCtx.stroke();
      hudCtx.beginPath(); hudCtx.moveTo(x, y+rad); hudCtx.lineTo(x, y+rad-t); hudCtx.stroke();
      hudCtx.beginPath(); hudCtx.moveTo(x-rad, y); hudCtx.lineTo(x-rad+t, y); hudCtx.stroke();
      hudCtx.beginPath(); hudCtx.moveTo(x+rad, y); hudCtx.lineTo(x+rad-t, y); hudCtx.stroke();

      hudCtx.restore();
    }

    function drawCrosshairsForRocks(target){
      const w = window.innerWidth;
      const h = window.innerHeight;

      // Only draw when rock is in front of camera
      const camForward = new THREE.Vector3();
      camera.getWorldDirection(camForward);

      for(const r of rocks){
        const rockPos = r.mesh.position;

        // behind camera check
        tmpV.copy(rockPos).sub(camera.position);
        const d = tmpV.length();
        const nd = tmpV.multiplyScalar(1/d);
        const dot = nd.dot(camForward);
        if(dot < 0.15) continue;

        // project
        tmpV2.copy(rockPos).project(camera);
        const sx = (tmpV2.x * 0.5 + 0.5) * w;
        const sy = (-tmpV2.y * 0.5 + 0.5) * h;

        // offscreen? still draw clamped to edge for tracking
        const margin = 18;
        const onScreen = (sx>=0 && sx<=w && sy>=0 && sy<=h);

        let x = sx, y = sy;
        if(!onScreen){
          x = clamp(sx, margin, w-margin);
          y = clamp(sy, margin, h-margin);
        }

        // “far tracking”: emphasize distant rocks more
        const far = d;
        const alpha = clamp((far - 120) / 1200, 0.25, 0.9);

        // size based on distance + rock radius
        const rad = clamp((r.radius * 10) / (far*0.03 + 10), 10, 34);

        // Draw more visible for the selected target
        const isTarget = (target && r === target);
        const finalAlpha = isTarget ? Math.max(alpha, 0.75) : alpha;

        // only show for far-ish OR offscreen OR target
        if(far > 240 || !onScreen || isTarget){
          drawCrosshair2D(x, y, isTarget ? rad*1.25 : rad, finalAlpha, isTarget);
        }
      }
    }

    // -----------------------------
    // Resize
    // -----------------------------
    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      resizeHUD();
    }
    window.addEventListener("resize", onResize);
    onResize();

    // -----------------------------
    // Main loop
    // -----------------------------
    let last = performance.now();

    function animate(now){
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      // Keep starfield "unreachable": it follows the ship, always far away
      starfield.position.copy(ship.position);

      // Mouse smoothing (bring back the "feel": accumulate, then damp)
      // Convert pixels to angular velocity
      const sens = 0.0022; // tweak for "previous-like" feel
      yawVel   += (-mouse.dx) * sens;
      pitchVel += (-mouse.dy) * sens;
      mouse.dx *= 0.35;
      mouse.dy *= 0.35;

      // damp & clamp
      yawVel *= 0.78;
      pitchVel *= 0.78;

      // apply
      yaw   += yawVel;
      pitch += pitchVel;
      pitch = clamp(pitch, -1.35, 1.35);

      // roll from keys (Q/E)
      const rollSpeed = 1.55; // rad/s
      if(keys.has("KeyQ")) roll += rollSpeed*dt;
      if(keys.has("KeyE")) roll -= rollSpeed*dt;
      roll *= 0.992;

      // Compose orientation (yaw/pitch/roll)
      ship.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, roll, "YXZ"));

      // Movement: thrust forward/back, strafe, brake
      const forward = new THREE.Vector3(0,0,1).applyQuaternion(ship.quaternion).normalize();
      const right   = new THREE.Vector3(1,0,0).applyQuaternion(ship.quaternion).normalize();

      let accel = new THREE.Vector3();
      let thrusting = false;

      if(keys.has("KeyW")){
        accel.add(forward.clone().multiplyScalar(shipAccel));
        thrusting = true;
      }
      if(keys.has("KeyS")){
        accel.add(forward.clone().multiplyScalar(-shipBrake));
      }
      if(keys.has("KeyA")) accel.add(right.clone().multiplyScalar(-shipStrafe));
      if(keys.has("KeyD")) accel.add(right.clone().multiplyScalar(shipStrafe));

      // integrate
      shipUserVel.add(accel.multiplyScalar(dt));
      shipUserVel.multiplyScalar(Math.pow(shipDrag, dt*60));

      // speed clamp
      const sp = shipUserVel.length();
      if(sp > shipMaxSpeed) shipUserVel.multiplyScalar(shipMaxSpeed/sp);

      ship.position.add(shipUserVel.clone().multiplyScalar(dt));

      // Thrust particles (behind ship)
      if(thrusting){
        const back = forward.clone().multiplyScalar(-1);
        const spawnPos = ship.position.clone().add(back.clone().multiplyScalar(3.4)).add(new THREE.Vector3(0, -0.1, 0));
        spawnParticleBurst(spawnPos, back, 14, 6, 18, 0.10, 0.18, 0.45, 0xffffff);
        spawnParticleBurst(spawnPos, back, 8, 4, 12, 0.12, 0.18, 0.35, 0xff7a7a);
      }

      // Camera follow (third-person)
      const desiredCamPos = camOffset.clone().applyQuaternion(ship.quaternion).add(ship.position);
      camera.position.lerp(desiredCamPos, 1 - Math.pow(0.0006, dt*60)); // smooth
      const lookAtPos = camLookAt.clone().applyQuaternion(ship.quaternion).add(ship.position);
      camera.lookAt(lookAtPos);

      // Bullets update
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.life -= dt;
        b.mesh.position.add(b.vel.clone().multiplyScalar(dt));
        if(b.life <= 0){
          scene.remove(b.mesh);
          bullets.splice(i,1);
        }
      }

      // Rocks update
      for(const r of rocks){
        r.mesh.position.add(r.vel.clone().multiplyScalar(dt));
        r.mesh.rotation.x += r.rot.x;
        r.mesh.rotation.y += r.rot.y;
        r.mesh.rotation.z += r.rot.z;
      }

      // Bullet-rock collisions
      for(let i=rocks.length-1;i>=0;i--){
        const r = rocks[i];
        const rp = r.mesh.position;
        for(let j=bullets.length-1;j>=0;j--){
          const b = bullets[j];
          const bp = b.mesh.position;
          if(bp.distanceTo(rp) < r.radius){
            // remove bullet
            scene.remove(b.mesh);
            bullets.splice(j,1);

            // remove rock, explode & maybe fragment
            scene.remove(r.mesh);
            rocks.splice(i,1);

            explodeRock(r);
            break;
          }
        }
      }

      // Particles
      updateParticles(dt);

      // Level progression
      if(rocks.length === 0){
        level++;
        rocksPerLevel *= 2;
        startLevel();
      }
      levelTimer = Math.max(0, levelTimer - dt);

      // Render 3D
      renderer.render(scene, camera);

      // HUD 2D
      clearHud();
      const target = pickTarget();
      drawCrosshairsForRocks(target);

      // Level text
      if(levelTimer > 0){
        hudCtx.save();
        hudCtx.globalAlpha = clamp(levelTimer/2.0, 0, 1);
        hudCtx.fillStyle = "white";
        hudCtx.strokeStyle = "rgba(0,0,0,0.65)";
        hudCtx.lineWidth = 6;
        hudCtx.font = "700 48px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        hudCtx.textAlign = "center";
        hudCtx.textBaseline = "middle";
        const msg = `LEVEL ${level}`;
        hudCtx.strokeText(msg, window.innerWidth/2, window.innerHeight*0.18);
        hudCtx.fillText(msg, window.innerWidth/2, window.innerHeight*0.18);
        hudCtx.restore();
      }

      // corner HUD
      hudCtx.save();
      hudCtx.fillStyle = "white";
      hudCtx.font = "14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      hudCtx.fillText(`Level: ${level}`, 12, 20);
      hudCtx.fillText(`Rocks: ${rocks.length}`, 12, 38);
      hudCtx.restore();

      requestAnimationFrame(animate);
    }

    // Start
    // initial placement
    ship.position.set(0,0,0);
    shipUserVel.set(0,0,0);

    requestAnimationFrame(animate);

    // Also allow click on hint to lock
    centerHint.addEventListener("mousedown", ()=>{
      renderer.domElement.requestPointerLock();
    });

    // Make sure clicks focus the canvas for pointer lock UX
    renderer.domElement.style.outline = "none";
    renderer.domElement.tabIndex = 0;
  </script>
</body>
</html>

