<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Asteroids 3D (third-person) — Three.js</title>
  <style>
    html,body{margin:0;padding:0;overflow:hidden;background:#000}
    canvas{display:block}
    #ui{
      position:fixed;left:12px;top:12px;z-index:10;
      font:14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff; user-select:none;
    }
    #panel{
      background:rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:10px;
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:260px;
      backdrop-filter: blur(6px);
    }
    #panel .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
    #panel label{display:flex;align-items:center;gap:8px}
    #panel input[type="checkbox"]{transform:scale(1.1)}
    #hint{
      opacity:0.9;
      font-size:12px;
      line-height:1.25;
    }
    #lockBtn{
      cursor:pointer;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.08);
      color:#fff;
    }
    #lockBtn:hover{background:rgba(255,255,255,0.13)}
    #hud{
      margin-top:6px;
      font:13px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      opacity:0.95;
    }
    #centerTip{
      position:fixed;left:0;right:0;bottom:16px;
      text-align:center;color:rgba(255,255,255,0.85);
      font:12px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      z-index:10;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="panel">
      <div class="row">
        <button id="lockBtn">Enable mouse (Pointer Lock)</button>
        <span id="lockState" style="opacity:.85">OFF</span>
      </div>

      <div class="row">
        <label><input id="invX" type="checkbox">Invert mouse X</label>
        <label><input id="invY" type="checkbox">Invert mouse Y</label>
      </div>

      <div id="hint">
        Controls:
        <br>W/S = thrust forward/back
        <br>A/D = strafe left/right
        <br>Q/E = roll
        <br>Mouse = yaw + pitch (toggle invert above)
        <br>Space or Left Mouse = shoot
        <br>Shift = boost
      </div>

      <div id="hud"></div>
    </div>
  </div>
  <div id="centerTip">Click “Enable mouse” then move mouse to fly. Space/Left-click to shoot.</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ============================
    // Helpers
    // ============================
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand  = (a,b)=>Math.random()*(b-a)+a;
    const randInt=(a,b)=>Math.floor(rand(a,b+1));

    // ============================
    // Scene / Renderer
    // ============================
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 200, 1400);

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 5000);

    window.addEventListener("resize", ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Lights (soft, space-y)
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const key = new THREE.DirectionalLight(0xffffff, 0.85);
    key.position.set(3, 4, 2);
    scene.add(key);

    // ============================
    // UI / Pointer lock
    // ============================
    const lockBtn = document.getElementById("lockBtn");
    const lockState = document.getElementById("lockState");
    const invXEl = document.getElementById("invX");
    const invYEl = document.getElementById("invY");
    const hudEl = document.getElementById("hud");

    let pointerLocked = false;
    lockBtn.addEventListener("click", ()=>{
      renderer.domElement.requestPointerLock?.();
    });

    document.addEventListener("pointerlockchange", ()=>{
      pointerLocked = (document.pointerLockElement === renderer.domElement);
      lockState.textContent = pointerLocked ? "ON" : "OFF";
    });

    // ============================
    // Starfield: tiny white boxes all around
    // ============================
    const stars = new THREE.Group();
    scene.add(stars);

    const starGeo = new THREE.BoxGeometry(1,1,1);
    const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const STAR_COUNT = 1200;
    const STAR_RADIUS = 1800;

    for(let i=0;i<STAR_COUNT;i++){
      const m = new THREE.Mesh(starGeo, starMat);

      // distribute in a sphere-ish shell
      const u = Math.random();
      const v = Math.random();
      const theta = 2*Math.PI*u;
      const phi = Math.acos(2*v - 1);

      const r = rand(STAR_RADIUS*0.3, STAR_RADIUS);
      m.position.set(
        r*Math.sin(phi)*Math.cos(theta),
        r*Math.cos(phi),
        r*Math.sin(phi)*Math.sin(theta)
      );

      const s = Math.random() < 0.15 ? rand(1.4, 2.2) : rand(0.8, 1.3);
      m.scale.setScalar(s);
      stars.add(m);
    }

    // ============================
    // Ship: simple “jet” (group)
    // ============================
    const ship = new THREE.Group();
    scene.add(ship);

    // Body
    const body = new THREE.Mesh(
      new THREE.ConeGeometry(0.9, 3.2, 12),
      new THREE.MeshStandardMaterial({ color: 0xf2f2f2, roughness: 0.35, metalness: 0.2 })
    );
    body.rotation.x = Math.PI/2; // point forward along -Z? We'll define forward as -Z
    ship.add(body);

    // Wings
    const wingMat = new THREE.MeshStandardMaterial({ color: 0xdcdcdc, roughness: 0.45, metalness: 0.15 });
    const wingGeo = new THREE.BoxGeometry(2.2, 0.08, 0.8);
    const wingL = new THREE.Mesh(wingGeo, wingMat);
    const wingR = new THREE.Mesh(wingGeo, wingMat);
    wingL.position.set(-0.9, 0, 0.4);
    wingR.position.set( 0.9, 0, 0.4);
    ship.add(wingL, wingR);

    // Canopy
    const canopy = new THREE.Mesh(
      new THREE.SphereGeometry(0.35, 14, 14),
      new THREE.MeshStandardMaterial({ color: 0x54c8ff, roughness: 0.15, metalness: 0.0, transparent:true, opacity:0.9 })
    );
    canopy.position.set(0, 0.25, 0.2);
    ship.add(canopy);

    ship.position.set(0,0,0);

    // ============================
    // Camera: third person chase
    // ============================
    const camOffsetLocal = new THREE.Vector3(0, 4.5, 12); // behind + above
    const camTargetLocal = new THREE.Vector3(0, 1.1, 0);

    // smooth camera
    const camPos = new THREE.Vector3();
    const camTarget = new THREE.Vector3();

    // ============================
    // Input
    // ============================
    const keys = new Set();
    window.addEventListener("keydown", (e)=>{
      keys.add(e.code);
      if(e.code === "Space") shoot();
    });
    window.addEventListener("keyup", (e)=>keys.delete(e.code));

    // Left mouse shoots too
    window.addEventListener("mousedown", (e)=>{
      if(e.button === 0) shoot();
    });

    // Mouse movement => yaw/pitch
    let yaw = 0;
    let pitch = 0;
    let roll = 0;

    const PITCH_LIMIT = Math.PI * 0.48;

    document.addEventListener("mousemove", (e)=>{
      if(!pointerLocked) return;

      const invX = invXEl.checked ? -1 : 1;
      const invY = invYEl.checked ? -1 : 1;

      const sens = 0.0022;
      yaw   -= e.movementX * sens * invX;
      pitch -= e.movementY * sens * invY;
      pitch = clamp(pitch, -PITCH_LIMIT, PITCH_LIMIT);
    });

    // ============================
    // Bullets
    // ============================
    const bullets = [];
    const bulletGeo = new THREE.SphereGeometry(0.12, 10, 10);
    const bulletMat = new THREE.MeshBasicMaterial({ color: 0x4ea3ff });

    function shoot(){
      // fire rate limiter
      const now = performance.now();
      if(now < shoot.nextAllowed) return;
      shoot.nextAllowed = now + 120;

      // muzzle position (slightly in front)
      const muzzle = new THREE.Vector3(0, 0.0, -2.1);
      muzzle.applyQuaternion(ship.quaternion);
      muzzle.add(ship.position);

      const b = new THREE.Mesh(bulletGeo, bulletMat);
      b.position.copy(muzzle);
      scene.add(b);

      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).normalize();
      const speed = 65;

      bullets.push({
        mesh: b,
        vel: dir.multiplyScalar(speed).add(ship.userData.vel.clone().multiplyScalar(0.15)),
        life: 1.2 // seconds
      });

      // muzzle particles
      spawnBurstParticles(muzzle, ship.quaternion, 16, 22, 0x66c6ff);
    }
    shoot.nextAllowed = 0;

    // ============================
    // Rocks (asteroids) + fragmentation
    // ============================
    const rocks = [];
    const rockGroup = new THREE.Group();
    scene.add(rockGroup);

    function makeRockMesh(radius){
      // “rocky” icosahedron with noisy vertices
      const geo = new THREE.IcosahedronGeometry(radius, 1);
      const pos = geo.attributes.position;
      for(let i=0;i<pos.count;i++){
        const x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
        const n = rand(0.78, 1.18);
        pos.setXYZ(i, x*n, y*n, z*n);
      }
      geo.computeVertexNormals();

      const mat = new THREE.MeshStandardMaterial({
        color: 0xaaaaaa,
        roughness: 0.95,
        metalness: 0.05
      });

      const m = new THREE.Mesh(geo, mat);
      // subtle outline-ish highlight using emissive a bit
      m.material.emissive = new THREE.Color(0x000000);
      return m;
    }

    function spawnRock(radius, position=null, velocity=null){
      const r = radius;
      const mesh = makeRockMesh(r);
      rockGroup.add(mesh);

      const pos = position ? position.clone() : randomSpawnPositionAwayFromShip(90, 420);
      mesh.position.copy(pos);

      const vel = velocity ? velocity.clone() : randomDriftVelocity(4, 12);
      const angVel = new THREE.Vector3(rand(-1,1), rand(-1,1), rand(-1,1)).multiplyScalar(0.7);

      const rock = { mesh, r, vel, angVel };
      rocks.push(rock);
      return rock;
    }

    function randomSpawnPositionAwayFromShip(minDist, maxDist){
      // spawn in a shell around ship, mostly in front-ish but still 360°
      let p = new THREE.Vector3();
      for(let tries=0;tries<60;tries++){
        // random direction
        const d = new THREE.Vector3(rand(-1,1), rand(-1,1), rand(-1,1)).normalize();
        const dist = rand(minDist, maxDist);
        p.copy(ship.position).add(d.multiplyScalar(dist));
        if(p.distanceTo(ship.position) >= minDist) return p;
      }
      return ship.position.clone().add(new THREE.Vector3(0,0,-maxDist));
    }

    function randomDriftVelocity(min, max){
      const d = new THREE.Vector3(rand(-1,1), rand(-1,1), rand(-1,1)).normalize();
      return d.multiplyScalar(rand(min, max));
    }

    function fragmentRock(rock){
      const r = rock.r;
      const p = rock.mesh.position.clone();

      // destruction particles (fading)
      spawnExplosionParticles(p, 90, 40, 0xdedede);

      // remove old rock
      rockGroup.remove(rock.mesh);
      rock.mesh.geometry.dispose();
      // keep material (shared-ish), but dispose is ok too if you want:
      // rock.mesh.material.dispose();

      rocks.splice(rocks.indexOf(rock), 1);

      // fragmentation rules
      if(r >= 6.0){
        const pieces = randInt(2,3);
        for(let i=0;i<pieces;i++){
          const nr = r * rand(0.45, 0.62);
          const dv = rock.vel.clone().add(new THREE.Vector3(rand(-7,7), rand(-7,7), rand(-7,7)));
          const np = p.clone().add(new THREE.Vector3(rand(-1.5,1.5), rand(-1.5,1.5), rand(-1.5,1.5)));
          spawnRock(nr, np, dv);
        }
        return;
      }

      if(r >= 3.2){
        const pieces = randInt(2,3);
        for(let i=0;i<pieces;i++){
          const nr = r * rand(0.52, 0.70);
          const dv = rock.vel.clone().add(new THREE.Vector3(rand(-9,9), rand(-9,9), rand(-9,9)));
          const np = p.clone().add(new THREE.Vector3(rand(-1.2,1.2), rand(-1.2,1.2), rand(-1.2,1.2)));
          spawnRock(nr, np, dv);
        }
        return;
      }

      // small rock: just particles (already done)
    }

    // initial rocks
    let level = 1;
    let rocksPerLevel = 12;

    function startLevel(){
      // clear
      while(rocks.length){
        const r = rocks.pop();
        rockGroup.remove(r.mesh);
        r.mesh.geometry.dispose();
      }
      // spawn
      for(let i=0;i<rocksPerLevel;i++){
        spawnRock(rand(3.2, 10.5));
      }
    }
    startLevel();

    // ============================
    // Particles (3D, fading)
    // ============================
    const particleGroup = new THREE.Group();
    scene.add(particleGroup);

    // tiny spheres => simple and readable; keep counts reasonable
    const particleGeo = new THREE.SphereGeometry(0.08, 8, 8);

    function makeParticleMesh(color){
      const mat = new THREE.MeshBasicMaterial({
        color,
        transparent:true,
        opacity: 1,
        depthWrite:false
      });
      return new THREE.Mesh(particleGeo, mat);
    }

    const particles = [];

    function spawnExplosionParticles(pos, amount, baseSpeed, color){
      for(let i=0;i<amount;i++){
        const m = makeParticleMesh(color);
        m.position.copy(pos).add(new THREE.Vector3(rand(-0.6,0.6), rand(-0.6,0.6), rand(-0.6,0.6)));
        const dir = new THREE.Vector3(rand(-1,1), rand(-1,1), rand(-1,1)).normalize();
        const spd = rand(baseSpeed*0.35, baseSpeed);

        const scale = rand(0.9, 2.2);
        m.scale.setScalar(scale);

        particleGroup.add(m);
        particles.push({
          mesh: m,
          vel: dir.multiplyScalar(spd),
          life: rand(0.35, 0.9),
          maxLife: 0,
          drag: rand(0.88, 0.95),
        });
        particles[particles.length-1].maxLife = particles[particles.length-1].life;
      }
    }

    function spawnBurstParticles(pos, quat, amount, speed, color){
      // cone-ish burst forward
      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(quat).normalize();
      for(let i=0;i<amount;i++){
        const m = makeParticleMesh(color);
        m.position.copy(pos).add(new THREE.Vector3(rand(-0.15,0.15), rand(-0.15,0.15), rand(-0.15,0.15)));

        const spread = new THREE.Vector3(rand(-0.35,0.35), rand(-0.35,0.35), rand(-0.35,0.35));
        const dir = forward.clone().add(spread).normalize();
        const spd = rand(speed*0.4, speed);

        const scale = rand(0.8, 1.8);
        m.scale.setScalar(scale);

        particleGroup.add(m);
        particles.push({
          mesh: m,
          vel: dir.multiplyScalar(spd),
          life: rand(0.12, 0.24),
          maxLife: 0,
          drag: rand(0.75, 0.88),
        });
        particles[particles.length-1].maxLife = particles[particles.length-1].life;
      }
    }

    function spawnThrustParticles(){
      // emit from ship rear (engine), opposite forward direction
      const backLocal = new THREE.Vector3(0, 0.0, 1.7);
      backLocal.applyQuaternion(ship.quaternion);
      const origin = ship.position.clone().add(backLocal);

      const backward = new THREE.Vector3(0,0,1).applyQuaternion(ship.quaternion).normalize();

      const count = 8;
      for(let i=0;i<count;i++){
        const m = makeParticleMesh(0xffffff);
        m.position.copy(origin).add(new THREE.Vector3(rand(-0.15,0.15), rand(-0.15,0.15), rand(-0.15,0.15)));

        const spread = new THREE.Vector3(rand(-0.30,0.30), rand(-0.30,0.30), rand(-0.30,0.30));
        const dir = backward.clone().add(spread).normalize();

        const spd = rand(10, 24);

        m.scale.setScalar(rand(0.9, 2.2));
        m.material.opacity = rand(0.55, 0.95);

        particleGroup.add(m);
        particles.push({
          mesh: m,
          vel: dir.multiplyScalar(spd).add(ship.userData.vel.clone().multiplyScalar(0.08)),
          life: rand(0.20, 0.45),
          maxLife: 0,
          drag: rand(0.78, 0.90),
        });
        particles[particles.length-1].maxLife = particles[particles.length-1].life;
      }
    }

    // ============================
    // Ship physics
    // ============================
    ship.userData.vel = new THREE.Vector3();
    const shipVel = ship.userData.vel;

    let thrusting = false;

    function updateShip(dt){
      // roll with Q/E
      const rollSpeed = 1.7;
      if(keys.has("KeyQ")) roll += rollSpeed * dt;
      if(keys.has("KeyE")) roll -= rollSpeed * dt;

      // damp roll slightly
      roll *= (1 - 0.8*dt);

      // apply orientation
      ship.rotation.order = "YXZ";
      ship.rotation.y = yaw;
      ship.rotation.x = pitch;
      ship.rotation.z = roll;

      // movement: W/S forward/back, A/D strafe
      const boost = keys.has("ShiftLeft") || keys.has("ShiftRight");
      const accel = boost ? 42 : 28;

      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).normalize();
      const right   = new THREE.Vector3(1,0, 0).applyQuaternion(ship.quaternion).normalize();
      const up      = new THREE.Vector3(0,1, 0).applyQuaternion(ship.quaternion).normalize(); // (unused but here)

      thrusting = false;

      if(keys.has("KeyW")){
        shipVel.add(forward.clone().multiplyScalar(accel*dt));
        thrusting = true;
      }
      if(keys.has("KeyS")){
        shipVel.add(forward.clone().multiplyScalar(-accel*0.8*dt));
        thrusting = true;
      }
      if(keys.has("KeyA")){
        shipVel.add(right.clone().multiplyScalar(-accel*0.7*dt));
        thrusting = true;
      }
      if(keys.has("KeyD")){
        shipVel.add(right.clone().multiplyScalar(accel*0.7*dt));
        thrusting = true;
      }

      // mild space drag (for control)
      const drag = boost ? 0.985 : 0.992;
      shipVel.multiplyScalar(Math.pow(drag, dt*60));

      // clamp
      const maxSpeed = boost ? 140 : 95;
      const sp = shipVel.length();
      if(sp > maxSpeed) shipVel.multiplyScalar(maxSpeed/sp);

      // integrate
      ship.position.add(shipVel.clone().multiplyScalar(dt));

      // thrust particles
      if(thrusting){
        // emit a few times per second proportional to dt
        const emit = Math.min(6, Math.floor(dt * 120));
        for(let i=0;i<emit;i++) spawnThrustParticles();
      }
    }

    // ============================
    // Update bullets + collisions
    // ============================
    const tmpV = new THREE.Vector3();

    function updateBullets(dt){
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.mesh.position.add(b.vel.clone().multiplyScalar(dt));
        b.life -= dt;
        if(b.life <= 0){
          scene.remove(b.mesh);
          bullets.splice(i,1);
        }
      }

      // collisions bullet-rock (sphere check)
      for(let i=rocks.length-1;i>=0;i--){
        const r = rocks[i];
        const rp = r.mesh.position;

        for(let j=bullets.length-1;j>=0;j--){
          const b = bullets[j];
          const bp = b.mesh.position;

          const hitDist = r.r + 0.12;
          if(bp.distanceTo(rp) < hitDist){
            // remove bullet
            scene.remove(b.mesh);
            bullets.splice(j,1);

            // impact particles
            spawnExplosionParticles(bp.clone(), 22, 30, 0x66c6ff);

            // fragment rock
            fragmentRock(r);
            break;
          }
        }
      }
    }

    // ============================
    // Update rocks
    // ============================
    function updateRocks(dt){
      for(const r of rocks){
        r.mesh.position.add(r.vel.clone().multiplyScalar(dt));
        r.mesh.rotation.x += r.angVel.x * dt;
        r.mesh.rotation.y += r.angVel.y * dt;
        r.mesh.rotation.z += r.angVel.z * dt;

        // keep rocks around ship: if too far, respawn nearer shell
        const d = r.mesh.position.distanceTo(ship.position);
        if(d > 900){
          r.mesh.position.copy(randomSpawnPositionAwayFromShip(220, 520));
          r.vel.copy(randomDriftVelocity(4, 12)).add(shipVel.clone().multiplyScalar(0.05));
        }
      }

      // level complete
      if(rocks.length === 0){
        level++;
        rocksPerLevel *= 2;
        startLevel();
      }
    }

    // ============================
    // Update particles
    // ============================
    function updateParticles(dt){
      for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.vel.multiplyScalar(Math.pow(p.drag, dt*60));
        p.mesh.position.add(p.vel.clone().multiplyScalar(dt));

        p.life -= dt;
        const a = clamp(p.life / p.maxLife, 0, 1);
        p.mesh.material.opacity = a;

        // slight shrink
        const s = 0.65 + 0.55*a;
        p.mesh.scale.setScalar(s);

        if(p.life <= 0){
          particleGroup.remove(p.mesh);
          p.mesh.material.dispose();
          // particleGeo is shared; do not dispose it
          particles.splice(i,1);
        }
      }

      // keep particles sane
      if(particles.length > 1800){
        const extra = particles.length - 1800;
        for(let k=0;k<extra;k++){
          const p = particles.shift();
          if(!p) break;
          particleGroup.remove(p.mesh);
          p.mesh.material.dispose();
        }
      }
    }

    // ============================
    // Camera follow update
    // ============================
    function updateCamera(dt){
      const desiredPos = camOffsetLocal.clone().applyQuaternion(ship.quaternion).add(ship.position);
      const desiredTarget = camTargetLocal.clone().applyQuaternion(ship.quaternion).add(ship.position);

      camPos.lerp(desiredPos, 1 - Math.pow(0.08, dt*60));
      camTarget.lerp(desiredTarget, 1 - Math.pow(0.10, dt*60));

      camera.position.copy(camPos);
      camera.lookAt(camTarget);
    }

    // ============================
    // HUD
    // ============================
    function updateHUD(){
      hudEl.textContent =
        `Level: ${level}\n` +
        `Rocks: ${rocks.length}\n` +
        `Bullets: ${bullets.length}\n` +
        `Particles: ${particles.length}\n` +
        `Speed: ${shipVel.length().toFixed(1)}`;
    }

    // ============================
    // Main loop
    // ============================
    const clock = new THREE.Clock();

    function tick(){
      const dt = Math.min(clock.getDelta(), 0.033);

      updateShip(dt);
      updateBullets(dt);
      updateRocks(dt);
      updateParticles(dt);
      updateCamera(dt);
      updateHUD();

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    // init camera state
    camPos.copy(camOffsetLocal);
    camTarget.copy(camTargetLocal);
    tick();
  </script>
</body>
</html>

