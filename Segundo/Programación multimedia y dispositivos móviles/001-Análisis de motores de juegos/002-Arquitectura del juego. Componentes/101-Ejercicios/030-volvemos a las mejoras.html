<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Asteroids-lite (improved)</title>
    <style>
      html,body{margin:0;padding:0;overflow:hidden;background:#000}
      canvas{display:block}
    </style>
  </head>
  <body>
    <canvas></canvas>

    <script>
      // ============================
      // Utilidades
      // ============================
      function distancia(x1, y1, x2, y2) {
        const dx = x2 - x1, dy = y2 - y1;
        return Math.hypot(dx, dy);
      }
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function rand(min, max){ return Math.random()*(max-min)+min; }
      function randInt(min,max){ return Math.floor(rand(min,max+1)); }

      // ============================
      // Setup
      // ============================
      const lienzo = document.querySelector("canvas");
      const contexto = lienzo.getContext("2d");

      let anchura = 0, altura = 0;
      function resize(){
        anchura = window.innerWidth;
        altura  = window.innerHeight;
        lienzo.width = anchura;
        lienzo.height = altura;
      }
      window.addEventListener("resize", resize);
      resize();

      // ============================
      // Partículas
      // ============================
      class Particula{
        constructor(x,y,vx,vy,r,life,color){
          this.posx=x; this.posy=y;
          this.vx=vx; this.vy=vy;
          this.r=r;
          this.life=life;
          this.maxLife=life;
          this.color=color || "white";
          this.drag = 0.98;
        }
        mueve(){
          this.vx *= this.drag;
          this.vy *= this.drag;
          this.posx += this.vx;
          this.posy += this.vy;
          this.life--;
        }
        dibuja(){
          const a = clamp(this.life/this.maxLife, 0, 1);
          contexto.save();
          contexto.globalAlpha = a;
          contexto.fillStyle = this.color;
          contexto.beginPath();
          contexto.arc(this.posx,this.posy,this.r,0,Math.PI*2);
          contexto.fill();
          contexto.restore();
        }
      }

      // ============================
      // Jugador
      // ============================
      class Jugador{
        constructor(){
          this.posx = anchura/2;
          this.posy = altura/2;
          this.angulo = 0;
          this.velx = 0;
          this.vely = 0;
          this.aceleracion = 0.18;
          this.rozamiento = 0.995;
          this.velMax = 8;

          // visual
          this.thrustGlow = 0;   // 0..1
          this.pulse = 0;
        }

        aplicaThrust(on){
          if(!on){
            this.thrustGlow *= 0.9;
            return;
          }

          this.velx += Math.cos(this.angulo)*this.aceleracion;
          this.vely += Math.sin(this.angulo)*this.aceleracion;

          const v = Math.hypot(this.velx, this.vely);
          if(v > this.velMax){
            const f = this.velMax / v;
            this.velx *= f; this.vely *= f;
          }

          // partículas "spray" del motor (círculos)
          this.thrustGlow = clamp(this.thrustGlow + 0.12, 0, 1);

          const backAng = this.angulo + Math.PI;
          const bx = this.posx + Math.cos(backAng)*16;
          const by = this.posy + Math.sin(backAng)*16;

          // abanico de spray
          const count = 4;
          for(let i=0;i<count;i++){
            const spread = rand(-0.45, 0.45);
            const a = backAng + spread;
            const speed = rand(1.6, 5.0);
            const vx = Math.cos(a)*speed + rand(-0.3,0.3) + this.velx*0.05;
            const vy = Math.sin(a)*speed + rand(-0.3,0.3) + this.vely*0.05;
            particulas.push(new Particula(
              bx + rand(-2,2),
              by + rand(-2,2),
              vx, vy,
              rand(1.2, 2.6),
              randInt(18, 32),
              "rgba(255,255,255,1)"
            ));
          }
        }

        mueve(){
          this.pulse += 0.08;

          this.velx *= this.rozamiento;
          this.vely *= this.rozamiento;
          this.posx += this.velx;
          this.posy += this.vely;

          // wrap
          if (this.posx < 0) this.posx += anchura;
          if (this.posx > anchura) this.posx -= anchura;
          if (this.posy < 0) this.posy += altura;
          if (this.posy > altura) this.posy -= altura;
        }

        dibuja(){
          // Nave vectorial más "awesome": doble contorno + ala + cabina + glow motor
          const ang = this.angulo;
          const cx = this.posx, cy = this.posy;

          // puntos base en espacio local
          const nose = {x: 24, y: 0};
          const wingL = {x: -10, y: -14};
          const wingR = {x: -10, y:  14};
          const tail  = {x: -18, y: 0};

          const finL  = {x: -2, y: -10};
          const finR  = {x: -2, y:  10};

          function rot(p){
            const c = Math.cos(ang), s = Math.sin(ang);
            return { x: cx + p.x*c - p.y*s, y: cy + p.x*s + p.y*c };
          }

          const Pnose = rot(nose);
          const PwingL= rot(wingL);
          const PwingR= rot(wingR);
          const Ptail = rot(tail);
          const PfinL = rot(finL);
          const PfinR = rot(finR);

          // glow motor
          if(this.thrustGlow > 0.02){
            const backAng = ang + Math.PI;
            const bx = cx + Math.cos(backAng)*18;
            const by = cy + Math.sin(backAng)*18;

            contexto.save();
            contexto.globalAlpha = 0.35 * this.thrustGlow;
            contexto.fillStyle = "white";
            contexto.beginPath();
            contexto.arc(bx, by, 10 + 6*Math.abs(Math.sin(this.pulse)), 0, Math.PI*2);
            contexto.fill();
            contexto.restore();
          }

          // cuerpo (relleno)
          contexto.save();
          contexto.fillStyle = "#f8f8f8";
          contexto.beginPath();
          contexto.moveTo(Pnose.x, Pnose.y);
          contexto.lineTo(PfinL.x, PfinL.y);
          contexto.lineTo(PwingL.x,PwingL.y);
          contexto.lineTo(Ptail.x, Ptail.y);
          contexto.lineTo(PwingR.x,PwingR.y);
          contexto.lineTo(PfinR.x, PfinR.y);
          contexto.closePath();
          contexto.fill();

          // contorno
          contexto.strokeStyle = "rgba(0,0,0,0.85)";
          contexto.lineWidth = 2.2;
          contexto.stroke();

          // contorno exterior "neón" sutil
          contexto.strokeStyle = "rgba(255,255,255,0.25)";
          contexto.lineWidth = 4.5;
          contexto.stroke();

          // cabina
          const canopy = rot({x: 6, y: 0});
          contexto.fillStyle = "rgba(80,180,255,0.9)";
          contexto.beginPath();
          contexto.arc(canopy.x, canopy.y, 4.2, 0, Math.PI*2);
          contexto.fill();

          // núcleo (punto rojo) como "reactor" interior
          contexto.fillStyle = "rgba(255,80,80,0.95)";
          contexto.beginPath();
          contexto.arc(cx,cy,3.6,0,Math.PI*2);
          contexto.fill();

          contexto.restore();
        }
      }

      // ============================
      // Bala
      // ============================
      class Bala{
        constructor(x,y,a, inheritVx, inheritVy){
          this.posx = x; this.posy = y; this.angulo = a;
          this.velocidad = 12;
          this.vx = Math.cos(this.angulo)*this.velocidad + inheritVx*0.25;
          this.vy = Math.sin(this.angulo)*this.velocidad + inheritVy*0.25;
          this.life = 90; // frames
        }
        dibuja(){
          contexto.fillStyle = "dodgerblue";
          contexto.beginPath();
          contexto.arc(this.posx,this.posy,3,0,Math.PI*2);
          contexto.fill();
        }
        mueve(){
          this.posx += this.vx;
          this.posy += this.vy;
          this.life--;
        }
      }

      // ============================
      // Estrella
      // ============================
      class Estrella{
        constructor(){
          this.posx = Math.random()*anchura;
          this.posy = Math.random()*altura;
          this.r = Math.random() < 0.15 ? 2 : 1;
          this.tw = rand(0, Math.PI*2);
        }
        dibuja(){
          this.tw += 0.02;
          contexto.save();
          contexto.globalAlpha = 0.6 + 0.4*Math.abs(Math.sin(this.tw));
          contexto.fillStyle = "white";
          contexto.beginPath();
          contexto.arc(this.posx,this.posy,this.r,0,Math.PI*2);
          contexto.fill();
          contexto.restore();
        }
      }

      // ============================
      // Roca (fragmentable)
      // ============================
      class Roca{
        constructor(x=null,y=null, radio=null, vx=null, vy=null){
          this.radio = (radio!=null) ? radio : (Math.random()*20+10);

          // posición
          if(x==null || y==null){
            let ok = false;
            while(!ok){
              this.posx = Math.random()*anchura;
              this.posy = Math.random()*altura;
              ok = distancia(this.posx,this.posy,jugador.posx,jugador.posy) > 120;
            }
          } else {
            this.posx = x; this.posy = y;
          }

          this.angulo = Math.random()*Math.PI*2;
          this.lados = Math.round(Math.random()*10+7);

          const rug = 0.45;
          this.puntas = Array.from({length:this.lados}, () => 1 + (Math.random()*2 - 1) * rug);

          // velocidad
          if(vx==null || vy==null){
            const v = Math.random()*1.6+0.4;
            const dir = Math.random()*Math.PI*2;
            this.vx = Math.cos(dir)*v;
            this.vy = Math.sin(dir)*v;
          } else {
            this.vx = vx; this.vy = vy;
          }

          this.rot = (Math.random()-0.5)*0.05;
        }

        dibuja(){
          contexto.save();

          // relleno + sombra suave (vectorial)
          contexto.fillStyle = "rgba(160,160,160,1)";
          contexto.beginPath();
          for(let i=0;i<this.lados;i++){
            const ang = (i/this.lados)*Math.PI*2 + this.angulo;
            const r = this.radio * this.puntas[i];
            const x = this.posx + Math.cos(ang)*r;
            const y = this.posy + Math.sin(ang)*r;
            if(i===0) contexto.moveTo(x,y); else contexto.lineTo(x,y);
          }
          contexto.closePath();
          contexto.fill();

          contexto.strokeStyle = "rgba(30,30,30,0.9)";
          contexto.lineWidth = 2;
          contexto.stroke();

          // highlight
          contexto.strokeStyle = "rgba(255,255,255,0.12)";
          contexto.lineWidth = 4;
          contexto.stroke();

          contexto.restore();
        }

        mueve(){
          this.angulo += this.rot;
          this.posx += this.vx;
          this.posy += this.vy;

          // Ricochet en bordes (considerando radio)
          if (this.posx - this.radio < 0){
            this.posx = this.radio;
            this.vx = -this.vx;
          } else if (this.posx + this.radio > anchura){
            this.posx = anchura - this.radio;
            this.vx = -this.vx;
          }
          if (this.posy - this.radio < 0){
            this.posy = this.radio;
            this.vy = -this.vy;
          } else if (this.posy + this.radio > altura){
            this.posy = altura - this.radio;
            this.vy = -this.vy;
          }
        }
      }

      // ============================
      // Targeting / crosshair
      // ============================
      function findTargetRock(){
        // “targeting”: si una roca está cerca del eje frontal (rayo) y relativamente cerca, se marca
        const maxDist = 520;
        const maxAng  = 0.18; // ~10 grados
        let best = null;
        let bestScore = Infinity;

        const fx = Math.cos(jugador.angulo);
        const fy = Math.sin(jugador.angulo);

        for(const r of rocas){
          const dx = r.posx - jugador.posx;
          const dy = r.posy - jugador.posy;

          const d = Math.hypot(dx,dy);
          if(d > maxDist) continue;

          // ángulo respecto a forward
          const ndx = dx / d, ndy = dy / d;
          const dot = ndx*fx + ndy*fy; // cos
          const ang = Math.acos(clamp(dot, -1, 1));
          if(ang > maxAng) continue;

          // score: prioriza el que esté más centrado y cercano
          const score = ang*280 + d;
          if(score < bestScore){
            bestScore = score;
            best = r;
          }
        }
        return best;
      }

      function drawCrosshair(rock){
        if(!rock) return;
        const t = performance.now()*0.008;
        const rad = rock.radio + 14 + 2*Math.sin(t);

        contexto.save();
        contexto.translate(rock.posx, rock.posy);

        // aro
        contexto.strokeStyle = "rgba(80,200,255,0.9)";
        contexto.lineWidth = 2;
        contexto.beginPath();
        contexto.arc(0,0,rad,0,Math.PI*2);
        contexto.stroke();

        // ticks
        contexto.strokeStyle = "rgba(80,200,255,0.75)";
        contexto.lineWidth = 3;
        const tick = 10;
        // arriba
        contexto.beginPath(); contexto.moveTo(0, -rad); contexto.lineTo(0, -rad+tick); contexto.stroke();
        // abajo
        contexto.beginPath(); contexto.moveTo(0,  rad); contexto.lineTo(0,  rad-tick); contexto.stroke();
        // izq
        contexto.beginPath(); contexto.moveTo(-rad, 0); contexto.lineTo(-rad+tick, 0); contexto.stroke();
        // der
        contexto.beginPath(); contexto.moveTo( rad, 0); contexto.lineTo( rad-tick, 0); contexto.stroke();

        contexto.restore();
      }

      // ============================
      // Juego
      // ============================
      const jugador = new Jugador();

      let estrellas = Array.from({length:120}, ()=>new Estrella());
      let balas = [];
      let particulas = [];

      // Niveles
      let level = 1;
      let rocksPerLevel = 100; // base
      let rocas = [];
      let levelMessageTimer = 0;

      function spawnRocas(n){
        for(let i=0;i<n;i++) rocas.push(new Roca());
      }

      function startLevel(){
        rocas.length = 0;
        spawnRocas(rocksPerLevel);
        levelMessageTimer = 120;
      }
      startLevel();

      // ============================
      // Fragmentación / Explosiones
      // ============================
      function explodeToParticles(x,y, amount, baseSpeed, rMin, rMax, color){
        for(let k=0;k<amount;k++){
          const a = rand(0, Math.PI*2);
          const s = rand(baseSpeed*0.35, baseSpeed);
          const vx = Math.cos(a)*s;
          const vy = Math.sin(a)*s;
          particulas.push(new Particula(
            x + rand(-2,2),
            y + rand(-2,2),
            vx, vy,
            rand(rMin, rMax),
            randInt(22, 52),
            color || "rgba(255,255,255,1)"
          ));
        }
      }

      function fragmentRock(rock){
        // grandes -> 2-3 medianas; medianas -> 2 pequeñas; pequeñas -> partículas
        const r = rock.radio;

        if(r >= 34){
          const pieces = randInt(2,3);
          for(let i=0;i<pieces;i++){
            const nr = r * rand(0.42, 0.56);
            const dvx = rock.vx + rand(-1.2,1.2);
            const dvy = rock.vy + rand(-1.2,1.2);
            rocas.push(new Roca(
              rock.posx + rand(-6,6),
              rock.posy + rand(-6,6),
              nr,
              dvx,
              dvy
            ));
          }
          explodeToParticles(rock.posx, rock.posy, 14, 4.5, 1.2, 2.4, "rgba(200,200,200,1)");
          return;
        }

        if(r >= 20){
          const pieces = randInt(2,3);
          for(let i=0;i<pieces;i++){
            const nr = r * rand(0.50, 0.68);
            const dvx = rock.vx + rand(-1.6,1.6);
            const dvy = rock.vy + rand(-1.6,1.6);
            rocas.push(new Roca(
              rock.posx + rand(-5,5),
              rock.posy + rand(-5,5),
              nr,
              dvx,
              dvy
            ));
          }
          explodeToParticles(rock.posx, rock.posy, 18, 5.5, 1.2, 2.6, "rgba(210,210,210,1)");
          return;
        }

        // pequeña: se destruye en partículas
        explodeToParticles(rock.posx, rock.posy, 34, 7.0, 1.2, 3.0, "rgba(230,230,230,1)");
      }

      // ============================
      // Controles
      // ============================
      let giro = 0;
      let thrust = false;

      document.body.onkeydown = (e)=>{
        const k = e.key.toLowerCase();
        if(k === "a") giro = -1;
        if(k === "d") giro = 1;
        if(k === "w") thrust = true;

        if(e.code === "Space"){
          // dispara desde la "nariz"
          const muzzleX = jugador.posx + Math.cos(jugador.angulo)*24;
          const muzzleY = jugador.posy + Math.sin(jugador.angulo)*24;
          balas.push(new Bala(muzzleX, muzzleY, jugador.angulo, jugador.velx, jugador.vely));

          // pequeña chispa
          explodeToParticles(muzzleX, muzzleY, 6, 3.2, 0.9, 1.6, "rgba(80,180,255,1)");
        }
      };

      document.body.onkeyup = (e)=>{
        const k = e.key.toLowerCase();
        if(k === "a" && giro === -1) giro = 0;
        if(k === "d" && giro === 1)  giro = 0;
        if(k === "w") thrust = false;
      };

      // ============================
      // HUD
      // ============================
      function drawLevelText(){
        if(levelMessageTimer <= 0) return;
        contexto.save();
        contexto.font = "bold 48px sans-serif";
        contexto.textAlign = "center";
        contexto.textBaseline = "middle";
        contexto.fillStyle = "white";
        contexto.strokeStyle = "rgba(0,0,0,0.6)";
        contexto.lineWidth = 6;
        const msg = `LEVEL ${level}`;
        contexto.strokeText(msg, anchura/2, altura*0.2);
        contexto.fillText(msg, anchura/2, altura*0.2);
        contexto.restore();
        levelMessageTimer--;
      }

      // ============================
      // Bucle
      // ============================
      let temporizador = null;

      function bucle(){
        // Input
        jugador.angulo += giro * 0.08;
        jugador.aplicaThrust(thrust);

        // Fondo
        contexto.fillStyle = "black";
        contexto.fillRect(0,0,anchura,altura);

        // Estrellas
        estrellas.forEach(s=>s.dibuja());

        // Targeting
        const target = findTargetRock();

        // Rocas
        rocas.forEach(r=>{ r.mueve(); r.dibuja(); });

        // Crosshair encima de rocas (para que no quede tapado)
        drawCrosshair(target);

        // Balas
        for(let i=balas.length-1;i>=0;i--){
          const b = balas[i];
          b.mueve();
          b.dibuja();

          // vida / fuera
          if(b.life <= 0 || b.posx<0 || b.posx>anchura || b.posy<0 || b.posy>altura){
            balas.splice(i,1);
          }
        }

        // Partículas
        for(let p=particulas.length-1;p>=0;p--){
          const pa = particulas[p];
          pa.mueve();
          pa.dibuja();
          if(pa.life <= 0) particulas.splice(p,1);
        }

        // Jugador
        jugador.mueve();
        jugador.dibuja();

        // Colisiones bala-roca (con fragmentación)
        for(let i=rocas.length-1;i>=0;i--){
          const roca = rocas[i];
          for(let j=balas.length-1;j>=0;j--){
            const bala = balas[j];
            if(distancia(bala.posx,bala.posy,roca.posx,roca.posy) < roca.radio){
              // quitar bala y roca
              balas.splice(j,1);
              rocas.splice(i,1);

              // fragmentar / destruir
              fragmentRock(roca);

              break;
            }
          }
        }

        // ¿Nivel completado?
        if(rocas.length === 0){
          level++;
          rocksPerLevel *= 2;
          startLevel();
        }

        // HUD esquina
        contexto.fillStyle = "white";
        contexto.font = "16px monospace";
        contexto.fillText(`Level: ${level}`, 12, 22);
        contexto.fillText(`Rocks: ${rocas.length}`, 12, 42);

        // Cartel de nivel
        drawLevelText();

        temporizador = setTimeout(bucle, 16);
      }

      temporizador = setTimeout(bucle, 16);
    </script>
  </body>
</html>

