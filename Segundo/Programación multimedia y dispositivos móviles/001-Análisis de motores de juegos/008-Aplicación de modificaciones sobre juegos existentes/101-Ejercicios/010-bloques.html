<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Minecraft Clone — Chunks + Instancing + SSAO</title>
  <style>
    html,body { margin:0; height:100%; overflow:hidden; font-family: system-ui, Arial; background:#000; }
    #crosshair {
      position:absolute; top:50%; left:50%; width:20px; height:20px; transform:translate(-50%,-50%); pointer-events:none;
    }
    #crosshair::before, #crosshair::after {
      content:""; position:absolute; background:white;
    }
    #crosshair::before { width:2px; height:20px; left:50%; transform:translateX(-50%); }
    #crosshair::after  { width:20px; height:2px; top:50%; transform:translateY(-50%); }
    #ui {
      position:absolute; top:10px; left:10px; background:rgba(0,0,0,.6); color:#fff; padding:10px 12px; border-radius:8px; font-size:14px; pointer-events:none;
    }
    #block-selector {
      position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,.6); padding:8px; border-radius:8px; display:flex; gap:8px;
    }
    .block-option { width:36px; height:36px; border:2px solid transparent; border-radius:4px; cursor:pointer; pointer-events:auto; }
    .block-option.selected { border-color:#fff; }
    #reset-btn {
      position:absolute; top:10px; right:10px; background:rgba(255,0,0,.7); color:#fff; border:none; padding:10px 12px; border-radius:8px; cursor:pointer; pointer-events:auto;
    }
    #reset-btn:hover { background:rgba(255,0,0,.9); }
    #overlay {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.7); color:#fff;
    }
    #overlay .card {
      max-width:520px; padding:24px; border-radius:12px; background:rgba(20,20,20,.9); text-align:center; line-height:1.5;
      box-shadow:0 10px 30px rgba(0,0,0,.5);
    }
    #overlay h1 { margin:0 0 8px; font-size:24px; }
    #overlay p { margin:4px 0; opacity:.9; }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <div id="ui">
    <div><b>WASD</b> move • <b>Mouse</b> look</div>
    <div><b>Space</b> jump • <b>LClick</b> remove • <b>RClick</b> place</div>
    <div><b>1/2/3</b> block type • <b>R</b> respawn • <b>O</b> SSAO • <b>P</b> SSAO scale • Auto-save</div>
  </div>
  <div id="block-selector">
    <div class="block-option selected" data-type="grass" style="background:#4CAF50"></div>
    <div class="block-option" data-type="dirt"  style="background:#795548"></div>
    <div class="block-option" data-type="stone" style="background:#9E9E9E"></div>
  </div>
  <button id="reset-btn">Reset World</button>

  <div id="overlay">
    <div class="card">
      <h1>Minecraft Clone — Chunks + Instancing + SSAO</h1>
      <p>Click to start • Mouse to look</p>
      <p>WASD move • Space jump • LClick remove • RClick place</p>
      <p>1/2/3 block type • O toggle SSAO • P SSAO quality • Auto-saves</p>
    </div>
  </div>

 <!-- Core -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>

<!-- Post-processing deps (order matters) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/SSAOShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/math/SimplexNoise.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/SSAOPass.js"></script>



  <script>
  // ----------------- Config -----------------
  const CONFIG = {
    CHUNK_SIZE: 16,
    CHUNK_HEIGHT: 16,
    WORLD_SIZE_CHUNKS: 8,        // 8x8 chunks → 128x128 world
    PLAYER: {
      HEIGHT: 1.8,
      RADIUS: 0.3,
      SPEED: 5.0,
      JUMP: 8.0,
      GRAVITY: -20.0
    },
    CULLING_RADIUS: 70,          // blocks
    SHADOW_RADIUS: 16,           // blocks
    SAVE_KEY: 'voxelWorldChunks_v3',
    MAX_INSTANCES_PER_CHUNK_PER_TYPE: 4096
  };

  const BLOCK_TYPES = ['grass','dirt','stone'];
  const COLORS = { grass: 0x4CAF50, dirt: 0x795548, stone: 0x9E9E9E };

  // ----------------- Utils -----------------
  const key = (x,y,z)=> `${x}|${y}|${z}`;
  const chunkKey = (cx,cy,cz)=> `${cx}|${cy}|${cz}`;
  const floorDiv = (n, d) => Math.floor(n / d);
  const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));

  // Shared resources
  const SHARED = {
    geometry: new THREE.BoxGeometry(1,1,1),
    materials: {},
    textures: {}
  };
  function makeCanvasTexture(hex) {
    if (SHARED.textures[hex]) return SHARED.textures[hex];
    const r=(hex>>16)&255, g=(hex>>8)&255, b=hex&255;
    const c = document.createElement('canvas'); c.width = 64; c.height = 64;
    const ctx = c.getContext('2d');
    ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fillRect(0,0,64,64);
    ctx.globalAlpha = 0.3;
    for (let i=0;i<200;i++){
      const x=Math.random()*64, y=Math.random()*64, s=Math.random()*3+1;
      const br = Math.random()*50-25;
      ctx.fillStyle = `rgb(${clamp(r+br,0,255)},${clamp(g+br,0,255)},${clamp(b+br,0,255)})`;
      ctx.fillRect(x,y,s,s);
    }
    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.magFilter = tex.minFilter = THREE.NearestFilter;
    tex.generateMipmaps = false;
    SHARED.textures[hex] = tex;
    return tex;
  }
  function getMaterial(type){
    if (SHARED.materials[type]) return SHARED.materials[type];
    const color = COLORS[type] || COLORS.grass;
    const mat = new THREE.MeshPhongMaterial({ color, map: makeCanvasTexture(color) });
    SHARED.materials[type] = mat;
    return mat;
  }

  // ----------------- Chunk -----------------
  class Chunk {
    constructor(cx, cy, cz, scene){
      this.cx = cx; this.cy = cy; this.cz = cz;
      this.scene = scene;
      this.size = CONFIG.CHUNK_SIZE;
      this.height = CONFIG.CHUNK_HEIGHT;

      this.voxels = new Map();
      this.meshByType = new Map(); // type -> { mesh, instanceCount, idToPos[], posToId(Map) }
      for (const type of BLOCK_TYPES){
        const mat = getMaterial(type);
        const mesh = new THREE.InstancedMesh(
          SHARED.geometry,
          mat,
          CONFIG.MAX_INSTANCES_PER_CHUNK_PER_TYPE
        );
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        mesh.visible = false;
        mesh.frustumCulled = false;
        mesh.count = 0;
        this.scene.add(mesh);
        this.meshByType.set(type, {
          mesh, instanceCount: 0,
          idToPos: [],
          posToId: new Map()
        });
      }

      const min = new THREE.Vector3(
        cx*this.size, cy*this.height, cz*this.size
      );
      const max = new THREE.Vector3(
        (cx+1)*this.size, (cy+1)*this.height, (cz+1)*this.size
      );
      this.aabb = new THREE.Box3(min, max);
    }

    addBlock(x,y,z,type){
      const k = key(x,y,z);
      if (this.voxels.has(k)) return false;
      this.voxels.set(k, type);
      const pack = this.meshByType.get(type);
      const index = pack.instanceCount++;
      const m = new THREE.Matrix4().makeTranslation(x+0.5, y+0.5, z+0.5);
      pack.mesh.setMatrixAt(index, m);
      pack.mesh.instanceMatrix.needsUpdate = true;
      pack.idToPos[index] = {x,y,z};
      pack.posToId.set(k, index);
      pack.mesh.count = pack.instanceCount;
      return true;
    }

    removeBlock(x,y,z){
      const k = key(x,y,z);
      const type = this.voxels.get(k);
      if (!type) return false;
      const pack = this.meshByType.get(type);
      const index = pack.posToId.get(k);
      if (index === undefined) return false;

      const lastIndex = pack.instanceCount - 1;
      if (index !== lastIndex){
        const tmp = new THREE.Matrix4();
        pack.mesh.getMatrixAt(lastIndex, tmp);
        pack.mesh.setMatrixAt(index, tmp);
        const movedPos = pack.idToPos[lastIndex];
        pack.idToPos[index] = movedPos;
        pack.posToId.set(key(movedPos.x, movedPos.y, movedPos.z), index);
      }
      pack.instanceCount--;
      pack.mesh.count = pack.instanceCount;
      pack.idToPos.pop();
      pack.posToId.delete(k);
      pack.mesh.instanceMatrix.needsUpdate = true;
      this.voxels.delete(k);
      return true;
    }

    setVisible(v){
      for (const [,pack] of this.meshByType){
        pack.mesh.visible = v && pack.instanceCount>0;
      }
    }
    setShadowsEnabled(near){
      for (const [,pack] of this.meshByType){
        pack.mesh.castShadow = near;
        pack.mesh.receiveShadow = near;
      }
    }

    raycast(raycaster, intersects){
      for (const [,pack] of this.meshByType){
        if (!pack.mesh.visible || pack.instanceCount===0) continue;
        pack.mesh.raycast(raycaster, intersects);
      }
    }

    instanceInfo(object, instanceId){
      for (const [type, pack] of this.meshByType){
        if (pack.mesh === object){
          const pos = pack.idToPos[instanceId];
          if (!pos) return null;
          return { type, ...pos };
        }
      }
      return null;
    }

    serialize(){
      const list = [];
      for (const [k, t] of this.voxels){
        const [x,y,z] = k.split('|').map(Number);
        list.push([x,y,z,t]);
      }
      return { cx:this.cx, cy:this.cy, cz:this.cz, voxels:list };
    }

    static deserialize(data, scene){
      const ch = new Chunk(data.cx, data.cy, data.cz, scene);
      for (const [x,y,z,t] of data.voxels){
        ch.addBlock(x,y,z,t);
      }
      return ch;
    }
  }

  // ----------------- World -----------------
  class World {
    constructor(scene){
      this.scene = scene;
      this.chunks = new Map();
      this.voxelIndex = new Map();
    }

    getChunkCoords(x,y,z){
      const cs = CONFIG.CHUNK_SIZE, ch = CONFIG.CHUNK_HEIGHT;
      return {
        cx: floorDiv(x, cs),
        cy: floorDiv(y, ch),
        cz: floorDiv(z, cs)
      };
    }
    getChunk(cx,cy,cz, createIfMissing=false){
      const ck = chunkKey(cx,cy,cz);
      let ch = this.chunks.get(ck);
      if (!ch && createIfMissing){
        ch = new Chunk(cx,cy,cz,this.scene);
        this.chunks.set(ck,ch);
      }
      return ch;
    }

    hasBlock(x,y,z){ return this.voxelIndex.has(key(x,y,z)); }

    addBlock(x,y,z,type){
      const {cx,cy,cz} = this.getChunkCoords(x,y,z);
      const ch = this.getChunk(cx,cy,cz,true);
      if (ch.addBlock(x,y,z,type)){
        this.voxelIndex.set(key(x,y,z), { type, cx,cy,cz });
        return true;
      }
      return false;
    }

    removeBlock(x,y,z){
      const v = this.voxelIndex.get(key(x,y,z));
      if (!v) return false;
      const ch = this.getChunk(v.cx, v.cy, v.cz, false);
      if (!ch) return false;
      if (ch.removeBlock(x,y,z)){
        this.voxelIndex.delete(key(x,y,z));
        return true;
      }
      return false;
    }

    neighborsOfAABB(min, max){
      const res = [];
      for (let x=Math.floor(min.x)-1; x<=Math.floor(max.x)+1; x++){
        for (let y=Math.floor(min.y)-1; y<=Math.floor(max.y)+1; y++){
          for (let z=Math.floor(min.z)-1; z<=Math.floor(max.z)+1; z++){
            const v = this.voxelIndex.get(key(x,y,z));
            if (v) res.push({x,y,z});
          }
        }
      }
      return res;
    }

    setChunksVisibilityAndShadows(cameraPos){
      const r2 = CONFIG.CULLING_RADIUS*CONFIG.CULLING_RADIUS;
      const s2 = CONFIG.SHADOW_RADIUS*CONFIG.SHADOW_RADIUS;
      for (const [,ch] of this.chunks){
        const cx = (ch.cx+0.5)*ch.size;
        const cz = (ch.cz+0.5)*ch.size;
        const dx = cx - cameraPos.x;
        const dz = cz - cameraPos.z;
        const d2 = dx*dx + dz*dz;
        const visible = d2 <= r2;
        const nearShadow = d2 <= s2;
        ch.setVisible(visible);
        ch.setShadowsEnabled(nearShadow);
      }
    }

    raycast(raycaster){
      const intersects = [];
      for (const [,ch] of this.chunks){
        ch.raycast(raycaster, intersects);
      }
      if (intersects.length === 0) return null;
      intersects.sort((a,b)=> a.distance - b.distance);
      const hit = intersects[0];
      const ch = this.findChunkByMesh(hit.object);
      if (!ch) return null;
      const info = ch.instanceInfo(hit.object, hit.instanceId);
      if (!info) return null;
      return { ...info, point: hit.point, face: hit.face, object: hit.object, chunk: ch };
    }

    findChunkByMesh(mesh){
      for (const [,ch] of this.chunks){
        for (const [,pack] of ch.meshByType){
          if (pack.mesh === mesh) return ch;
        }
      }
      return null;
    }

    serialize(){
      const data = [];
      for (const [,ch] of this.chunks){
        if (ch.voxels.size>0) data.push(ch.serialize());
      }
      return data;
    }
    static deserialize(arr, scene){
      const w = new World(scene);
      for (const chData of arr){
        const ch = Chunk.deserialize(chData, scene);
        w.chunks.set(chunkKey(ch.cx,ch.cy,ch.cz), ch);
        for (const [k,t] of ch.voxels){
          const [x,y,z] = k.split('|').map(Number);
          w.voxelIndex.set(k, { type:t, cx:ch.cx, cy:ch.cy, cz:ch.cz });
        }
      }
      return w;
    }
  }

  // ----------------- Game -----------------
  class Game {
    constructor(){
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x87CEEB);

      this.camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
      this.camera.position.set(0, 5, 10);

      this.renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:'high-performance' });
      this.renderer.setSize(innerWidth, innerHeight);
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(this.renderer.domElement);

      // SSAO / Composer
      this.useSSAO = true;
      this.ssaoScale = 0.5; // 0.5 = half-res
      this.composer = null;
      this.renderPass = null;
      this.ssaoPass = null;
      this.setupPostFX();

      // Lights
      const amb = new THREE.AmbientLight(0xffffff, 0.8);
      this.scene.add(amb);
      const sun = new THREE.DirectionalLight(0xffffff, 1.8);
      sun.position.set(60, 80, 40);
      sun.castShadow = true;
      sun.shadow.mapSize.set(1024,1024);
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 300;
      sun.shadow.camera.left = -100;
      sun.shadow.camera.right = 100;
      sun.shadow.camera.top = 100;
      sun.shadow.camera.bottom = -100;
      this.scene.add(sun);

      // Controls
      this.controls = new THREE.PointerLockControls(this.camera, document.body);
      const overlay = document.getElementById('overlay');
      document.body.addEventListener('click', ()=>{
        if (!this.controls.isLocked) this.controls.lock();
      });
      this.controls.addEventListener('lock', ()=> overlay.style.display='none');
      this.controls.addEventListener('unlock', ()=> overlay.style.display='flex');

      // Input
      this.move = { f:false,b:false,l:false,r:false,j:false };
      addEventListener('keydown', e=>{
        if (e.code==='KeyW') this.move.f=true;
        if (e.code==='KeyS') this.move.b=true;
        if (e.code==='KeyA') this.move.l=true;
        if (e.code==='KeyD') this.move.r=true;
        if (e.code==='Space' && this.onGround) this.move.j=true;
        if (e.code==='Digit1') this.selectBlock('grass');
        if (e.code==='Digit2') this.selectBlock('dirt');
        if (e.code==='Digit3') this.selectBlock('stone');
        if (e.code==='KeyR') this.respawn();

        // SSAO controls
        if (e.code==='KeyO'){ // toggle SSAO
          this.useSSAO = !this.useSSAO;
        }
        if (e.code==='KeyP'){ // cycle quality
          const levels = [1.0, 0.5, 0.33];
          const i = levels.indexOf(this.ssaoScale);
          this.ssaoScale = levels[(i+1) % levels.length];
          if (this.ssaoPass){
            const w = Math.max(1, Math.floor(innerWidth  * this.ssaoScale));
            const h = Math.max(1, Math.floor(innerHeight * this.ssaoScale));
            this.ssaoPass.setSize(w, h);
          }
        }
      });
      addEventListener('keyup', e=>{
        if (e.code==='KeyW') this.move.f=false;
        if (e.code==='KeyS') this.move.b=false;
        if (e.code==='KeyA') this.move.l=false;
        if (e.code==='KeyD') this.move.r=false;
        if (e.code==='Space') this.move.j=false;
      });

      // UI selector
      this.selectedType = 'grass';
      const opts = document.querySelectorAll('.block-option');
      opts.forEach(o=>o.addEventListener('click', ()=>{
        opts.forEach(p=>p.classList.remove('selected'));
        o.classList.add('selected');
        this.selectedType = o.dataset.type;
      }));
      document.getElementById('reset-btn').addEventListener('click', ()=>{
        if (confirm('Reset world?')){
          localStorage.removeItem(CONFIG.SAVE_KEY);
          location.reload();
        }
      });

      // Mouse actions
      addEventListener('contextmenu', e=> e.preventDefault());
      addEventListener('mousedown', (e)=>{
        if (!this.controls.isLocked) return;
        if (e.button===0) this.removeBlockAtPointer();
        if (e.button===2) this.placeBlockAtPointer();
      });

      // Resize
      addEventListener('resize', ()=>{
        this.camera.aspect = innerWidth/innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(innerWidth, innerHeight);
        if (this.composer){
          this.composer.setSize(innerWidth, innerHeight);
          const w = Math.max(1, Math.floor(innerWidth  * this.ssaoScale));
          const h = Math.max(1, Math.floor(innerHeight * this.ssaoScale));
          this.ssaoPass.setSize(w, h);
        }
      });

      // World
      this.world = null;

      // Physics
      this.velocity = new THREE.Vector3();
      this.onGround = false;

      // Raycaster
      this.raycaster = new THREE.Raycaster();
      this.raycaster.far = 10;

      // Clock
      this.clock = new THREE.Clock();

      // Load or create
      this.loadOrCreateWorld();

      // Autosave timer
      this.lastAutoSave = 0;

      this.animate();
    }

    setupPostFX(){
      this.composer = new THREE.EffectComposer(this.renderer);
      this.renderPass = new THREE.RenderPass(this.scene, this.camera);
      this.composer.addPass(this.renderPass);

      const w = Math.max(1, Math.floor(innerWidth  * this.ssaoScale));
      const h = Math.max(1, Math.floor(innerHeight * this.ssaoScale));
      this.ssaoPass = new THREE.SSAOPass(this.scene, this.camera, w, h);
      // tuned for voxel look
      this.ssaoPass.kernelRadius = 5;   // try 8–12
      this.ssaoPass.minDistance  = 0.005;
      this.ssaoPass.maxDistance  = 0.12;

      this.composer.addPass(this.ssaoPass);
    }

    selectBlock(t){ this.selectedType = t; }

    // --------- World generation ----------
    createDefaultWorld(){
      this.world = new World(this.scene);
      const sizeChunks = CONFIG.WORLD_SIZE_CHUNKS;
      const CS = CONFIG.CHUNK_SIZE;
      const worldSize = sizeChunks*CS;

      function noise2(x,z){
        return Math.sin(x*0.07)*0.7 + Math.cos(z*0.09)*0.5 + Math.sin((x+z)*0.03)*0.6;
      }

      for (let x=0; x<worldSize; x++){
        for (let z=0; z<worldSize; z++){
          const h = Math.floor(2 + Math.max(0, noise2(x,z)*2)); // height ≈2..5
          for (let y=0; y<h; y++){
            let type = (y===h-1) ? 'grass' : (y>=h-3 ? 'dirt' : 'stone');
            this.world.addBlock(x, y-1, z, type);
          }
        }
      }
      for (let i=0;i<80;i++){
        const x = Math.floor(Math.random()*worldSize);
        const z = Math.floor(Math.random()*worldSize);
        const h = 1+Math.floor(Math.random()*4);
        for (let y=0;y<h;y++){
          this.world.addBlock(x, y+2, z, 'stone');
        }
      }
    }

    saveWorld(){
      if (!this.world) return;
      const data = {
        chunks: this.world.serialize(),
        player: { x:this.camera.position.x, y:this.camera.position.y, z:this.camera.position.z }
      };
      localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(data));
    }

    loadOrCreateWorld(){
      const raw = localStorage.getItem(CONFIG.SAVE_KEY);
      if (raw){
        try{
          const parsed = JSON.parse(raw);
          this.world = World.deserialize(parsed.chunks || [], this.scene);
          if (parsed.player){
            this.camera.position.set(parsed.player.x, parsed.player.y, parsed.player.z);
          }
        }catch(e){
          console.warn('Error loading save, creating new world', e);
          this.createDefaultWorld();
        }
      } else {
        this.createDefaultWorld();
      }
    }

    // --------- Interactions ---------
    removeBlockAtPointer(){
      this.raycaster.setFromCamera(new THREE.Vector2(0,0), this.camera);
      const hit = this.world.raycast(this.raycaster);
      if (!hit) return;
      this.world.removeBlock(hit.x, hit.y, hit.z);
    }

    placeBlockAtPointer(){
      this.raycaster.setFromCamera(new THREE.Vector2(0,0), this.camera);
      const hit = this.world.raycast(this.raycaster);
      if (!hit) return;
      const n = hit.face.normal.clone();
      n.transformDirection(hit.object.matrixWorld);
      const nx = hit.x + Math.round(n.x);
      const ny = hit.y + Math.round(n.y);
      const nz = hit.z + Math.round(n.z);

      const playerPos = this.camera.position;
      const dist = new THREE.Vector3(nx+0.5, ny+0.5, nz+0.5).distanceTo(playerPos);
      if (dist < 1.5) return;

      if (!this.world.hasBlock(nx,ny,nz)){
        this.world.addBlock(nx,ny,nz,this.selectedType);
      }
    }

    // --------- Collision ---------
    playerAABBAt(pos){
      const r = CONFIG.PLAYER.RADIUS;
      const h = CONFIG.PLAYER.HEIGHT;
      return new THREE.Box3(
        new THREE.Vector3(pos.x - r, pos.y - h, pos.z - r),
        new THREE.Vector3(pos.x + r, pos.y,     pos.z + r)
      );
    }
    collidesAt(pos){
      const aabb = this.playerAABBAt(pos);
      const neighbors = this.world.neighborsOfAABB(aabb.min, aabb.max);
      for (const b of neighbors){
        const bb = new THREE.Box3(
          new THREE.Vector3(b.x, b.y, b.z),
          new THREE.Vector3(b.x+1, b.y+1, b.z+1)
        );
        if (aabb.intersectsBox(bb)) return true;
      }
      return false;
    }

    respawn(){
      this.camera.position.set(0, 8, 0);
      this.velocity.set(0,0,0);
    }

    // --------- Loop ---------
    animate(){
      requestAnimationFrame(()=>this.animate());
      const dt = Math.min(this.clock.getDelta(), 0.05);

      // Movement
      if (this.controls.isLocked){
        const dir = new THREE.Vector3();
        this.camera.getWorldDirection(dir);
        dir.y = 0; dir.normalize();
        const right = new THREE.Vector3().crossVectors(this.camera.up, dir).normalize();

        const speed = CONFIG.PLAYER.SPEED;
        let dx=0, dz=0;
        if (this.move.f) { dx += dir.x; dz += dir.z; }
        if (this.move.b) { dx -= dir.x; dz -= dir.z; }
        if (this.move.l) { dx += right.x; dz += right.z; }
        if (this.move.r) { dx -= right.x; dz -= right.z; }

        const horiz = new THREE.Vector3(dx,0,dz);
        if (horiz.lengthSq()>0) horiz.normalize().multiplyScalar(speed*dt);

        const posH = this.camera.position.clone().add(horiz);
        if (!this.collidesAt(posH)){
          this.camera.position.copy(posH);
        }

        if (this.move.j && this.onGround){
          this.velocity.y = CONFIG.PLAYER.JUMP;
          this.onGround = false;
          this.move.j = false;
        }
        this.velocity.y += CONFIG.PLAYER.GRAVITY * dt;

        const posV = this.camera.position.clone();
        posV.y += this.velocity.y * dt;

        if (!this.collidesAt(posV)){
          this.camera.position.y = posV.y;
          this.onGround = false;
        } else {
          if (this.velocity.y < 0) this.onGround = true;
          this.velocity.y = 0;
        }

        if (this.camera.position.y < -20) this.respawn();
      }

      // Visibility & shadows by radius
      this.world.setChunksVisibilityAndShadows(this.camera.position);

      // Autosave every ~10s
      this.lastAutoSave += dt;
      if (this.lastAutoSave >= 10){
        this.lastAutoSave = 0;
        this.saveWorld();
      }

      // Render path
      if (this.useSSAO && this.composer){
        this.composer.render();
      } else {
        this.renderer.render(this.scene, this.camera);
      }
    }
  }

  // ----------------- Start -----------------
  new Game();
  </script>
</body>
</html>

