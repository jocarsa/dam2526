<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Voxel + Terreno Suavizado (Opción A) + Nubes + Niebla (Delta Save + Superficie Suavizada)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui,Arial;background:#000}
    #crosshair{
      position:absolute;top:50%;left:50%;width:20px;height:20px;transform:translate(-50%,-50%);pointer-events:none
    }
    #crosshair::before,#crosshair::after{content:"";position:absolute;background:white}
    #crosshair::before{width:2px;height:20px;left:50%;transform:translateX(-50%)}
    #crosshair::after{width:20px;height:2px;top:50%;transform:translateY(-50%)}

    #ui{
      position:absolute;top:10px;left:10px;z-index:10;
      background:rgba(0,0,0,.55);color:#fff;padding:10px 12px;border-radius:10px;
      font-size:14px;line-height:1.35;pointer-events:none;
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
      max-width: 560px;
    }
    #ui .muted{opacity:.85}

    #toast{
      position:absolute;left:50%;top:12px;transform:translateX(-50%);
      background:rgba(20,20,20,.88);color:#fff;padding:10px 12px;border-radius:10px;
      border:1px solid rgba(255,255,255,.12);backdrop-filter: blur(6px);
      z-index:30;display:none;font-size:13px;max-width: 720px;
    }

    #block-selector{
      position:absolute;bottom:10px;left:50%;transform:translateX(-50%);z-index:10;
      background:rgba(0,0,0,.55);padding:8px;border-radius:10px;display:flex;gap:8px;
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
    }
    .block-option{width:36px;height:36px;border:2px solid transparent;border-radius:6px;cursor:pointer;pointer-events:auto}
    .block-option.selected{border-color:#fff}

    #reset-btn{
      position:absolute;top:10px;right:10px;z-index:10;
      background:rgba(255,0,0,.75);color:#fff;border:none;padding:10px 12px;border-radius:10px;
      cursor:pointer;pointer-events:auto
    }
    #reset-btn:hover{background:rgba(255,0,0,.92)}

    #overlay{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.7);color:#fff;z-index:20
    }
    #overlay .card{
      max-width:620px;padding:24px;border-radius:14px;background:rgba(20,20,20,.92);
      text-align:center;line-height:1.55;box-shadow:0 10px 30px rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12)
    }
    #overlay h1{margin:0 0 8px;font-size:22px}
    #overlay p{margin:6px 0;opacity:.9}
    #overlay .hint{opacity:.8;font-size:13px}
    code{background:rgba(255,255,255,.08);padding:.15em .35em;border-radius:6px}
  </style>
</head>
<body>
  <div id="crosshair"></div>

  <div id="toast"></div>

  <div id="ui">
    <div><b>WASD</b> mover • <b>Ratón</b> mirar</div>
    <div><b>Espacio</b> saltar • <b>Clic izq.</b> quitar • <b>Clic der.</b> poner</div>
    <div class="muted"><b>1/2/3</b> tipo bloque • <b>R</b> reaparecer • Autoguardado (delta)</div>
    <div class="muted">
      Render: <b>superficie del terreno</b> suavizada (malla) + <b>bloques editados</b> cúbicos.
      Base “top” cúbico oculto.
    </div>
  </div>

  <div id="block-selector">
    <div class="block-option selected" data-type="grass" style="background:#4CAF50" title="Hierba (1)"></div>
    <div class="block-option" data-type="dirt"  style="background:#795548" title="Tierra (2)"></div>
    <div class="block-option" data-type="stone" style="background:#9E9E9E" title="Piedra (3)"></div>
  </div>

  <button id="reset-btn">Reiniciar mundo</button>

  <div id="overlay">
    <div class="card">
      <h1>Voxel + Terreno Suavizado (Opción A)</h1>
      <p>Clic para empezar • Ratón para mirar</p>
      <p><b>WASD</b> mover • <b>Espacio</b> saltar • <b>Clic izq.</b> quitar • <b>Clic der.</b> poner</p>
      <p><b>1/2/3</b> elegir bloque • <b>R</b> reaparecer • Autoguarda</p>
      <p class="hint">
        La lógica sigue siendo voxel (DDA + colisión por bloques), pero el <b>terreno natural</b>
        se renderiza como una <b>malla suavizada</b>. Los <b>bloques colocados por el jugador</b>
        se ven cúbicos.
        <br/>Guardado: solo <b>deltas</b> (ediciones), evita <code>QuotaExceededError</code>.
      </p>
    </div>
  </div>

  <!-- Three r128 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>

  <script>
  // ============================================================
  //  CONFIG
  // ============================================================
  const CONFIG = {
    CHUNK_SIZE: 16,
    CHUNK_HEIGHT: 64,

    VIEW_DISTANCE_CHUNKS: 7,
    VISIBILITY_RADIUS_BLOCKS: 120,
    SHADOW_RADIUS_BLOCKS: 22,

    SEA_LEVEL: 10,
    HEIGHT_SCALE: 22,
    TERRAIN_BASE_FREQ: 0.0045,
    TERRAIN_OCTAVES: 5,
    TERRAIN_PERSISTENCE: 0.52,
    TERRAIN_LACUNARITY: 2.05,
    RIDGE_STRENGTH: 0.8,

    // Suavizado de superficie
    SURFACE_SMOOTH_STRENGTH: 0.65,
    SURFACE_Y_BIAS: 0.0,

    CLOUDS: {
      ENABLED: true,
      BASE_Y: 48,
      THICKNESS: 4,
      FREQ: 0.010,
      COVERAGE: 0.52,
      ALPHA: 0.42
    },

    PLAYER: {
      HEIGHT: 1.8,
      RADIUS: 0.32,
      SPEED: 5.4,
      JUMP: 8.2,
      GRAVITY: -20.0
    },

    FOG_NEAR: 30,
    FOG_FAR: 150,

    SAVE_KEY: 'voxelSmoothWorld_v2_delta',
    AUTOSAVE_SECONDS: 10,

    MAX_INSTANCES_PER_CHUNK_PER_TYPE: 9000,
    MAX_INSTANCES_CLOUD_PER_CHUNK: 4500,

    // cuánto “por encima” del terreno natural permitimos considerar para bloques colocados
    MAX_BUILD_Y_ABOVE_GROUND: 64
  };

  const BLOCK_TYPES = ['grass','dirt','stone','cloud'];
  const SOLID_TYPES = ['grass','dirt','stone'];
  const COLORS = {
    grass: 0x4CAF50,
    dirt:  0x795548,
    stone: 0x9E9E9E,
    cloud: 0xFFFFFF
  };

  // ============================================================
  //  UTILS
  // ============================================================
  const key = (x,y,z)=> `${x}|${y}|${z}`;
  const colKey = (x,z)=> `${x}|${z}`;
  const chunkKey = (cx,cz)=> `${cx}|${cz}`;
  const floorDiv = (n, d) => Math.floor(n / d);
  const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));
  const lerp = (a,b,t)=> a + (b-a)*t;

  function showToast(msg, ms=3500){
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.style.display = 'block';
    clearTimeout(showToast._tt);
    showToast._tt = setTimeout(()=> t.style.display='none', ms);
  }

  // Hash 2D (sin BigInt; evita “Cannot mix BigInt…”)
  function hash2D(ix, iz, seed=1337){
    let x = (ix | 0) * 374761393;
    let z = (iz | 0) * 668265263;
    let h = (x ^ z) ^ (seed|0);
    h = (h ^ (h >>> 13)) * 1274126177;
    h = (h ^ (h >>> 16)) >>> 0;
    return h;
  }
  function rand2D(ix, iz, seed=1337){
    return (hash2D(ix, iz, seed) & 0xFFFFFF) / 0x1000000;
  }

  function smoothstep(t){ return t*t*(3-2*t); }
  function valueNoise2(x, z, seed=1337){
    const x0 = Math.floor(x), z0 = Math.floor(z);
    const x1 = x0 + 1, z1 = z0 + 1;
    const sx = smoothstep(x - x0);
    const sz = smoothstep(z - z0);

    const n00 = rand2D(x0, z0, seed);
    const n10 = rand2D(x1, z0, seed);
    const n01 = rand2D(x0, z1, seed);
    const n11 = rand2D(x1, z1, seed);

    const ix0 = lerp(n00, n10, sx);
    const ix1 = lerp(n01, n11, sx);
    return lerp(ix0, ix1, sz) * 2 - 1; // [-1..1]
  }

  function fbmRidge(x, z, seed=1337){
    let amp = 1.0;
    let freq = CONFIG.TERRAIN_BASE_FREQ;
    let sum = 0;
    let norm = 0;

    for (let o=0; o<CONFIG.TERRAIN_OCTAVES; o++){
      const n = valueNoise2(x*freq, z*freq, seed + o*1013); // [-1..1]
      const r = 1.0 - Math.abs(n); // [0..1]
      const ridge = Math.pow(r, 1.7);
      const blend = lerp((n+1)*0.5, ridge, CONFIG.RIDGE_STRENGTH);
      sum += blend * amp;
      norm += amp;
      amp *= CONFIG.TERRAIN_PERSISTENCE;
      freq *= CONFIG.TERRAIN_LACUNARITY;
    }
    return sum / Math.max(1e-6, norm); // ~[0..1]
  }

  // ============================================================
  //  SHARED RESOURCES
  // ============================================================
  const SHARED = {
    boxGeom: new THREE.BoxGeometry(1,1,1),
    mats: {},
    tex: {}
  };

  function makeCanvasTexture(hex) {
    if (SHARED.tex[hex]) return SHARED.tex[hex];
    const r=(hex>>16)&255, g=(hex>>8)&255, b=hex&255;
    const c = document.createElement('canvas'); c.width = 64; c.height = 64;
    const ctx = c.getContext('2d');
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0,0,64,64);

    // “grano”
    ctx.globalAlpha = 0.35;
    for (let i=0;i<240;i++){
      const x=Math.random()*64, y=Math.random()*64, s=Math.random()*3+1;
      const br = Math.random()*60-30;
      ctx.fillStyle = `rgb(${clamp(r+br,0,255)},${clamp(g+br,0,255)},${clamp(b+br,0,255)})`;
      ctx.fillRect(x,y,s,s);
    }

    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.magFilter = tex.minFilter = THREE.NearestFilter;
    tex.generateMipmaps = false;
    SHARED.tex[hex] = tex;
    return tex;
  }

  function getMaterial(type){
    if (SHARED.mats[type]) return SHARED.mats[type];

    if (type === 'cloud'){
      const mat = new THREE.MeshLambertMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: CONFIG.CLOUDS.ALPHA,
        depthWrite: false
      });
      SHARED.mats[type] = mat;
      return mat;
    }

    const color = COLORS[type] ?? COLORS.grass;
    const mat = new THREE.MeshPhongMaterial({
      color,
      map: makeCanvasTexture(color)
    });
    SHARED.mats[type] = mat;
    return mat;
  }

  // ============================================================
  //  CHUNK (render-only containers)
  // ============================================================
  class Chunk {
    constructor(cx, cz, scene){
      this.cx = cx; this.cz = cz;
      this.scene = scene;

      this.size = CONFIG.CHUNK_SIZE;
      this.height = CONFIG.CHUNK_HEIGHT;

      this.instByType = new Map();
      for (const type of SOLID_TYPES){
        const mesh = new THREE.InstancedMesh(
          SHARED.boxGeom,
          getMaterial(type),
          CONFIG.MAX_INSTANCES_PER_CHUNK_PER_TYPE
        );
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        mesh.frustumCulled = false;
        mesh.visible = true;
        mesh.count = 0;
        this.scene.add(mesh);
        this.instByType.set(type, { mesh, count:0, idToPos:[], posToId:new Map() });
      }

      // Clouds
      this.cloudMesh = new THREE.InstancedMesh(
        SHARED.boxGeom,
        getMaterial('cloud'),
        CONFIG.MAX_INSTANCES_CLOUD_PER_CHUNK
      );
      this.cloudMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      this.cloudMesh.castShadow = false;
      this.cloudMesh.receiveShadow = false;
      this.cloudMesh.frustumCulled = false;
      this.cloudMesh.visible = CONFIG.CLOUDS.ENABLED;
      this.cloudMesh.count = 0;
      this.scene.add(this.cloudMesh);
      this.cloudCount = 0;

      // Smooth surface mesh
      this.surface = null;
      this.surfaceGeom = null;

      this.minX = cx*this.size;
      this.minZ = cz*this.size;
      this.maxX = this.minX + this.size;
      this.maxZ = this.minZ + this.size;
    }

    dispose(){
      for (const [,pack] of this.instByType){
        this.scene.remove(pack.mesh);
        pack.mesh.geometry.dispose();
      }
      this.scene.remove(this.cloudMesh);
      this.cloudMesh.geometry.dispose();

      if (this.surface){
        this.scene.remove(this.surface);
        this.surface.geometry.dispose();
      }
    }

    clearInstancing(){
      for (const t of SOLID_TYPES){
        const pack = this.instByType.get(t);
        pack.count = 0; pack.idToPos.length = 0; pack.posToId.clear();
        pack.mesh.count = 0;
        pack.mesh.instanceMatrix.needsUpdate = true;
      }
    }

    instAdd(type, x,y,z){
      const pack = this.instByType.get(type);
      if (!pack) return;
      const k = key(x,y,z);
      if (pack.posToId.has(k)) return;

      const id = pack.count++;
      if (id >= CONFIG.MAX_INSTANCES_PER_CHUNK_PER_TYPE) return;

      const m = new THREE.Matrix4().makeTranslation(x+0.5,y+0.5,z+0.5);
      pack.mesh.setMatrixAt(id, m);
      pack.mesh.instanceMatrix.needsUpdate = true;
      pack.idToPos[id] = {x,y,z};
      pack.posToId.set(k, id);
      pack.mesh.count = pack.count;
    }

    cloudAdd(x,y,z){
      const id = this.cloudCount++;
      if (id >= CONFIG.MAX_INSTANCES_CLOUD_PER_CHUNK) return;
      const m = new THREE.Matrix4().makeTranslation(x+0.5,y+0.5,z+0.5);
      this.cloudMesh.setMatrixAt(id, m);
      this.cloudMesh.instanceMatrix.needsUpdate = true;
      this.cloudMesh.count = this.cloudCount;
    }
    cloudClear(){
      this.cloudCount = 0;
      this.cloudMesh.count = 0;
      this.cloudMesh.instanceMatrix.needsUpdate = true;
    }

    setVisible(v){
      for (const [,pack] of this.instByType){
        pack.mesh.visible = v && pack.count>0;
      }
      this.cloudMesh.visible = v && CONFIG.CLOUDS.ENABLED && this.cloudCount>0;
      if (this.surface) this.surface.visible = v;
    }
    setShadowsEnabled(near){
      for (const [,pack] of this.instByType){
        pack.mesh.castShadow = near;
        pack.mesh.receiveShadow = near;
      }
      if (this.surface){
        this.surface.castShadow = near;
        this.surface.receiveShadow = near;
      }
    }

    rebuildSurface(surfaceHeightFn, surfaceTopTypeFn){
      const N = this.size;
      const verts = (N+1)*(N+1);

      const positions = new Float32Array(verts*3);
      const colors    = new Float32Array(verts*3);
      const idx = [];
      const colorTmp = new THREE.Color();

      const hs = new Float32Array(verts);

      for (let dz=0; dz<=N; dz++){
        for (let dx=0; dx<=N; dx++){
          const wx = this.minX + dx;
          const wz = this.minZ + dz;

          const h00 = surfaceHeightFn(wx, wz);
          const h10 = surfaceHeightFn(wx-1, wz);
          const h01 = surfaceHeightFn(wx, wz-1);
          const h11 = surfaceHeightFn(wx-1, wz-1);

          let h = (h00 + h10 + h01 + h11) * 0.25;

          let s = 0, c = 0;
          for (let oz=-1; oz<=1; oz++){
            for (let ox=-1; ox<=1; ox++){
              s += surfaceHeightFn(wx+ox, wz+oz); c++;
            }
          }
          const hAvg = s / c;
          h = lerp(h, hAvg, CONFIG.SURFACE_SMOOTH_STRENGTH);

          hs[dz*(N+1)+dx] = h + CONFIG.SURFACE_Y_BIAS;
        }
      }

      for (let dz=0; dz<=N; dz++){
        for (let dx=0; dx<=N; dx++){
          const i = dz*(N+1)+dx;
          const wx = this.minX + dx;
          const wz = this.minZ + dz;

          const h = hs[i];
          positions[i*3+0] = wx;
          positions[i*3+1] = h;
          positions[i*3+2] = wz;

          const t = surfaceTopTypeFn(wx, wz);
          const col = COLORS[t] ?? COLORS.grass;
          colorTmp.setHex(col);
          colors[i*3+0] = colorTmp.r;
          colors[i*3+1] = colorTmp.g;
          colors[i*3+2] = colorTmp.b;
        }
      }

      // CCW desde arriba
      for (let z=0; z<N; z++){
        for (let x=0; x<N; x++){
          const a =  z    *(N+1) + x;
          const b =  z    *(N+1) + x+1;
          const c = (z+1) *(N+1) + x;
          const d = (z+1) *(N+1) + x+1;
          idx.push(a, c, b);
          idx.push(b, c, d);
        }
      }

      if (this.surfaceGeom){
        this.surfaceGeom.dispose();
      }
      this.surfaceGeom = new THREE.BufferGeometry();
      this.surfaceGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      this.surfaceGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      this.surfaceGeom.setIndex(idx);
      this.surfaceGeom.computeVertexNormals();

      const mat = Chunk.surfaceMaterial();
      if (!this.surface){
        this.surface = new THREE.Mesh(this.surfaceGeom, mat);
        this.surface.frustumCulled = false;
        this.surface.castShadow = true;
        this.surface.receiveShadow = true;
        this.scene.add(this.surface);
      } else {
        this.surface.geometry = this.surfaceGeom;
      }
    }

    static surfaceMaterial(){
      if (Chunk._surfMat) return Chunk._surfMat;
      Chunk._surfMat = new THREE.MeshStandardMaterial({
        vertexColors: true,
        roughness: 0.95,
        metalness: 0.0
      });
      return Chunk._surfMat;
    }
  }

  // ============================================================
  //  WORLD (procedural base + edit deltas)
  // ============================================================
  class World {
    constructor(scene){
      this.scene = scene;
      this.chunks = new Map();

      // Edits only:
      // - value === null  => removed (air)
      // - value === 'grass'|'dirt'|'stone' => forced block (placed/changed)
      this.edits = new Map(); // key(x,y,z) -> (string|null)

      // Column caches for surface:
      // surfaceHeight = natural baseTop reduced by removals (but NOT increased by additions)
      this.surfaceHeightCache = new Map(); // colKey(x,z)-> int
      this.surfaceTopTypeCache = new Map(); // colKey(x,z)-> type

      // Track highest placed block per column (above base) so we can render builds
      this.columnMaxY = new Map(); // colKey(x,z)-> int (max y where an edit places a solid); -inf if none

      // Natural caches
      this.heightCache = new Map();    // colKey(x,z)-> int (natural)
      this.topTypeCache = new Map();   // colKey(x,z)-> type (natural)
    }

    // ---- NATURAL TERRAIN ----
    naturalHeightAt(x,z){
      const ck = colKey(x,z);
      const cached = this.heightCache.get(ck);
      if (cached !== undefined) return cached;

      const n = fbmRidge(x, z, 424242); // 0..1
      const m = Math.pow(n, 1.35);
      const h = Math.floor(CONFIG.SEA_LEVEL + m * CONFIG.HEIGHT_SCALE);
      this.heightCache.set(ck, h);
      return h;
    }

    naturalTopTypeAt(x,z){
      const ck = colKey(x,z);
      const cached = this.topTypeCache.get(ck);
      if (cached) return cached;

      const h = this.naturalHeightAt(x,z);
      let t = 'grass';
      if (h > CONFIG.SEA_LEVEL + 16) t = 'stone';
      else if (h > CONFIG.SEA_LEVEL + 6) t = 'dirt';
      this.topTypeCache.set(ck, t);
      return t;
    }

    naturalBlockAt(x,y,z){
      const h = this.naturalHeightAt(x,z);
      if (y<0 || y>CONFIG.CHUNK_HEIGHT-1) return null;
      if (y>h) return null;

      if (y === h) return this.naturalTopTypeAt(x,z);
      if (y >= h-3) return 'dirt';
      return 'stone';
    }

    // ---- EDIT-AWARE BLOCK QUERY (logic uses voxels) ----
    getBlock(x,y,z){
      const ek = key(x,y,z);
      if (this.edits.has(ek)){
        return this.edits.get(ek); // can be null (air) or type
      }
      return this.naturalBlockAt(x,y,z);
    }

    hasBlock(x,y,z){
      return this.getBlock(x,y,z) !== null;
    }

    // “surface height” for smoothed mesh:
    // - start at natural top (baseH)
    // - if blocks removed from top, surface goes down
    // - if player adds blocks above baseH, mesh does NOT go up (blocks remain cubic)
    surfaceHeightAt(x,z){
      const ck = colKey(x,z);
      const cached = this.surfaceHeightCache.get(ck);
      if (cached !== undefined) return cached;

      const baseH = this.naturalHeightAt(x,z);

      // search downward from baseH until we find a solid (could be forced air by edits)
      let y = baseH;
      while (y >= 0){
        const t = this.getBlock(x,y,z);
        if (t !== null) break;
        y--;
      }
      if (y < 0) y = 0;

      this.surfaceHeightCache.set(ck, y);

      // top type for vertex color: prefer actual type at surface
      const tt = this.getBlock(x,y,z) || 'grass';
      this.surfaceTopTypeCache.set(ck, tt);

      return y;
    }

    surfaceTopTypeAt(x,z){
      const ck = colKey(x,z);
      const cached = this.surfaceTopTypeCache.get(ck);
      if (cached) return cached;
      // ensure cache is computed
      this.surfaceHeightAt(x,z);
      return this.surfaceTopTypeCache.get(ck) || 'grass';
    }

    // Highest y we need to render cubes up to (natural base + placed blocks)
    renderMaxYAt(x,z){
      const baseH = this.naturalHeightAt(x,z);
      const ck = colKey(x,z);
      const maxPlaced = this.columnMaxY.get(ck);
      if (maxPlaced === undefined) return baseH;
      return Math.max(baseH, maxPlaced);
    }

    // Is this coordinate part of the “natural surface cube” that we hide?
    // We hide cubes that are exactly at surfaceHeight AND are not an explicitly placed edit.
    shouldHideNaturalSurfaceCube(x,y,z){
      const ek = key(x,y,z);
      if (this.edits.has(ek)) return false; // explicit edits stay cubic/visible
      const sy = this.surfaceHeightAt(x,z);
      // only hide if it's exactly the surface level (natural terrain layer)
      return y === sy;
    }

    // ---- EDITS ----
    setBlock(x,y,z,type){
      if (y < 0 || y >= CONFIG.CHUNK_HEIGHT) return;

      const ek = key(x,y,z);
      const prev = this.edits.has(ek) ? this.edits.get(ek) : undefined;

      // Determine what would be there naturally
      const nat = this.naturalBlockAt(x,y,z);

      // If setting to same as natural, we can remove the edit (no delta needed)
      // If setting to null (air) and natural already air => remove edit too.
      if (type === nat){
        this.edits.delete(ek);
      } else {
        // store delta (type or null)
        this.edits.set(ek, type);
      }

      // Column caches invalidation
      const ck = colKey(x,z);
      this.surfaceHeightCache.delete(ck);
      this.surfaceTopTypeCache.delete(ck);

      // Update max placed y tracker
      // Only count solid placed blocks (type string), and only when it is ABOVE natural base
      // (still safe if inside base; it won't hurt to track, but we clamp)
      const baseH = this.naturalHeightAt(x,z);

      // recompute maxPlaced cheaply for this column:
      // we track only edits in this column. Since chunk is small, scanning is OK.
      // (this avoids unbounded growth logic complexity).
      let maxY = -Infinity;

      // scan a reasonable range: 0..min(CHUNK_HEIGHT-1, baseH+MAX_BUILD_Y_ABOVE_GROUND)
      const yMaxScan = Math.min(CONFIG.CHUNK_HEIGHT-1, baseH + CONFIG.MAX_BUILD_Y_ABOVE_GROUND);
      for (let yy=0; yy<=yMaxScan; yy++){
        const k2 = key(x,yy,z);
        if (!this.edits.has(k2)) continue;
        const v = this.edits.get(k2);
        if (v !== null) maxY = Math.max(maxY, yy);
      }
      if (maxY === -Infinity) this.columnMaxY.delete(ck);
      else this.columnMaxY.set(ck, maxY);

      // If player changed surface height, surface mesh must update; we rebuild affected chunks outside.
    }

    // ---- CHUNKS ----
    getChunk(cx,cz, create=false){
      const ck = chunkKey(cx,cz);
      let ch = this.chunks.get(ck);
      if (!ch && create){
        ch = new Chunk(cx,cz,this.scene);
        this.chunks.set(ck,ch);
      }
      return ch;
    }

    buildChunk(cx,cz){
      const ch = this.getChunk(cx,cz,true);

      ch.clearInstancing();
      ch.cloudClear();

      const minX = cx*CONFIG.CHUNK_SIZE;
      const minZ = cz*CONFIG.CHUNK_SIZE;

      // Build solid cubes:
      // - Render all solids except the natural “surface cube” (hidden), so terrain appears smoothed.
      // - Render any explicit edits as cubes (including those at surface).
      for (let dz=0; dz<CONFIG.CHUNK_SIZE; dz++){
        for (let dx=0; dx<CONFIG.CHUNK_SIZE; dx++){
          const x = minX + dx;
          const z = minZ + dz;

          const yMax = this.renderMaxYAt(x,z);
          for (let y=0; y<=yMax; y++){
            const t = this.getBlock(x,y,z);
            if (!t || t === 'cloud') continue;

            // Hide only the natural surface cube (so mesh shows instead)
            if (this.shouldHideNaturalSurfaceCube(x,y,z)) continue;

            ch.instAdd(t, x,y,z);
          }
        }
      }

      // Clouds
      if (CONFIG.CLOUDS.ENABLED){
        this.buildCloudChunk(cx,cz);
      }

      // Surface mesh: uses surfaceHeightAt (affected by removals), and surfaceTopTypeAt
      ch.rebuildSurface(
        (x,z)=> this.surfaceHeightAt(x,z),
        (x,z)=> this.surfaceTopTypeAt(x,z)
      );

      return ch;
    }

    buildCloudChunk(cx,cz){
      const ch = this.getChunk(cx,cz,true);
      ch.cloudClear();

      const minX = cx*CONFIG.CHUNK_SIZE;
      const minZ = cz*CONFIG.CHUNK_SIZE;

      const baseY = CONFIG.CLOUDS.BASE_Y;
      const thick = CONFIG.CLOUDS.THICKNESS;

      for (let dz=0; dz<CONFIG.CHUNK_SIZE; dz++){
        for (let dx=0; dx<CONFIG.CHUNK_SIZE; dx++){
          const x = minX + dx;
          const z = minZ + dz;

          const n = valueNoise2(x*CONFIG.CLOUDS.FREQ, z*CONFIG.CLOUDS.FREQ, 9999);
          const v = (n+1)*0.5;
          if (v < CONFIG.CLOUDS.COVERAGE) continue;

          const t = (v - CONFIG.CLOUDS.COVERAGE) / (1.0 - CONFIG.CLOUDS.COVERAGE);
          const layers = 1 + Math.floor(t * (thick-1));

          for (let i=0; i<layers; i++){
            const y = baseY + i;
            ch.cloudAdd(x,y,z);
          }
        }
      }
    }

    ensureChunksAround(playerPos){
      const cs = CONFIG.CHUNK_SIZE;
      const pcx = floorDiv(Math.floor(playerPos.x), cs);
      const pcz = floorDiv(Math.floor(playerPos.z), cs);
      const r = CONFIG.VIEW_DISTANCE_CHUNKS;

      for (let dz=-r; dz<=r; dz++){
        for (let dx=-r; dx<=r; dx++){
          const cx = pcx + dx;
          const cz = pcz + dz;
          const ck = chunkKey(cx,cz);
          if (!this.chunks.has(ck)){
            this.buildChunk(cx,cz);
          }
        }
      }

      const visR2 = CONFIG.VISIBILITY_RADIUS_BLOCKS*CONFIG.VISIBILITY_RADIUS_BLOCKS;
      const shR2  = CONFIG.SHADOW_RADIUS_BLOCKS*CONFIG.SHADOW_RADIUS_BLOCKS;

      for (const [,ch] of this.chunks){
        const centerX = (ch.cx + 0.5)*cs;
        const centerZ = (ch.cz + 0.5)*cs;
        const dx = centerX - playerPos.x;
        const dz = centerZ - playerPos.z;
        const d2 = dx*dx + dz*dz;

        const visible = d2 <= visR2;
        const shadows = d2 <= shR2;

        ch.setVisible(visible);
        ch.setShadowsEnabled(shadows);
      }
    }

    // Rebuild visuals for a chunk (procedural base + deltas)
    rebuildChunk(cx,cz){
      this.buildChunk(cx,cz);
    }

    // ---- SAVE/LOAD (delta only) ----
    serializeEdits(){
      const out = [];
      for (const [k,v] of this.edits){
        const [x,y,z] = k.split('|').map(Number);
        // store '' for air (null), otherwise type
        out.push([x,y,z, v === null ? '' : v]);
      }
      return out;
    }

    deserializeEdits(list){
      this.edits.clear();
      this.surfaceHeightCache.clear();
      this.surfaceTopTypeCache.clear();
      this.columnMaxY.clear();

      if (!Array.isArray(list)) return;

      // Apply edits
      for (const row of list){
        if (!row || row.length < 4) continue;
        const x = row[0]|0, y = row[1]|0, z = row[2]|0;
        const t = row[3];
        const v = (t === '' ? null : t);
        this.edits.set(key(x,y,z), v);
      }

      // Recompute columnMaxY (cheap pass)
      // Note: for performance, we only compute for columns we touched
      const touchedCols = new Set();
      for (const [k,v] of this.edits){
        if (v === null) continue;
        const parts = k.split('|');
        const x = parts[0], z = parts[2];
        touchedCols.add(`${x}|${z}`);
      }
      for (const ck of touchedCols){
        const [xs,zs] = ck.split('|');
        const x = xs|0, z = zs|0;
        const baseH = this.naturalHeightAt(x,z);
        const yMaxScan = Math.min(CONFIG.CHUNK_HEIGHT-1, baseH + CONFIG.MAX_BUILD_Y_ABOVE_GROUND);
        let maxY = -Infinity;
        for (let yy=0; yy<=yMaxScan; yy++){
          const k2 = key(x,yy,z);
          if (!this.edits.has(k2)) continue;
          const vv = this.edits.get(k2);
          if (vv !== null) maxY = Math.max(maxY, yy);
        }
        if (maxY !== -Infinity) this.columnMaxY.set(ck, maxY);
      }
    }
  }

  // ============================================================
  //  VOXEL RAYCAST (DDA)
  // ============================================================
  function voxelRaycast(world, origin, dir, maxDist=10){
    let x = Math.floor(origin.x);
    let y = Math.floor(origin.y);
    let z = Math.floor(origin.z);

    const stepX = dir.x > 0 ? 1 : -1;
    const stepY = dir.y > 0 ? 1 : -1;
    const stepZ = dir.z > 0 ? 1 : -1;

    const tDeltaX = (dir.x !== 0) ? Math.abs(1 / dir.x) : Infinity;
    const tDeltaY = (dir.y !== 0) ? Math.abs(1 / dir.y) : Infinity;
    const tDeltaZ = (dir.z !== 0) ? Math.abs(1 / dir.z) : Infinity;

    const frac = (v)=> v - Math.floor(v);

    let tMaxX = (dir.x > 0 ? (1 - frac(origin.x)) : frac(origin.x)) * tDeltaX;
    let tMaxY = (dir.y > 0 ? (1 - frac(origin.y)) : frac(origin.y)) * tDeltaY;
    let tMaxZ = (dir.z > 0 ? (1 - frac(origin.z)) : frac(origin.z)) * tDeltaZ;

    let hitNormal = new THREE.Vector3(0,0,0);

    let t = 0;
    const maxT = maxDist;

    for (let i=0; i<900; i++){
      const type = world.getBlock(x,y,z);
      if (type && type !== 'cloud'){
        return { x,y,z, type, t, normal: hitNormal.clone() };
      }

      if (tMaxX < tMaxY){
        if (tMaxX < tMaxZ){
          x += stepX;
          t = tMaxX;
          tMaxX += tDeltaX;
          hitNormal.set(-stepX,0,0);
        } else {
          z += stepZ;
          t = tMaxZ;
          tMaxZ += tDeltaZ;
          hitNormal.set(0,0,-stepZ);
        }
      } else {
        if (tMaxY < tMaxZ){
          y += stepY;
          t = tMaxY;
          tMaxY += tDeltaY;
          hitNormal.set(0,-stepY,0);
        } else {
          z += stepZ;
          t = tMaxZ;
          tMaxZ += tDeltaZ;
          hitNormal.set(0,0,-stepZ);
        }
      }

      if (t > maxT) break;
    }
    return null;
  }

  // ============================================================
  //  GAME
  // ============================================================
  class Game {
    constructor(){
      this.scene = new THREE.Scene();
      this.scene.fog = new THREE.Fog(0xCFE9FF, CONFIG.FOG_NEAR, CONFIG.FOG_FAR);

      this.camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 800);
      this.camera.position.set(0, 24, 0);

      this.renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:'high-performance' });
      this.renderer.setSize(innerWidth, innerHeight);
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(this.renderer.domElement);

      this.addGradientSky();

      const amb = new THREE.AmbientLight(0xffffff, 0.70);
      this.scene.add(amb);

      const sun = new THREE.DirectionalLight(0xffffff, 1.35);
      sun.position.set(70, 90, 40);
      sun.castShadow = true;
      sun.shadow.mapSize.set(1024,1024);
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 260;
      sun.shadow.camera.left = -110;
      sun.shadow.camera.right = 110;
      sun.shadow.camera.top = 110;
      sun.shadow.camera.bottom = -110;
      this.scene.add(sun);

      this.controls = new THREE.PointerLockControls(this.camera, document.body);
      const overlay = document.getElementById('overlay');
      document.body.addEventListener('click', ()=>{
        if (!this.controls.isLocked) this.controls.lock();
      });
      this.controls.addEventListener('lock', ()=> overlay.style.display='none');
      this.controls.addEventListener('unlock', ()=> overlay.style.display='flex');

      this.move = { f:false,b:false,l:false,r:false,j:false };

      addEventListener('keydown', (e)=>{
        if (e.code==='KeyW') this.move.f=true;
        if (e.code==='KeyS') this.move.b=true;
        if (e.code==='KeyA') this.move.l=true;
        if (e.code==='KeyD') this.move.r=true;
        if (e.code==='Space' && this.onGround) this.move.j=true;

        if (e.code==='Digit1') this.selectBlock('grass');
        if (e.code==='Digit2') this.selectBlock('dirt');
        if (e.code==='Digit3') this.selectBlock('stone');

        if (e.code==='KeyR') this.respawn();
      });
      addEventListener('keyup', (e)=>{
        if (e.code==='KeyW') this.move.f=false;
        if (e.code==='KeyS') this.move.b=false;
        if (e.code==='KeyA') this.move.l=false;
        if (e.code==='KeyD') this.move.r=false;
        if (e.code==='Space') this.move.j=false;
      });

      this.selectedType = 'grass';
      const opts = document.querySelectorAll('.block-option');
      opts.forEach(o=>o.addEventListener('click', ()=>{
        opts.forEach(p=>p.classList.remove('selected'));
        o.classList.add('selected');
        this.selectedType = o.dataset.type;
      }));

      document.getElementById('reset-btn').addEventListener('click', ()=>{
        if (confirm('¿Reiniciar el mundo? Se perderán cambios.')){
          localStorage.removeItem(CONFIG.SAVE_KEY);
          location.reload();
        }
      });

      addEventListener('contextmenu', e=> e.preventDefault());
      addEventListener('mousedown', (e)=>{
        if (!this.controls.isLocked) return;
        if (!this.world) return;
        if (e.button===0) this.removeBlockAtPointer();
        if (e.button===2) this.placeBlockAtPointer();
      });

      addEventListener('resize', ()=>{
        this.camera.aspect = innerWidth/innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(innerWidth, innerHeight);
      });

      this.world = new World(this.scene);

      this.velocity = new THREE.Vector3();
      this.onGround = false;

      this.clock = new THREE.Clock();
      this.autoSaveAcc = 0;
      this.autosaveEnabled = true;

      this.loadWorld();

      this.world.ensureChunksAround(this.camera.position);

      this.animate();
    }

    addGradientSky(){
      const skyGeom = new THREE.SphereGeometry(500, 32, 16);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          topColor:    { value: new THREE.Color(0x2F80FF) },
          bottomColor: { value: new THREE.Color(0xFFFFFF) },
          offset:      { value: 0.0 },
          exponent:    { value: 0.8 }
        },
        vertexShader: `
          varying vec3 vWorldPosition;
          void main() {
            vec4 wp = modelMatrix * vec4(position, 1.0);
            vWorldPosition = wp.xyz;
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader: `
          uniform vec3 topColor;
          uniform vec3 bottomColor;
          uniform float offset;
          uniform float exponent;
          varying vec3 vWorldPosition;
          void main() {
            float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
            float t = pow(max(h, 0.0), exponent);
            vec3 col = mix(bottomColor, topColor, t);
            gl_FragColor = vec4(col, 1.0);
          }
        `
      });
      const sky = new THREE.Mesh(skyGeom, skyMat);
      sky.frustumCulled = false;
      this.scene.add(sky);
    }

    selectBlock(t){
      this.selectedType = t;
      const opts = document.querySelectorAll('.block-option');
      opts.forEach(o=> o.classList.toggle('selected', o.dataset.type===t));
    }

    respawn(){
      const x = Math.floor(this.camera.position.x);
      const z = Math.floor(this.camera.position.z);
      const h = this.world.surfaceHeightAt(x,z);
      this.camera.position.set(x+0.5, h+6, z+0.5);
      this.velocity.set(0,0,0);
    }

    saveWorld(){
      if (!this.autosaveEnabled) return;

      const data = {
        edits: this.world.serializeEdits(),
        player: { x:this.camera.position.x, y:this.camera.position.y, z:this.camera.position.z }
      };

      try{
        localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(data));
      }catch(e){
        // Avoid spam + disable autosave
        this.autosaveEnabled = false;
        console.warn('Autosave desactivado:', e);
        showToast('Autoguardado desactivado: almacenamiento del navegador lleno. (Se guardan deltas, pero tu navegador está sin espacio).');
      }
    }

    loadWorld(){
      const raw = localStorage.getItem(CONFIG.SAVE_KEY);
      if (!raw){
        const h = this.world.surfaceHeightAt(0,0);
        this.camera.position.set(0.5, h+10, 0.5);
        return;
      }
      try{
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed.edits)){
          this.world.deserializeEdits(parsed.edits);
        }
        if (parsed.player){
          this.camera.position.set(parsed.player.x, parsed.player.y, parsed.player.z);
        } else {
          const h = this.world.surfaceHeightAt(0,0);
          this.camera.position.set(0.5, h+10, 0.5);
        }
      }catch(e){
        console.warn('Error cargando mundo; se crea nuevo.', e);
        localStorage.removeItem(CONFIG.SAVE_KEY);
        const h = this.world.surfaceHeightAt(0,0);
        this.camera.position.set(0.5, h+10, 0.5);
      }
    }

    rebuildAffectedChunks(x,z){
      const cs = CONFIG.CHUNK_SIZE;
      const cx = floorDiv(x, cs);
      const cz = floorDiv(z, cs);

      const lx = ((x % cs) + cs) % cs;
      const lz = ((z % cs) + cs) % cs;

      const targets = new Set();
      targets.add(chunkKey(cx,cz));
      if (lx===0) targets.add(chunkKey(cx-1,cz));
      if (lx===cs-1) targets.add(chunkKey(cx+1,cz));
      if (lz===0) targets.add(chunkKey(cx,cz-1));
      if (lz===cs-1) targets.add(chunkKey(cx,cz+1));
      if (lx===0 && lz===0) targets.add(chunkKey(cx-1,cz-1));
      if (lx===0 && lz===cs-1) targets.add(chunkKey(cx-1,cz+1));
      if (lx===cs-1 && lz===0) targets.add(chunkKey(cx+1,cz-1));
      if (lx===cs-1 && lz===cs-1) targets.add(chunkKey(cx+1,cz+1));

      for (const ck of targets){
        const [tcx,tcz] = ck.split('|').map(Number);
        this.world.rebuildChunk(tcx,tcz);
      }
    }

    removeBlockAtPointer(){
      const origin = this.camera.position.clone();
      const dir = new THREE.Vector3();
      this.camera.getWorldDirection(dir);

      const hit = voxelRaycast(this.world, origin, dir, 10);
      if (!hit) return;

      // remove (air)
      this.world.setBlock(hit.x, hit.y, hit.z, null);
      this.rebuildAffectedChunks(hit.x, hit.z);
    }

    placeBlockAtPointer(){
      const origin = this.camera.position.clone();
      const dir = new THREE.Vector3();
      this.camera.getWorldDirection(dir);

      const hit = voxelRaycast(this.world, origin, dir, 10);
      if (!hit) return;

      const nx = hit.x + Math.round(hit.normal.x);
      const ny = hit.y + Math.round(hit.normal.y);
      const nz = hit.z + Math.round(hit.normal.z);

      // avoid placing inside player
      const playerPos = this.camera.position;
      const dist = new THREE.Vector3(nx+0.5, ny+0.5, nz+0.5).distanceTo(playerPos);
      if (dist < 1.4) return;

      if (!this.world.hasBlock(nx,ny,nz)){
        this.world.setBlock(nx,ny,nz,this.selectedType);
        this.rebuildAffectedChunks(nx, nz);
      }
    }

    // ---- collision with nearby voxels ----
    playerAABBAt(pos){
      const r = CONFIG.PLAYER.RADIUS;
      const h = CONFIG.PLAYER.HEIGHT;
      return new THREE.Box3(
        new THREE.Vector3(pos.x - r, pos.y - h, pos.z - r),
        new THREE.Vector3(pos.x + r, pos.y,     pos.z + r)
      );
    }

    collidesAt(pos){
      const aabb = this.playerAABBAt(pos);

      const minX = Math.floor(aabb.min.x)-1;
      const maxX = Math.floor(aabb.max.x)+1;
      const minY = Math.floor(aabb.min.y)-1;
      const maxY = Math.floor(aabb.max.y)+1;
      const minZ = Math.floor(aabb.min.z)-1;
      const maxZ = Math.floor(aabb.max.z)+1;

      for (let x=minX; x<=maxX; x++){
        for (let y=minY; y<=maxY; y++){
          for (let z=minZ; z<=maxZ; z++){
            const t = this.world.getBlock(x,y,z);
            if (!t || t==='cloud') continue;
            const bb = new THREE.Box3(
              new THREE.Vector3(x, y, z),
              new THREE.Vector3(x+1, y+1, z+1)
            );
            if (aabb.intersectsBox(bb)) return true;
          }
        }
      }
      return false;
    }

    animate(){
      requestAnimationFrame(()=>this.animate());
      const dt = Math.min(this.clock.getDelta(), 0.05);

      this.world.ensureChunksAround(this.camera.position);

      if (this.controls.isLocked){
        const dir = new THREE.Vector3();
        this.camera.getWorldDirection(dir);
        dir.y = 0; dir.normalize();
        const right = new THREE.Vector3().crossVectors(this.camera.up, dir).normalize();

        let dx=0, dz=0;
        if (this.move.f) { dx += dir.x; dz += dir.z; }
        if (this.move.b) { dx -= dir.x; dz -= dir.z; }
        if (this.move.l) { dx += right.x; dz += right.z; }
        if (this.move.r) { dx -= right.x; dz -= right.z; }

        const horiz = new THREE.Vector3(dx,0,dz);
        if (horiz.lengthSq()>0) horiz.normalize().multiplyScalar(CONFIG.PLAYER.SPEED*dt);

        const posH = this.camera.position.clone().add(horiz);
        if (!this.collidesAt(posH)){
          this.camera.position.copy(posH);
        }

        if (this.move.j && this.onGround){
          this.velocity.y = CONFIG.PLAYER.JUMP;
          this.onGround = false;
          this.move.j = false;
        }

        this.velocity.y += CONFIG.PLAYER.GRAVITY * dt;

        const posV = this.camera.position.clone();
        posV.y += this.velocity.y * dt;

        if (!this.collidesAt(posV)){
          this.camera.position.y = posV.y;
          this.onGround = false;
        } else {
          if (this.velocity.y < 0) this.onGround = true;
          this.velocity.y = 0;
        }

        if (this.camera.position.y < -30) this.respawn();
      }

      this.autoSaveAcc += dt;
      if (this.autoSaveAcc >= CONFIG.AUTOSAVE_SECONDS){
        this.autoSaveAcc = 0;
        this.saveWorld();
      }

      this.renderer.render(this.scene, this.camera);
    }
  }

  // ---- Start ----
  new Game();
  </script>
</body>
</html>

